(function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n?n:e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++) s(r[o]); return s })({
    1: [function (require, module, exports) {
            
            
            var Networks = require('bitcore').Networks
            var Node = require('../lib/node.js')
            
            node = new Node({
                network: Networks.livenet,
                path: 'data',
                acceptWeb: true
            })
            node.on('error', function (err) {
                console.error(err)
            })
            
            node.peers.on('peer', function (peer) {
                console.log('Connected to peer:', peer.remoteAddress, peer.subversion)
                peer.on('disconnect', function () {
                    console.log('Disconnected from peer:', peer.remoteAddress, peer.subversion)
                })
            })
            
            node.chain
  .on('sync', function (tip) {
                var max = node.chain.syncHeight
                if (!max && node.chain.downloadPeer) max = node.chain.downloadPeer.bestHeight
                console.log('Chain sync progress:', tip.height + ' / ' + max,
      '(' + (Math.round(tip.height / max * 1000) / 10) + '%)',
      '-', new Date(tip.header.time * 1000).toLocaleDateString())
            })
  .on('synced', function (tip) {
                console.log('Chain up-to-date. height: ' + tip.height 
      + ', hash: ' + tip.header.hash)
            })
  .on('block', function (block) {
                if (node.chain.syncing) return
                console.log('Received a new block. height: ' + block.height 
      + ', hash: ' + block.header.hash)
            })
            node.start()
            
            var w = node.createWallet('main', function (err) {
                if (err) return console.error(err)
            })
            w.on('error', function (err) {
                console.error(err.stack)
            })
            w.on('receive', function (e) {
                console.log('Received funds: ' + e.amount + ' satoshis, txid: ' + e.transaction.hash)
            })
            w.on('send', function (e) {
                console.log('Sent funds: ' + e.amount + ' satoshis, txid: ' + e.transaction.hash)
            })

        }, { "../lib/node.js": 6, "bitcore": "bitcore" }], 2: [function (require, module, exports) {
            (function (Buffer) {
                var EventEmitter = require('events').EventEmitter
                var util = require('util')
                var bitcore = require('bitcore')
                var buffertools = require('buffertools')
                var u = require('./utils.js')
                
                function cloneBuffer(a) {
                    var b = new Buffer(a.length)
                    a.copy(b)
                    return b
                }
                
                function encodeKey(hash) {
                    if (Buffer.isBuffer(hash)) return buffertools.reverse(cloneBuffer(hash)).toString('base64')
                    if (typeof hash === 'string') {
                        if (hash.length === 44) return hash
                        if (hash.length === 64) return new Buffer(hash, 'hex').toString('base64')
                    }
                    throw new Error('Invalid hash format')
                }
                
                var BlockStore = module.exports = function (opts, cb) {
                    if (typeof opts === 'function') {
                        cb = opts
                        opts = null
                    }
                    opts = opts || {}
                    
                    this.BlockHeader = opts.BlockHeader || bitcore.BlockHeader
                    
                    this.store = opts.store || u.createStore({
                        path: opts.path,
                        db: opts.db,
                        cacheSize: 32 * 1024 * 1024
                    }, cb)
                    if (opts.reset) {
                        this.store.del('tip', { keyEncoding: 'utf8' }, typeof opts.reset === 'function' ? opts.reset : null)
                    }
                }
                util.inherits(BlockStore, EventEmitter)
                
                BlockStore.prototype.put = function (block, opts, cb) {
                    if (typeof opts === 'function') {
                        cb = opts
                        opts = {}
                    }
                    if (block.height == null) return cb(new Error('Must specify height'))
                    if (block.header == null) return cb(new Error('Must specify header'))
                    if (!(block.header instanceof this.BlockHeader)) {
                        return cb(new Error('Header must be instance of BlockHeader'))
                    }
                    if (opts.tip) opts.best = true
                    
                    var self = this
                    var blockJson = {
                        height: block.height,
                        header: block.header.toBuffer().toString('base64')
                    }
                    var batch = [
                        { type: 'put', key: encodeKey(block.header.hash), value: blockJson }
                    ]
                    if (opts.best && opts.prev) {
                        var prevJson = {
                            height: opts.prev.height,
                            header: opts.prev.header.toBuffer().toString('base64'),
                            next: block.header.hash
                        }
                        batch.push({ type: 'put', key: encodeKey(opts.prev.header.hash), value: prevJson })
                    }
                    this.store.batch(batch, function (err) {
                        if (err) return cb(err)
                        if (opts.tip) {
                            return self._setTip({ height: block.height, hash: block.header.hash }, cb)
                        }
                        cb(null)
                    })
                }
                
                BlockStore.prototype.get = function (hash, cb) {
                    try {
                        var key = encodeKey(hash)
                    } catch (err) {
                        return cb(err)
                    }
                    
                    var self = this
                    this.store.get(key, function (err, block) {
                        if (err) return cb(err)
                        var header = new Buffer(block.header, 'base64')
                        block.header = self.BlockHeader.fromBuffer(header)
                        cb(null, block)
                    })
                }
                
                BlockStore.prototype._setTip = function (tip, cb) {
                    var newTip = {}
                    for (var k in tip) newTip[k] = tip[k]
                    delete newTip.header
                    this.store.put('tip', newTip, cb)
                }
                
                BlockStore.prototype.getTip = function (cb) {
                    var self = this
                    this.store.get('tip', function (err, tip) {
                        if (err) return cb(err)
                        self.get(tip.hash, function (err, block) {
                            if (err) return cb(err)
                            tip.hash = u.toHash(tip.hash)
                            tip.header = block.header
                            cb(null, tip)
                        })
                    })
                }
                
                BlockStore.prototype.close = function (cb) {
                    this.store.close(cb)
                }
                
                BlockStore.prototype.isClosed = function () {
                    return this.store.isClosed()
                }
                
                BlockStore.prototype.isOpen = function () {
                    return this.store.isOpen()
                }

            }).call(this, require("buffer").Buffer)
        }, { "./utils.js": 11, "bitcore": "bitcore", "buffer": 172, "buffertools": 58, "events": 317, "util": 342 }], 3: [function (require, module, exports) {
            var Readable = require('stream').Readable
            var util = require('util')
            var Inventory = require('bitcore-p2p').Inventory
            var u = require('./utils.js')
            
            var BlockStream = module.exports = function (opts) {
                if (!opts.peer) throw new Error('"peer" option is required for BlockStream')
                if (!opts.chain) throw new Error('"chain" option is required for BlockStream')
                Readable.call(this, { objectMode: true })
                
                opts = opts || {}
                this.peer = opts.peer
                this.chain = opts.chain
                this.network = this.chain.network
                this.from = opts.from || 0
                this.to = opts.to || null
                this.filtered = typeof opts.filtered === 'boolean' ? opts.filtered : !!this.peer.filter
                
                this.cursor = this.from
                this.expected = null
                this.ending = false
                
                this.peer.on(this.filtered ? 'merkleblock' : 'block', this._onBlock.bind(this))
            }
            util.inherits(BlockStream, Readable)
            
            BlockStream.prototype._error = function (err) {
                this.emit('error', err)
            }
            
            BlockStream.prototype._end = function () {
                this.ending = true
                if (this.expected) return
                this.push(null)
            }
            
            BlockStream.prototype._read = function () {
                this._next()
            }
            
            BlockStream.prototype._next = function () {
                var self = this
                if (this.expected) return
                this.chain.getBlock(this.cursor, function (err, block) {
                    if (err) return self._error(err)
                    if (!block.next) return self._end()
                    self.cursor = u.toHash(block.next)
                    if (u.toHash(block.header.hash).compare(self.from) === 0) return self._next()
                    self._getData(block)
                })
            }
            
            BlockStream.prototype._getData = function (block) {
                var hash = u.toHash(block.header.hash)
                this.expected = { height: block.height, hash: hash }
                var inventory = [
                    new Inventory({
                        type: this.filtered ? Inventory.TYPE.MERKLE_BLOCK : Inventory.TYPE.BLOCK,
                        hash: hash
                    })
                ]
                var message = this.peer.messages.GetData(inventory)
                this.peer.sendMessage(message)
            }
            
            BlockStream.prototype._onBlock = function (message) {
                if (!this.expected) return
                var hash = u.toHash(message.block.header.hash)
                if (hash.compare(this.expected.hash) !== 0) return
                var block = {
                    height: this.expected.height,
                    header: message.block.header,
                    block: message.block
                }
                this.expected = null
                var done = !this.push(block) || this.ending
                if (done) this._end()
                else this._next()
            }

        }, { "./utils.js": 11, "bitcore-p2p": 15, "stream": 338, "util": 342 }], 4: [function (require, module, exports) {
            (function (process, Buffer) {
                var EventEmitter = require('events').EventEmitter
                var util = require('util')
                var async = require('async')
                var bitcore = require('bitcore')
                var Inventory = require('bitcore-p2p').Inventory
                var BN = bitcore.crypto.BN
                var constants = require('./constants.js')
                var BlockStore = require('./blockStore.js')
                var u = require('./utils.js')
                
                if (process.browser) {
                    require('setimmediate')
                }
                
                function noop() { }
                
                var TIME_MARGIN = 2 * 60 * 60
                var storeClosedError = new Error('Store is closed')
                
                var Blockchain = module.exports = function (opts) {
                    var self = this
                    opts = opts || {}
                    this.peerGroup = opts.peerGroup
                    this.network = bitcore.Networks.get(opts.network) || bitcore.Networks.defaultNetwork
                    
                    var genesisHeader = opts.genesis || constants.genesisHeaders[this.network.name]
                    this.genesis = this.tip = {
                        height: 0,
                        hash: u.toHash(genesisHeader.hash),
                        header: genesisHeader
                    }
                    
                    this.BlockHeader = genesisHeader.constructor
                    
                    if (opts.checkpoint && !opts.to) {
                        this.checkpoint = opts.checkpoint
                        this.checkpoint.hash = u.toHash(this.checkpoint.header.hash)
                        this.tip = this.checkpoint
                    }
                    this.to = opts.to
                    
                    this.initialized = false
                    this.closed = false
                    
                    this.store = opts.store || new BlockStore({
                        path: opts.path,
                        BlockHeader: this.BlockHeader
                    })
                    this._initStore(function (err) {
                        if (err && err !== storeClosedError) return self._error(err)
                        else if (err && err === storeClosedError) return
                        self.initialized = true
                        self.emit('ready')
                    })
                    
                    this.downloadPeer = null
                    this.syncing = false
                    this.initialized = false
                    this.syncHeight = 0
                    this.lastInv = null
                    
                    this.interval = opts.interval || 2016
                    this.targetSpacing = opts.targetSpacing || 10 * 60
                    this.targetTimespan = this.interval * this.targetSpacing
                    this.maxTarget = opts.maxTarget || constants.maxTarget
                    
                    this._onHeaders = this._onHeaders.bind(this)
                    this._onDownloadPeerDisconnect = this._onDownloadPeerDisconnect.bind(this)
                }
                util.inherits(Blockchain, EventEmitter)
                
                Blockchain.prototype._initStore = function (cb) {
                    var self = this
                    
                    function putIfNotFound(block) {
                        return function (cb) {
                            self.store.get(block.hash, function (err) {
                                if (err && !err.notFound) return cb(err)
                                if (self.closed || self.store.isClosed()) return cb(storeClosedError)
                                self.store.put(block, cb)
                            })
                        }
                    }
                    
                    var tasks = [putIfNotFound(this.genesis)]
                    if (this.checkpoint) tasks.push(putIfNotFound(this.checkpoint))
                    async.parallel(tasks, cb)
                }
                
                Blockchain.prototype.waitForReady = function (cb) {
                    if (this.initialized) return cb()
                    this.on('ready', cb)
                }
                
                Blockchain.prototype.close = function (cb) {
                    var self = this
                    this.waitForReady(function () {
                        self.closed = true
                        self.syncing = false
                        self.store.close(cb)
                    })
                }
                
                Blockchain.prototype.sync = function (opts, cb) {
                    var self = this
                    if (this.syncing) return cb(null)
                    if (typeof opts === 'function') {
                        cb = opts
                        opts = {}
                    }
                    opts = opts || {}
                    if (cb) this.once('synced', cb)
                    
                    this.syncing = true
                    if (opts.to || this.to) this.syncHeight = opts.to || this.to
                    
                    var syncDone = function () {
                        var done = false
                        if (self.syncHeight) {
                            done = self.tip.height >= self.syncHeight
                        } else {
                            done = self.downloadPeer && self.tip.height >= self.downloadPeer.bestHeight
                        }
                        if (done) {
                            self.removeListener('sync', syncDone)
                            self.removeListener('syncing', syncDone)
                            self.syncing = false
                            self._setDownloadPeer(null)
                            self.emit('synced', self.tip)
                            self._listenForUpdates()
                        }
                    }
                    this.on('sync', syncDone)
                    this.on('syncing', syncDone)
                    
                    var startDownload = function (err) {
                        if (err) {
                            err = new Error('Error initializing blockchain: ' + err)
                            if (cb) return cb(err)
                            else self.emit('error', err)
                        }
                        self._getHeaders()
                    }
                    if (!this.initialized) this._initialize(startDownload)
                    else startDownload(null)
                }
                
                Blockchain.prototype.getTip = function () {
                    return this.tip
                }
                
                Blockchain.prototype.getPath = function (from, to, cb) {
                    var self = this
                    var output = {
                        add: [],
                        remove: [],
                        fork: null
                    }
                    
                    var top, bottom, down
                    if (from.height > to.height) {
                        top = from
                        bottom = to
                        down = true
                    } else {
                        top = to
                        bottom = from
                        down = false
                    }
                    
                    function addTraversedBlock(block) {
                        if (down && block.header.hash !== to.header.hash) output.remove.push(block)
                        else if (!down && block.header.hash !== from.header.hash) output.add.unshift(block)
                    }
                    
                    // traverse down from the higher block to the lower block
                    function traverseDown(err, block) {
                        if (err) return cb(err)
                        if (block.height === bottom.height) {
                            // we traversed down to the lower height
                            if (block.header.hash === bottom.header.hash) {
                                // the blocks are the same, there was no fork
                                addTraversedBlock(block)
                                return cb(null, output)
                            }
                            // the blocks are not the same, so we need to traverse down to find a fork
                            return traverseToFork(block, bottom)
                        }
                        addTraversedBlock(block)
                        self._get(block.header.prevHash, traverseDown)
                    }
                    traverseDown(null, top)
                    
                    // traverse down from both blocks until we find one block that is the same
                    function traverseToFork(left, right) {
                        if (left.height === 0 || right.height === 0) {
                            // we got all the way to two different genesis blocks,
                            // the blocks don't have a path between thems
                            return cb(new Error('Blocks are not in the same chain'))
                        }
                        
                        output.remove.push(down ? left : right)
                        output.add.unshift(down ? right : left)
                        
                        self._get(left.header.prevHash, function (err, left) {
                            if (err) return cb(err)
                            self._get(right.header.prevHash, function (err, right) {
                                if (err) return cb(err)
                                if (left.header.hash === right.header.hash) {
                                    output.fork = left
                                    return cb(null, output)
                                }
                                traverseToFork(left, right)
                            })
                        })
                    }
                }
                
                Blockchain.prototype.getPathToTip = function (from, cb) {
                    this.getPath(from, this.tip, cb)
                }
                
                Blockchain.prototype.getBlockAtTime = function (time, opts, cb) {
                    var self = this
                    if (typeof opts === 'function') {
                        cb = opts
                        opts = {}
                    }
                    opts = opts || {}
                    opts.margin = opts.margin != null ? opts.margin : TIME_MARGIN
                    
                    var output = this.tip
                    function traverse(err, block) {
                        if (err) return cb(err)
                        if (block.header.time <= time - opts.margin) return cb(null, output)
                        if (block.header.time >= time) output = block
                        if (block.height === 0) return cb(null, output)
                        self._get(block.header.prevHash, traverse)
                    }
                    traverse(null, this.tip)
                }
                
                Blockchain.prototype.getBlockAtHeight = function (height, cb) {
                    var self = this
                    
                    if (height > this.tip.height) return cb(new Error('height is higher than tip'))
                    if (height < 0) return cb(new Error('height must be >= 0'))
                    
                    var down = height > this.tip.height / 2
                    
                    function traverse(err, block) {
                        if (err) return cb(err)
                        if (block.height === height) return cb(null, block)
                        self._get(down ? block.header.prevHash : block.next, traverse)
                    }
                    this._get(down ? this.tip.hash : this.genesis.hash, traverse)
                }
                
                Blockchain.prototype.getBlock = function (at, cb) {
                    // hash
                    if (Buffer.isBuffer(at)) return this._get(at, cb)
                    if (typeof at === 'number') {
                        // height
                        if (at < constants.timestampThreshold) {
                            return this.getBlockAtHeight(at, cb)
                        }
                        // timestamp
                        return this.getBlockAtTime(at, cb)
                    }
                    
                    return cb(new Error('"at" must be a block hash, height, or timestamp'))
                }
                
                Blockchain.prototype.getLocator = function (from, cb) {
                    this.getBlock(from, function (err, block) {
                        if (err) return cb(err)
                        // TODO: include some previous blocks in case we are on a fork
                        return cb(null, [u.toHash(block.header.hash)])
                    })
                }
                
                Blockchain.prototype._error = function (err) {
                    this.emit('error', err)
                }
                
                Blockchain.prototype._initialize = function (cb) {
                    cb = cb || noop
                    
                    if (this.initialized) return cb(null)
                    
                    var self = this
                    this.store.getTip(function (err, tip) {
                        self.initialized = true
                        if (err && err.name === 'NotFoundError') return cb(null)
                        if (err) return cb(err)
                        self.tip = tip
                        cb(null, tip)
                    })
                }
                
                Blockchain.prototype._findDownloadPeer = function (cb) {
                    var self = this
                    cb = cb || noop
                    
                    if (this.peerGroup.peers.length === 0) {
                        this.peerGroup.once('peer', function () {
                            self._findDownloadPeer(cb)
                        })
                        return
                    }
                    
                    var peer = this.peerGroup.randomPeer()
                    this._setDownloadPeer(peer)
                    return cb(null, peer)
                }
                
                Blockchain.prototype._setDownloadPeer = function (peer) {
                    if (this.downloadPeer) {
                        this.downloadPeer.removeListener('headers', this._onHeaders)
                        this.downloadPeer.removeListener('disconnect', this._onDownloadPeerDisconnect)
                    }
                    
                    this.downloadPeer = peer
                    if (peer) {
                        peer.on('headers', this._onHeaders)
                        peer.on('disconnect', this._onDownloadPeerDisconnect)
                        this.emit('syncing', peer)
                    }
                }
                
                Blockchain.prototype._getHeaders = function (opts) {
                    var self = this
                    
                    if (!this.syncing) return
                    if (!this.downloadPeer) {
                        this._findDownloadPeer(function (err, peer) {
                            if (err) return self._error(err)
                            self._getHeaders(opts)
                        })
                        return
                    }
                    
                    opts = opts || {}
                    this.getLocator(opts.from || this.tip.hash, function (err, locator) {
                        if (err) throw err
                        if (!self.downloadPeer) return
                        var message = self.downloadPeer.messages.GetHeaders({
                            starts: locator
                        })
                        self.downloadPeer.sendMessage(message)
                    })
                }
                
                Blockchain.prototype._onHeaders = function (message) {
                    var self = this
                    if (message.headers.length === 0) return
                    this.processHeaders(message.headers, function (err, last) {
                        if (err) {
                            return self._error(new Error('Peer sent invalid headers: ' + err.message))
                        }
                        if (self.syncing) {
                            self.emit('sync', last)
                            self._getHeaders()
                        }
                    })
                }
                
                Blockchain.prototype._onDownloadPeerDisconnect = function () {
                    this.downloadPeer = null
                    if (this.syncing) this._getHeaders()
                }
                
                Blockchain.prototype._listenForUpdates = function () {
                    var self = this
                    this.peerGroup.on('inv', function (peer, message) {
                        message.inventory.forEach(function (item) {
                            if (item.type === Inventory.TYPE.BLOCK ||
      item.type === Inventory.TYPE.FILTERED_BLOCK) {
                                if (self.lastInv && self.lastInv.compare(item.hash) === 0) return
                                self.lastInv = item.hash
                                self._getHeaders()
                            }
                        })
                    })
                }
                
                Blockchain.prototype._get = function (hash, cb) {
                    var self = this
                    if (!this.initialized) {
                        this.once('ready', function () { self._get(hash, cb) })
                        return
                    }
                    this.store.get(hash, cb)
                }
                
                Blockchain.prototype._put = function (hash, opts, cb) {
                    var self = this
                    if (!this.initialized) {
                        this.once('ready', function () { self._put(hash, opts, cb) })
                        return
                    }
                    this.store.put(hash, opts, cb)
                }
                
                Blockchain.prototype.processHeaders = function (headers, cb) {
                    var self = this
                    
                    var previousTip = this.tip
                    
                    this._get(headers[0].prevHash, function (err, start) {
                        if (err && err.name === 'NotFoundError') return cb(new Error('Block does not connect to chain'))
                        if (err) return cb(err)
                        start.hash = u.toHash(start.header.hash)
                        
                        if (self.syncHeight && start.height + headers.length > self.syncHeight) {
                            headers = headers.slice(0, start.height + headers.length - self.syncHeight)
                        }
                        
                        async.reduce(headers, start, self.processHeader.bind(self), function (err, last) {
                            if (err) return cb(err, last)
                            
                            if (last.height > previousTip.height) {
                                self.getPath(previousTip, last, function (err, path) {
                                    if (err) return cb(err, last)
                                    if (path.remove.length > 0) {
                                        var first = { height: start.height + 1, header: headers[0] }
                                        self.store.put(first, { best: true, prev: start }, function (err) {
                                            if (err) return cb(err)
                                            self.emit('reorg', { remove: path.remove, tip: last })
                                            cb(null, last)
                                        })
                                        return
                                    }
                                    cb(null, last)
                                })
                                return
                            }
                            
                            cb(null, last)
                        })
                    })
                }
                
                Blockchain.prototype.processHeader = function (prev, header, cb) {
                    if (!cb) cb = typeof header === 'function' ? header : cb
                    if (prev instanceof bitcore.BlockHeader) {
                        header = prev
                        prev = this.tip
                    }
                    
                    var self = this
                    var height = prev.height + 1
                    var block = {
                        height: height,
                        hash: u.toHash(header.hash),
                        header: header
                    }
                    
                    if (header.prevHash.compare(prev.hash) !== 0) {
                        return cb(new Error('Block does not connect to previous'), block)
                    }
                    // TODO: testnet difficulty rules (for now we are just not verifying testnet block difficulty)
                    if (this.network !== bitcore.Networks.testnet &&
  !self.shouldRetarget(height) &&
  header.bits !== prev.header.bits) {
                        return cb(new Error('Unexpected difficulty change'), block)
                    }
                    if (!header.validProofOfWork()) {
                        return cb(new Error('Invalid proof of work'), block)
                    }
                    // TODO: other checks (timestamp, version)
                    if (self.shouldRetarget(height) &&
  // don't verify retarget if it requires checking before our checkpoint
  !(this.checkpoint && height - this.checkpoint.height < this.interval)) {
                        return self.calculateTarget(block, function (err, target) {
                            if (err) return cb(err, block)
                            
                            var expected = u.toCompactTarget(target)
                            if (expected !== header.bits) {
                                return cb(new Error('Bits in block (' + header.bits.toString(16) + ')' +
          ' is different than expected (' + expected.toString(16) + ')'))
                            }
                            put()
                        })
                    }
                    put()
                    
                    function put() {
                        var tip = height > self.tip.height
                        self._put({ header: header, height: height }, { tip: tip, prev: prev }, function (err) {
                            if (err) return cb(err)
                            
                            if (tip) {
                                self.tip = block
                                block.syncing = self.syncing
                                self.emit('block', block)
                            }
                            
                            cb(null, block)
                        })
                    }
                }
                
                Blockchain.prototype.shouldRetarget = function (height) {
                    return !(height % this.interval)
                }
                
                Blockchain.prototype.calculateTarget = function (block, cb) {
                    var self = this
                    
                    var endBlock = null
                    var startBlock = null
                    
                    function calculate() {
                        var timespan = endBlock.header.time - startBlock.header.time
                        timespan = Math.max(timespan, self.targetTimespan / 4)
                        timespan = Math.min(timespan, self.targetTimespan * 4)
                        
                        var target = endBlock.header.getTargetDifficulty()
                        target.imul(new BN(timespan))
                        target.idivn(new BN(self.targetTimespan))
                        
                        if (target.cmp(self.maxTarget) === 1) {
                            target = self.maxTarget
                        }
                        
                        return cb(null, target)
                    }
                    
                    var i = 0
                    function traverse(block) {
                        self.store.get(block.header.prevHash, function (err, prev) {
                            if (err) return cb(err)
                            if (i === 0) endBlock = prev
                            i++
                            if (i === self.interval) {
                                startBlock = prev
                                return calculate()
                            }
                            setImmediate(function () { traverse(prev) })
                        })
                    }
                    traverse(block)
                }

            }).call(this, require('_process'), require("buffer").Buffer)
        }, { "./blockStore.js": 2, "./constants.js": 5, "./utils.js": 11, "_process": 322, "async": 14, "bitcore": "bitcore", "bitcore-p2p": 15, "buffer": 172, "events": 317, "setimmediate": 166, "util": 342 }], 5: [function (require, module, exports) {
            (function (Buffer) {
                var bitcore = require('bitcore')
                var BN = bitcore.crypto.BN
                var u = require('./utils.js')
                
                module.exports = {
                    genesisHeaders: {
                        livenet: new bitcore.BlockHeader({
                            version: 1,
                            prevHash: u.toHash('0000000000000000000000000000000000000000000000000000000000000000'),
                            merkleRoot: u.toHash('4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b'),
                            time: 1231006505,
                            bits: 0x1d00ffff,
                            nonce: 2083236893
                        }),
                        testnet: new bitcore.BlockHeader({
                            version: 1,
                            prevHash: u.toHash('0000000000000000000000000000000000000000000000000000000000000000'),
                            merkleRoot: u.toHash('4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b'),
                            time: 1296688602,
                            bits: 0x1d00ffff,
                            nonce: 414098458
                        })
                    },
                    checkpoints: {
                        livenet: {
                            height: 359000,
                            header: new bitcore.BlockHeader({
                                version: 3,
                                prevHash: u.toHash('000000000000000006ecee94daaa034bbd026cad52a9d3c6a5b7972716e5d566'),
                                merkleRoot: u.toHash('1e24b829d04e8e6fcb71fa0de364d6c0fa952c1cdb5fad446cf2a94dd203867a'),
                                time: 1433195458,
                                bits: 0x18171a8b,
                                nonce: 3020402664
                            })
                        },
                        testnet: {
                            height: 446000,
                            header: new bitcore.BlockHeader({
                                version: 3,
                                prevHash: u.toHash('00000000003d7bfe7baf59981a749017112b8018f0977356a3a21ea81a04d79d'),
                                merkleRoot: u.toHash('8a5829f9ac43b54819a02e44b2754458179de46c748f2d110bf97a0b02595267'),
                                time: 1432987428,
                                bits: 0x1a3fffc0,
                                nonce: 3771678460
                            })
                        }
                    },
                    maxTarget: new BN('ffff0000000000000000000000000000000000000000000000000000', 'hex'),
                    zeroHash: new Buffer('0000000000000000000000000000000000000000000000000000000000000000', 'hex'),
                    timestampThreshold: 500000000,
                    
                    webSeeds: [
                        '104.236.185.38:8192'
                    ]
                }

            }).call(this, require("buffer").Buffer)
        }, { "./utils.js": 11, "bitcore": "bitcore", "buffer": 172 }], 6: [function (require, module, exports) {
            var EventEmitter = require('events').EventEmitter
            var util = require('util')
            var async = require('async')
            var bitcore = require('bitcore')
            var Blockchain = require('./blockchain.js')
            var PeerGroup = require('./peerGroup.js')
            var BlockStream = require('../lib/blockStream.js')
            var TransactionStream = require('../lib/transactionStream.js')
            var Wallet = require('../lib/wallet.js')
            var constants = require('../lib/constants.js')
            
            var Node = module.exports = function (opts, cb) {
                var self = this
                opts = opts || {}
                
                this.path = opts.path || 'data'
                this.path.replace(/[/\\]$/, '')
                
                this.network = opts.network || bitcore.Networks.livenet
                
                this.peers = opts.peers || new PeerGroup({
                    network: this.network,
                    acceptWeb: opts.accept || opts.acceptWeb,
                    acceptTcp: opts.accept || opts.acceptTcp,
                    getTip: function () { return self.chain.getTip() }
                })
                this.peers.on('error', this._error.bind(this))
                
                this.chain = opts.chain || new Blockchain({
                    network: this.network,
                    peerGroup: this.peers,
                    path: this.path + '/' + (opts.chainPath || this.network.name + '.chain'),
                    store: opts.chainStore,
                    to: opts.to,
                    checkpoint: constants.checkpoints[this.network.name]
                })
                this.chain.on('error', this._error.bind(this))
                
                this.wallets = {}
                
                this.closing = false
                this.closed = false
                
                if (cb) this.start(cb)
            }
            util.inherits(Node, EventEmitter)
            
            Node.prototype.start = function (cb) {
                var self = this
                cb = cb || function () { }
                
                this.peers.on('peerconnect', this._onPeerConnect.bind(this))
                
                async.parallel([
                    this.peers.connect.bind(this.peers),
                    function (cb) {
                        self.chain.on('syncing', function () { cb(null) })
                        self.chain.sync()
                    }
                ], cb)
                
                this.emit('ready')
            }
            
            Node.prototype.close = function (cb) {
                if (!cb) cb = function () { }
                var self = this
                
                this.closing = true
                
                var tasks = [this.peers.disconnect.bind(this.peers)]
                
                tasks.push(function (cb) {
                    var wallets = []
                    for (var id in this.wallets) wallets.push(this.wallets[id])
                    async.each(wallets, function (wallet, cb) { wallet.close(cb) }, function (err) {
                        if (err) return cb(err)
                        self.chain.close(function (err) {
                            if (err) return cb(err)
                            this.closed = true
                            cb(null)
                        })
                    })
                })
                
                async.parallel(tasks, function (err) {
                    if (err) return (self._error || cb)(err)
                    self.emit('end')
                    cb(null)
                })
            }
            
            Node.prototype.createBlockStream = function (opts) {
                var peer = this.peers.randomPeer()
                if (!peer) throw new Error('Not connected to any peers')
                opts.peer = peer
                opts.chain = this.chain
                return new BlockStream(opts)
            }
            
            Node.prototype.createTransactionStream = function (opts) {
                var blocks = this.createBlockStream(opts)
                return new TransactionStream(blocks)
            }
            
            Node.prototype.createWallet = function (id, opts, cb) {
                if (!id) throw new Error('Wallet id is required')
                if (this.wallets[id]) throw new Error('A Wallet already exists with id "' + id + '"')
                if (typeof opts === 'function') {
                    cb = opts
                    opts = {}
                }
                opts = opts || {}
                opts.id = id
                opts.path = this.path
                opts.node = this
                var wallet = new Wallet(opts, cb)
                this.wallets[id] = wallet
                return wallet
            }
            
            Node.prototype._error = function (err) {
                this.emit('error', err)
            }
            
            Node.prototype._onPeerConnect = function (peer) {
                var self = this
                peer.on('getheaders', function (message) {
                    self._sendHeaders(peer, message)
                })
            }
            
            Node.prototype._sendHeaders = function (peer, message) {
                var self = this
                var start = null
                var headers = []
                
                function next(err, block) {
                    if (err) return self._error(err)
                    headers.push(block.header)
                    if (headers.length === 2000 || !block.next) {
                        peer.sendMessage(peer.messages.Headers(headers))
                        return
                    }
                    self.chain.store.get(block.next, next)
                }
                
                async.each(message.starts, function (hash, cb) {
                    self.chain.store.get(hash, function (err, block) {
                        if (err && err.name === 'NotFoundError') return cb(null)
                        if (err) return cb(err)
                        if (block) {
                            start = block
                            return cb(true)
                        }
                    })
                }, function (err) {
                    if (err !== true && !(err.message === 'Database is not open' && self.closing)) {
                        return self._error(err)
                    }
                    if (!start || !start.next) return
                    self.chain.store.get(start.next, next)
                })
            }

        }, { "../lib/blockStream.js": 3, "../lib/constants.js": 5, "../lib/transactionStream.js": 10, "../lib/wallet.js": 12, "./blockchain.js": 4, "./peerGroup.js": 8, "async": 14, "bitcore": "bitcore", "events": 317, "util": 342 }], 7: [function (require, module, exports) {
            (function (process) {
                var util = require('util')
                var p2p = require('bitcore-p2p')
                var Builder = p2p.Messages.builder
                var pkg = require('../package.json')
                
                var commands = Object.keys((new Builder()).commandsMap)
                
                var Peer = module.exports = function (opts) {
                    var self = this
                    if (this instanceof Peer) {
                        p2p.Peer.call(this, opts)
                    } else {
                        return new Peer(opts)
                    }
                    
                    if (opts.getTip) this.getTip = opts.getTip
                    
                    this.on('connect', function () {
                        self.socket.on('error', function (err) {
                            self.emit('error', err)
                        })
                    })
                    this.on('ready', function (message) {
                        self.connectTime = Date.now()
                        if (self.filter) self._sendFilterLoad()
                    })
                    this.on('version', function (message) {
                        self.services = message.services
                    })
                    
                    // in addition to bitcore-p2p message events, emit as a 'message' event
                    commands.forEach(function (command) {
                        self.on(command, function (message) {
                            self.emit('message', message)
                        })
                    })
                    
                    this.remoteAddress = 'tcp://' + this.host + ':' + this.port
                    this.filter = null
                }
                util.inherits(Peer, p2p.Peer)
                
                Peer.STATUS = p2p.Peer.STATUS
                
                Peer.prototype._sendVersion = function () {
                    var message = this.messages.Version({ relay: this.relay })
                    
                    message.subversion = '/' + pkg.name + ':' + pkg.version + message.subversion
                    if (process.browser) message.subversion += navigator.userAgent + '/'
                    else message.subversion += process.title + ':' + process.versions.node + '/'
                    
                    if (this.getTip) {
                        var tip = this.getTip()
                        message.startHeight = tip.height
                    }
                    
                    this.versionSent = true
                    this.sendMessage(message)
                }
                
                Peer.prototype.sendMessage = function () {
                    if (this.status === Peer.STATUS.DISCONNECTED) return
                    var args = Array.prototype.slice.call(arguments, 0)
                    p2p.Peer.prototype.sendMessage.apply(this, args)
                }
                
                Peer.prototype.getFilter = function () {
                    return this.filter
                }
                
                Peer.prototype.setFilter = function (filter) {
                    if (filter != null && !(filter instanceof p2p.BloomFilter)) {
                        throw new Error('Filter must be an instance of bitcore-p2p.BloomFilter')
                    }
                    this.filter = filter
                    if (this.status === Peer.STATUS.READY) {
                        if (filter) this._sendFilterLoad()
                        else this.sendFilterClear()
                    }
                }
                
                Peer.prototype.addToFilter = function (data) {
                    if (!this.filter) {
                        // TODO: create a BloomFilter class that automatically sets its parameters as
                        // elements are added
                        this.setFilter(p2p.BloomFilter.create(1000, 0.1))
                    }
                    this.filter.insert(data)
                    if (this.status === Peer.STATUS.READY) this._sendFilterAdd(data)
                }
                
                Peer.prototype._sendFilterLoad = function () {
                    var message = this.messages.FilterLoad(this.filter)
                    this.sendMessage(message)
                }
                
                Peer.prototype._sendFilterAdd = function (data) {
                    var message = this.messages.FilterAdd(data)
                    this.sendMessage(message)
                }
                
                Peer.prototype._sendFilterClear = function () {
                    var message = this.messages.FilterClear()
                    this.sendMessage(message)
                }

            }).call(this, require('_process'))
        }, { "../package.json": 168, "_process": 322, "bitcore-p2p": 15, "util": 342 }], 8: [function (require, module, exports) {
            (function (process, Buffer) {
                var EventEmitter = require('events').EventEmitter
                var util = require('util')
                var async = require('async')
                var bitcore = require('bitcore')
                var Networks = bitcore.Networks
                var Transaction = bitcore.Transaction
                var PeerhubClient = require('peerhub/client')
                var p2p = require('bitcore-p2p')
                var Builder = p2p.Messages.builder
                var Inventory = p2p.Inventory
                var Peer = require('./peer.js')
                var WebPeer = require('./webPeer.js')
                var u = require('./utils.js')
                
                var webSeeds = require('./constants.js').webSeeds
                
                var supportsWebRTC = false
                if (process.browser) {
                    var RTCPC = window.mozRTCPeerConnection || window.webkitRTCPeerConnection || window.RTCPeerConnection
                    supportsWebRTC = !!RTCPC
                } else {
                    try {
                        require('wrtc')
                        supportsWebRTC = true
                    } catch (e) { }
                }
                
                // HACK: suppress warnings from Buffer#get()
                Buffer.prototype.get = function get(offset) {
                    return this.readUInt8(offset)
                }
                
                var commands = Object.keys((new Builder()).commandsMap)
                
                var PeerGroup = module.exports = function (opts) {
                    opts = opts || {}
                    this.network = Networks.get(opts.network) || Networks.defaultNetwork
                    this.acceptTcp = opts.acceptTcp || false
                    this.acceptWeb = opts.acceptWeb || false
                    this.tcpCount = opts.tcpCount != null ? opts.tcpCount : 5
                    this.webCount = opts.webCount != null ? opts.webCount : 5
                    this.autoConnect = opts.autoConnect != null ? opts.autoConnect : true
                    this.getTip = opts.getTip
                    
                    this.webSeeds = []
                    
                    this.connecting = false
                    this.connected = false
                    this.disconnecting = false
                    this.connectedTCP = false
                    this.connectedWeb = false
                    
                    this.peers = []
                    this.peers.tcp = []
                    this.peers.web = []
                    this.messages = null
                    
                    this.filter = null
                    this.inventory = {}
                    
                    this.pool = new p2p.Pool({ maxSize: this.tcpCount, network: this.network })
                    this.pool.on('peerconnect', this._onTCPPeerConnect.bind(this))
                    
                    this.setMaxListeners(100)
                }
                util.inherits(PeerGroup, EventEmitter)
                
                PeerGroup.prototype._error = function (err) {
                    this.emit('error', err)
                }
                
                PeerGroup.prototype._onPeerConnect = function (peer) {
                    var self = this
                    
                    if (!(peer instanceof Peer)) {
                        peer = new Peer(peer)
                    }
                    
                    peer.on('ready', function () {
                        self._onPeerReady(peer)
                        self.emit('peer', peer)
                    })
                    peer.on('error', function (err) {
                        self._error(err)
                    })
                    peer.on('disconnect', function () {
                        self._onPeerDisconnect(peer)
                        self.emit('peerdisconnect', peer)
                    })
                    this.emit('peerconnect', peer)
                }
                
                PeerGroup.prototype._onPeerReady = function (peer) {
                    var self = this
                    this.peers.push(peer)
                    if (peer instanceof WebPeer) this.peers.web.push(peer)
                    else this.peers.tcp.push(peer)
                    
                    if (this.filter) peer.setFilter(this.filter)
                    
                    if (!this.messages) this.messages = peer.messages
                    commands.forEach(function (key) {
                        peer.on(key, function (message) {
                            self.emit(key, peer, message)
                        })
                    })
                    
                    peer.on('getdata', function (message) {
                        message.inventory.forEach(function (inv) {
                            var hash = inv.hash.toString('base64')
                            var item = self.inventory[hash]
                            if (!item) return
                            // TODO: handle types other than transactions
                            var txMessage = peer.messages.Transaction(item.value)
                            peer.sendMessage(txMessage)
                        })
                    })
                    
                    var invMessage = peer.messages.Inventory(this.getInventory())
                    peer.sendMessage(invMessage)
                }
                
                PeerGroup.prototype._onPeerDisconnect = function (peer) {
                    var isWeb = peer instanceof WebPeer
                    
                    u.remove(this.peers, peer)
                    u.remove(isWeb ? this.peers.web : this.peers.tcp, peer)
                    
                    if (this.autoConnect && isWeb) {
    // TODO (we don't yet have a way of ensuring peers are unique)
                    }
                }
                
                PeerGroup.prototype.numberConnected = function () {
                    return this.peers.length
                }
                
                PeerGroup.prototype.randomPeer = function () {
                    // prefers TCP peers to WebRTC peers
                    var peers = this.peers
                    if (peers.tcp.length) peers = peers.tcp
                    return peers[Math.floor(Math.random() * peers.length)]
                }
                
                PeerGroup.prototype.connect = function (opts, cb) {
                    var self = this
                    
                    if (typeof opts === 'function') {
                        cb = opts
                        opts = {}
                    }
                    opts = opts || {}
                    if (cb) {
                        this.once('ready', function () { cb(null) })
                    }
                    
                    this.connecting = true
                    
                    var tasks = []
                    
                    if (!process.browser) {
                        tasks.push(function (cb) {
                            // first check if a peer is running on the local machine
                            self._connectToLocalhost(function (err, peer) {
                                if (err || !peer) {
                                    // if we couldn't connect to the local peer, connect to DNS seed peers
                                    return self._connectToTCPPeers(cb)
                                }
                                // if we eventually disconnect from local peer, connect to DNS seed peers
                                peer.on('disconnect', self._connectToTCPPeers.bind(self))
                                cb(null)
                            })
                        })
                    }
                    
                    if (supportsWebRTC) {
                        tasks.push(function (cb) {
                            async.each(webSeeds, function (uri, cb) {
                                var client = new PeerhubClient(uri, function () {
                                    self.webSeeds.push(client)
                                    self.emit('seedconnect', client)
                                    self._connectToWebPeers()
                                    if (self.acceptWeb) self._acceptFromPeerhub(client)
                                    cb(null)
                                })
                            }, cb)
                        })
                    }
                    
                    async.parallel(tasks, function (err) {
                        if (err) return (cb || self._error)(err)
                        self.connecting = false
                        self.emit('ready')
                    })
                }
                
                PeerGroup.prototype._connectToLocalhost = function (cb) {
                    var self = this
                    if (process.browser) return cb(new Error('Not supported in the browser'))
                    
                    var localPeer = new Peer({
                        host: 'localhost',
                        port: this.network.port,
                        getTip: this.getTip
                    })
                    
                    var couldNotConnect = function () {
                        if (cb) return cb(new Error('Could not connect'))
                    }
                    localPeer.on('error', couldNotConnect)
                    localPeer.on('connect', function () {
                        self._onPeerConnect(localPeer)
                    })
                    localPeer.on('ready', function () {
                        localPeer.removeListener('error', couldNotConnect)
                        if (cb) return cb(null, localPeer)
                    })
                    
                    localPeer.connect()
                }
                
                PeerGroup.prototype._connectToTCPPeers = function (cb) {
                    if (process.browser) throw new Error('Not supported in the browser')
                    if (!cb) cb = function () { }
                    
                    var self = this
                    if (this.tcpCount <= 0) return cb(null)
                    // FIXME: temporary hack to fix intermittent connection problems:
                    // (reconnect pool every 5 seconds if no peers connect)
                    var interval = setInterval(function () {
                        self.pool.connect()
                    }, 5000)
                    function onPeerConnect() {
                        self.pool.removeListener('peerconnect', onPeerConnect)
                        clearInterval(interval)
                        cb(null)
                    }
                    if (!this.connected) this.pool.on('peerconnect', onPeerConnect)
                    this.pool.connect()
                    if (this.acceptTcp) this.pool.listen()
                }
                
                PeerGroup.prototype._onTCPPeerConnect = function (peer) {
                    peer.getTip = this.getTip
                    this._onPeerConnect(new Peer(peer))
                }
                
                PeerGroup.prototype._connectToWebPeers = function () {
                    var self = this
                    var client = this.webSeeds[Math.floor(Math.random() * this.webSeeds.length)]
                    client.discover(function (err, peerIds) {
                        if (err) return console.error(err)
                        
                        peerIds = peerIds.slice(0, self.webCount - self.numberConnected())
                        peerIds.forEach(function (id) {
                            client.connect(id, function (err, peer) {
                                if (err) return self._error(err)
                                self._onWebPeerConnect(peer)
                            })
                        })
                    })
                }
                
                PeerGroup.prototype._onWebPeerConnect = function (conn, incoming) {
                    var peer = new WebPeer(conn, { incoming: !!incoming, getTip: this.getTip })
                    peer.connect()
                    this._onPeerConnect(peer)
                    this.emit('webpeer', peer)
                }
                
                PeerGroup.prototype.acceptWebPeers = function () {
                    if (!supportsWebRTC) throw new Error('WebRTC is not supported')
                    this.webSeeds.forEach(this._acceptFromPeerhub.bind(this))
                    this.acceptWeb = true
                }
                
                PeerGroup.prototype._acceptFromPeerhub = function (client) {
                    var self = this
                    client.accept(function (id, peer) { self._onWebPeerConnect(peer, true) })
                }
                
                PeerGroup.prototype.disconnect = function (cb) {
                    var self = this
                    
                    this.disconnecting = true
                    
                    if (this.connecting) {
                        return this.on('ready', function () {
                            self.disconnect(cb)
                        })
                    }
                    
                    self.peers.forEach(function (peer) {
                        peer.disconnect()
                    })
                    self.webSeeds.forEach(function (client) {
                        client.disconnect()
                    })
                    
                    if (this.pool) this.pool.disconnect()
                    self.emit('disconnect')
                    if (cb) cb(null)
                }
                
                PeerGroup.prototype.setFilter = function (filter) {
                    this.peers.forEach(function (peer) {
                        peer.setFilter(filter)
                    })
                    this.filter = filter
                }
                
                PeerGroup.prototype.addToFilter = function (data) {
                    this.filter.insert(data)
                    this.peers.forEach(function (peer) {
                        peer.addToFilter(data)
                    })
                }
                
                PeerGroup.prototype.sendMessage = PeerGroup.prototype.broadcast = function (message) {
                    this.peers.forEach(function (peer) {
                        peer.sendMessage(message)
                    })
                }
                
                PeerGroup.prototype.addToInventory = function (item, data) {
                    // TODO: support inventory types other than transactions
                    if (!(item instanceof Transaction)) {
                        throw new Error('Argument must be an instance of bitcore.Transaction')
                    }
                    var hash = u.toHash(item.hash).toString('base64')
                    var inv = new Inventory({
                        type: Inventory.TYPE.TX,
                        hash: u.toHash(item.hash)
                    })
                    this.inventory[hash] = {
                        inv: inv,
                        value: item
                    }
                    this.sendInventory(inv)
                }
                
                PeerGroup.prototype.getInventory = function () {
                    var output = []
                    for (var k in this.inventory) {
                        output.push(this.inventory[k].inv)
                    }
                    return output
                }
                
                PeerGroup.prototype.sendInventory = function (item) {
                    if (this.peers.length === 0) return
                    var inventory = item ? [item] : this.getInventory()
                    var message = this.messages.Inventory(inventory)
                    this.sendMessage(message)
                }
                
                PeerGroup.prototype.broadcastTransaction = function (tx, cb) {
                    this.addToInventory(tx)
                    // TODO: remove tx from inventory after it has been confirmed
                    // TODO: send relevant 'reject' message back as error to cb
                    if (cb) cb(null)
                }

            }).call(this, require('_process'), require("buffer").Buffer)
        }, { "./constants.js": 5, "./peer.js": 7, "./utils.js": 11, "./webPeer.js": 13, "_process": 322, "async": 14, "bitcore": "bitcore", "bitcore-p2p": 15, "buffer": 172, "events": 317, "peerhub/client": 151, "util": 342, "wrtc": 167 }], 9: [function (require, module, exports) {
            (function (Buffer) {
                var bitcore = require('bitcore')
                var Transaction = bitcore.Transaction
                var u = require('./utils.js')
                
                function encodeKey(hash) {
                    if (typeof hash === 'string') {
                        return new Buffer(hash, 'hex').toString('base64')
                    } else if (Buffer.isBuffer(hash)) {
                        return hash.toString('base64')
                    }
                }
                
                var TransactionStore = module.exports = function (opts, cb) {
                    if (typeof opts === 'function') {
                        cb = opts
                        opts = null
                    }
                    opts = opts || {}
                    this.store = opts.store || u.createStore({ path: opts.path, db: opts.db }, cb)
                }
                
                TransactionStore.prototype.put = function (tx, opts, cb) {
                    var self = this
                    if (typeof opts === 'function') {
                        cb = opts
                        opts = {}
                    }
                    if (!opts.header && !opts.block) return cb(new Error('Must specify "header" or "block" option'))
                    if (!(tx instanceof Transaction)) {
                        return cb(new Error('Transaction must be instance of bitcore.Transaction'))
                    }
                    
                    var blockKey = encodeKey(opts.header ? opts.header.hash : opts.block)
                    var txKey = encodeKey(tx.hash)
                    
                    this.store.get(txKey, function (err, existingTx) {
                        if (err && !err.notFound) return cb(err)
                        if (existingTx) return cb(null, tx, { existed: true })
                        self.store.get(blockKey, function (err, blockIndex) {
                            if (err && !err.notFound) return cb(err)
                            blockIndex = blockIndex || []
                            blockIndex.push(txKey)
                            var batch = [
                                {
                                    type: 'put',
                                    key: txKey,
                                    value: {
                                        block: blockKey,
                                        data: tx.toBuffer().toString('base64')
                                    }
                                },
                                { type: 'put', key: blockKey, value: blockIndex }
                            ]
                            self.store.batch(batch, function (err) {
                                if (err) return cb(err)
                                return cb(null, tx, { existed: false })
                            })
                        })
                    })
                }
                
                TransactionStore.prototype.get = function (hash, cb) {
                    try {
                        var key = encodeKey(hash)
                    } catch (err) {
                        return cb(err)
                    }
                    
                    this.store.get(key, function (err, tx) {
                        if (err) return cb(err)
                        if (tx.data) {
                            // value is a transaction (not a block index)
                            tx.transaction = new Transaction(new Buffer(tx.data, 'base64'))
                            delete tx.data
                        }
                        cb(null, tx)
                    })
                }
                
                TransactionStore.prototype.close = function (cb) {
                    this.store.close(cb)
                }
                
                TransactionStore.prototype.isClosed = function () {
                    return this.store.isClosed()
                }
                
                TransactionStore.prototype.isOpen = function () {
                    return this.store.isOpen()
                }

            }).call(this, require("buffer").Buffer)
        }, { "./utils.js": 11, "bitcore": "bitcore", "buffer": 172 }], 10: [function (require, module, exports) {
            var Transform = require('stream').Transform
            var util = require('util')
            var Block = require('bitcore').Block
            
            var TransactionStream = module.exports = function (blocks, opts) {
                var self = this
                Transform.call(this, { objectMode: true })
                
                opts = opts || {}
                this.verify = typeof opts.verify === 'boolean' ? opts.verify : true
                this.last = null
                this.blocks = blocks
                
                blocks.on('end', function () { self.push(null) })
                blocks.pipe(this)
            }
            util.inherits(TransactionStream, Transform)
            
            TransactionStream.prototype._transform = function (block, enc, cb) {
                if (block.height == null || !(block.block instanceof Block)) {
                    return cb(new Error('Input to TransactionStream must be a stream of blocks'))
                }
                
                var self = this
                block.block.transactions.forEach(function (tx) {
                    if (this.verify && tx.verify() !== true) return
                    self.push({ transaction: tx, block: block })
                })
                this.last = block
                cb(null)
            }

        }, { "bitcore": "bitcore", "stream": 338, "util": 342 }], 11: [function (require, module, exports) {
            (function (process, Buffer) {
                var buffertools = require('buffertools')
                var levelup = require('levelup')
                var mkdirp = require('mkdirp')
                
                module.exports = {
                    toHash: function (hex) {
                        return buffertools.reverse(new Buffer(hex, 'hex'))
                    },
                    
                    createStore: function (opts, cb) {
                        opts = opts || {}
                        if (opts.path && !process.browser) mkdirp.sync(opts.path)
                        if (!opts.db) {
                            opts.db = process.browser ? require('level-js') : require('leveldown')
                        }
                        opts.keyEncoding = opts.keyEncoding || 'utf8'
                        opts.valueEncoding = opts.valueEncoding || 'json'
                        opts.cacheSize = opts.cacheSize
                        return levelup(opts.path, opts, cb)
                    },
                    
                    remove: function (array, value) {
                        var index = array.indexOf(value)
                        if (index === -1) return
                        array.splice(index, 1)
                    },
                    
                    toCompactTarget: function (target) {
                        var exponent = Math.ceil(target.bitLength() / 8)
                        var targetString = target.toString(16)
                        if (targetString.length % 2 === 1) targetString = '0' + targetString
                        var mantissa = Number.parseInt(targetString.substr(0, 6), 16)
                        if (mantissa & 0x800000) {
                            mantissa >>= 8
                            exponent++
                        }
                        return (exponent << 24) | mantissa
                    }
                }

            }).call(this, require('_process'), require("buffer").Buffer)
        }, { "_process": 322, "buffer": 172, "buffertools": 58, "level-js": 59, "leveldown": 77, "levelup": 124, "mkdirp": 150 }], 12: [function (require, module, exports) {
            (function (Buffer) {
                var EventEmitter = require('events').EventEmitter
                var path = require('path')
                var util = require('util')
                var async = require('async')
                var bitcore = require('bitcore')
                var keyHash = bitcore.crypto.Hash.sha256ripemd160
                var BlockHeader = bitcore.BlockHeader
                var HDPrivateKey = bitcore.HDPrivateKey
                var Transaction = bitcore.Transaction
                var Output = Transaction.Output
                var Script = bitcore.Script
                var Address = bitcore.Address
                var TransactionStore = require('./transactionStore.js')
                var u = require('./utils.js')
                
                var TIME_MARGIN = 3 * 60 * 60
                
                var Wallet = module.exports = function (opts, cb) {
                    if (typeof opts === 'function') {
                        cb = opts
                        opts = {}
                    }
                    opts = opts || {}
                    
                    if (!opts.path) throw new Error('"path" option is required for Wallet')
                    if (!opts.id) throw new Error('"id" option is required for Wallet')
                    if (!opts.node) throw new Error('"node" option is required for Wallet')
                    
                    this.node = opts.node
                    this.chain = this.node.chain
                    this.peers = this.node.peers
                    this.network = this.node.network
                    
                    this.id = opts.id
                    this.path = path.normalize(opts.path + '/' + this.id + '.' + this.network.name + '.wallet')
                    this.store = opts.store || u.createStore({ path: this.path, db: opts.db })
                    
                    this.scanning = false
                    this.closed = false
                    
                    this.rootKey = opts.rootKey || null
                    this.pubKey = this.rootKey ? this.rootKey.hdPublicKey : null
                    this.state = null
                    this.lookAhead = opts.lookAhead || 1
                    
                    this.unspent = {}
                    this.transactions = opts.transactions || new TransactionStore({
                        store: this.store
                    })
                    
                    this.feePerKb = opts.feePerKb || 10000
                    
                    this._error = this._error.bind(this)
                    this.initialized = false
                    this._initialize(cb)
                }
                util.inherits(Wallet, EventEmitter)
                
                Wallet.prototype.close = function (cb) {
                    var self = this
                    this.waitForReady(function () {
                        self.closed = true
                        self.store.close(cb)
                    })
                }
                
                Wallet.prototype.getKey = function () {
                    var key = this.deriveKey(this.state.i++)
                    this._generateKeys()
                    return key
                }
                
                Wallet.prototype.getAddress = function () {
                    return this.getKey().publicKey.toAddress(this.network)
                }
                
                Wallet.prototype.send = function (recipient, amount, cb) {
                    var self = this
                    var recipients
                    if (typeof amount === 'number') {
                        recipients = {}
                        recipients[recipient] = amount
                    } else if (typeof recipient === 'object') {
                        recipients = recipient
                        cb = amount
                    }
                    
                    var total = 0
                    for (var address in recipients) total += recipients[address]
                    if (total > this.state.balance) return cb(new Error('Insufficient balance'))
                    
                    var tx = new Transaction()
                    tx.change(this.getAddress())
                    for (address in recipients) tx.to(address, recipients[address])
                    
                    var inputs = []
                    var inputIds = []
                    var inputAmount = 0
                    while (inputAmount < total + tx.getFee()) {
                        var utxo = this.getUTXO(total + tx.getFee(), inputIds)
                        inputs.push(utxo)
                        inputIds.push(utxo.id)
                        inputAmount += utxo.satoshis
                        tx.from(utxo)
                    }
                    
                    async.eachSeries(inputs, function (input, cb) {
                        var k = input.address.hashBuffer.toString('base64')
                        self.store.get(k, function (err, keyInfo) {
                            if (err) return cb(err)
                            var key = self.rootKey.derive(keyInfo.path)
                            tx.sign(key.privateKey, bitcore.crypto.Signature.SIGHASH_ALL)
                            cb(null)
                        })
                    }, function (err) {
                        if (err) return cb(err)
                        self.peers.broadcastTransaction(tx)
                        cb(null)
                    })
                }
                
                Wallet.prototype.getUTXO = function (amount, exclude) {
                    var closest, closestDiff
                    for (var id in this.unspent) {
                        var output = this.unspent[id]
                        if (exclude && exclude.indexOf(id) !== -1) continue
                        var diff = Math.abs(output.satoshis - amount)
                        if (!closest || diff < closestDiff) {
                            closest = id
                            closestDiff = diff
                        }
                    }
                    if (!closest) return null
                    
                    var script = new Script(this.unspent[closest].script)
                    return {
                        id: closest,
                        address: new Address(script.getAddressInfo(this.network)),
                        txid: new Buffer(closest.split(':')[0], 'base64').toString('hex'),
                        outputIndex: +closest.split(':')[1],
                        script: script,
                        satoshis: this.unspent[closest].satoshis
                    }
                }
                
                Wallet.prototype._error = function (err) {
                    if (!err) return
                    this.emit('error', err)
                }
                
                Wallet.prototype._initialize = function (cb) {
                    var self = this
                    
                    async.series([
                        function (cb) {
                            async.parallel([
                                self._loadRootKey.bind(self),
                                self._loadUnspent.bind(self),
                                self._loadState.bind(self)
                            ], cb)
                        },
                        this._initializeKeys.bind(this)
                    ], function (err, res) {
                        if (err) return (cb || self._error)(err)
                        self._listenToChain()
                        self.initialized = true
                        self.emit('ready')
                        if (cb) cb(null)
                    })
                }
                
                Wallet.prototype.waitForReady = function (cb) {
                    if (this.initialized) return cb()
                    this.on('ready', cb)
                }
                
                Wallet.prototype._listenToChain = function () {
                    var self = this
                    if (this.peers.numberConnected() === 0) {
                        this.peers.once('peer', function () { self._listenToChain() })
                        return
                    }
                    this.chain.on('block', this._update.bind(this))
                    this._update()
                }
                
                Wallet.prototype._update = function () {
                    var self = this
                    var scanStart = this.state.createdAt - TIME_MARGIN
                    if (this.chain.tip.header.time < scanStart) return
                    if (!this.state.tip) {
                        this.chain.getBlockAtTime(this.state.createdAt - TIME_MARGIN, function (err, block) {
                            if (err) return self._error(err)
                            self.state.tip = block
                            self._saveState(self._scanChain.bind(self))
                        })
                        return
                    }
                    this._scanChain()
                }
                
                Wallet.prototype._scanChain = function (opts) {
                    var self = this
                    opts = opts || {}
                    
                    if (this.scanning) return
                    this.scanning = true
                    
                    this.node.chain.getPathToTip(this.state.tip, function (err, path) {
                        if (err) return self._error(err)
                        
                        if (path.remove.length > 0) {
                            async.eachSeries(path.remove, self._unprocessBlock.bind(self), function (err) {
                                if (err) return self._error(err)
                                processTransactions()
                            })
                            return
                        }
                        processTransactions()
                        
                        function processTransactions() {
                            var tipHash = u.toHash(self.state.tip.header.hash)
                            var txs = self.node.createTransactionStream({ from: tipHash })
                            self.emit('syncing', self.state.tip)
                            function error(err) {
                                if (!err) return
                                txs.pause()
                                self._error(err)
                            }
                            txs.on('data', function (tx) {
                                self.isRelevant(tx.transaction, function (err, relevant) {
                                    if (err) return error(err)
                                    if (!relevant) return
                                    self._processTransaction(tx, function (err) {
                                        if (err) return error(err)
                                        
                                        self.state.tip = {
                                            height: tx.block.height,
                                            header: tx.block.header
                                        }
                                        self._saveState(error)
                                    })
                                })
                            })
                            txs.on('end', function () {
                                self.scanning = false
                                self.state.tip = {
                                    height: txs.last.height,
                                    header: txs.last.header
                                }
                                self._saveState(function (err) {
                                    if (err) return self._error(err)
                                    self.emit('synced')
                                })
                            })
                            txs.blocks.on('data', function (block) {
                                self.emit('sync', block)
                            })
                        }
                    })
                }
                
                Wallet.prototype.isOwnOutput = function (output, cb) {
                    if (!output.script) return cb(null, false)
                    if (output.script.isPublicKeyHashOut() || output.script.isPublicKeyOut()) {
                        var addr = output.script.toAddress(this.network)
                        if (!addr) return cb(null, false)
                        this.store.get(addr.hashBuffer.toString('base64'), function (err, key) {
                            if (err && !err.notFound) return cb(err)
                            if (err && err.notFound) return cb(null, false)
                            cb(null, true)
                        })
                        return
                    }
  // TODO: support P2SH of pay-to-pubkey and pay-to-pubkey-hash
                }
                
                Wallet.prototype.isOwnInput = function (input, cb) {
                    if (!input.script) return cb(null, 0)
                    if (input.script.isPublicKeyHashIn() || input.script.isPublicKeyIn()) {
                        var addr = input.script.toAddress(this.network)
                        if (!addr) return cb(null, false)
                        this.store.get(addr.hashBuffer.toString('base64'), function (err, key) {
                            if (err && !err.notFound) return cb(err)
                            if (err && err.notFound) return cb(null, false)
                            cb(null, true)
                        })
                        return
                    }
  // TODO: support P2SH of pay-to-pubkey and pay-to-pubkey-hash
                }
                
                Wallet.prototype.getOwnOutputs = function (tx, cb) {
                    var self = this
                    var outputs = []
                    async.eachSeries(tx.outputs, function (output, cb) {
                        self.isOwnOutput(output, function (err, own) {
                            if (err) return cb(err)
                            if (own) outputs.push(output)
                            cb(null)
                        })
                    }, function (err) {
                        return cb(err, outputs)
                    })
                }
                
                Wallet.prototype.getOwnInputs = function (tx, cb) {
                    var self = this
                    var inputs = []
                    async.eachSeries(tx.inputs, function (input, cb) {
                        self.isOwnInput(input, function (err, own) {
                            if (err) return cb(err)
                            if (own) inputs.push(input)
                            cb(null)
                        })
                    }, function (err) {
                        return cb(err, inputs)
                    })
                }
                
                Wallet.prototype.isRelevant = function (tx, cb) {
                    var self = this
                    this.amountReceived(tx, function (err, received) {
                        if (err) return cb(err)
                        if (received !== 0) return cb(null, true)
                        self.amountSent(tx, function (err, sent) {
                            if (err) return cb(err)
                            return cb(null, sent !== 0)
                        })
                    })
                }
                
                Wallet.prototype.total = function (items) {
                    var amount = 0
                    items.forEach(function (item) { amount += item.satoshis })
                    return amount
                }
                
                Wallet.prototype.amountReceived = function (tx, cb) {
                    var self = this
                    this.getOwnOutputs(tx, function (err, outputs) {
                        if (err) return cb(err)
                        cb(null, self.total(outputs))
                    })
                }
                
                Wallet.prototype.amountSent = function (tx, cb) {
                    var self = this
                    this.getOwnInputs(tx, function (err, inputs) {
                        if (err) return cb(err)
                        cb(null, self.total(inputs))
                    })
                }
                
                Wallet.prototype._processTransaction = function (tx, cb) {
                    var self = this
                    // TODO: make store operations atomic
                    this.transactions.get(tx.transaction.hash, function (err, storedTx) {
                        if (err && !err.notFound) return cb(err)
                        if (storedTx) return cb(new Error('Transaction was already processed'))
                        
                        var balanceDelta = 0
                        
                        async.series([
                            function (cb) {
                                self._processOutputs(tx, function (err, received) {
                                    balanceDelta += received
                                    cb(err)
                                })
                            },
                            function (cb) {
                                self._processInputs(tx, function (err, sent) {
                                    balanceDelta -= sent
                                    cb(err)
                                })
                            },
                            function (cb) {
                                self.transactions.put(tx.transaction, { block: tx.block.header.hash }, function (err, _, meta) {
                                    if (err) return cb(err)
                                    if (meta.existed) return cb(new Error('Transaction was already in store'))
                                    cb(null)
                                })
                            }
                        ],
    function (err) {
                            if (err) return cb(err)
                            self.state.balance += balanceDelta
                            self._saveState(cb)
                        })
                    })
                }
                
                Wallet.prototype._processOutputs = function (tx, cb) {
                    var self = this
                    this.getOwnOutputs(tx.transaction, function (err, outputs) {
                        if (err) return cb(err)
                        if (outputs.length === 0) return cb(null, 0)
                        var addresses = outputs.map(function (output) {
                            return output.script.getAddressInfo(self.network)
                        })
                        var amount = self.total(outputs)
                        
                        self._addUnspent(tx.transaction, function (err) {
                            if (err) return cb(err)
                            // TODO: disregard change in amount
                            self.emit('receive', {
                                transaction: tx.transaction,
                                block: tx.block,
                                addresses: addresses,
                                amount: amount
                            })
                            cb(null, amount)
                        })
                    })
                }
                
                Wallet.prototype._processInputs = function (tx, cb) {
                    var self = this
                    this.getOwnInputs(tx.transaction, function (err, inputs) {
                        if (err) return cb(err)
                        if (inputs.length === 0) return cb(null, 0)
                        var addresses = inputs.map(function (input) {
                            return input.script.getAddressInfo(self.network)
                        })
                        var amount = 0
                        async.each(inputs, function (input, cb) {
                            self.transactions.get(input.prevTxId, function (err, tx) {
                                if (err) return cb(err)
                                var output = tx.transaction.outputs[input.outputIndex]
                                amount += output.satoshis
                                cb(null)
                            })
                        }, function (err) {
                            if (err) return cb(err)
                            self._removeUnspent(tx.transaction, function (err) {
                                if (err) return cb(err)
                                // TODO: disregard change in amount
                                self.emit('send', {
                                    transaction: tx.transaction,
                                    block: tx.block,
                                    addresses: addresses,
                                    amount: amount
                                })
                                cb(null, amount)
                            })
                        })
                    })
                }
                
                Wallet.prototype._unprocessTransaction = function (tx, cb) {
                    var self = this
                    // TODO: make store operations atomic
                    this.transactions.get(tx.transaction.hash, function (err, storedTx) {
                        if (err && !err.notFound) return cb(err)
                        if (!storedTx) return cb(new Error('Transaction was not found in store'))
                        
                        var balanceDelta = 0
                        
                        async.series([
                            function (cb) {
                                self._unprocessOutputs(tx, function (err, received) {
                                    balanceDelta -= received
                                    cb(err)
                                })
                            },
                            function (cb) {
                                self._unprocessInputs(tx, function (err, sent) {
                                    balanceDelta += sent
                                    cb(err)
                                })
                            },
                            function (cb) {
                                var hash = new Buffer(tx.transaction.hash, 'hex').toString('base64')
                                self.transactions.del(hash, { block: tx.block.header.hash }, function (err, _, meta) {
                                    if (err) return cb(err)
                                    if (!meta.existed) return cb(new Error('Transaction was not found in store'))
                                    cb(null)
                                })
                            }
                        ],
    function (err) {
                            if (err) return cb(err)
                            self.state.balance += balanceDelta
                            self._saveState(cb)
                        })
                    })
                }
                
                Wallet.prototype._unprocessOutputs = function (tx, cb) {
                    var self = this
                    this.getOwnOutputs(tx.transaction, function (err, outputs) {
                        if (err) return cb(err)
                        if (outputs.length === 0) return cb(null, 0)
                        var addresses = outputs.map(function (output) {
                            return output.script.getAddressInfo(self.network)
                        })
                        var amount = self.total(outputs)
                        
                        self._removeUnspent(tx.transaction, function (err) {
                            if (err) return cb(err)
                            // TODO: disregard change in amount
                            self.emit('unreceive', {
                                transaction: tx.transaction,
                                block: tx.block,
                                addresses: addresses,
                                amount: amount
                            })
                            cb(null, amount)
                        })
                    })
                }
                
                Wallet.prototype._unprocessInputs = function (tx, cb) {
                    var self = this
                    this.getOwnInputs(tx.transaction, function (err, inputs) {
                        if (err) return cb(err)
                        if (inputs.length === 0) return cb(null, 0)
                        var addresses = inputs.map(function (input) {
                            return input.script.getAddressInfo(self.network)
                        })
                        var amount = 0
                        async.each(inputs, function (input, cb) {
                            self.transactions.get(input.prevTxId, function (err, tx) {
                                if (err) return cb(err)
                                var output = tx.transaction.outputs[input.outputIndex]
                                amount += output.satoshis
                                cb(null)
                            })
                        }, function (err) {
                            if (err) return cb(err)
                            self.addUnspent(tx.transaction, function (err) {
                                if (err) return cb(err)
                                // TODO: disregard change in amount
                                self.emit('unsend', {
                                    transaction: tx.transaction,
                                    block: tx.block,
                                    addresses: addresses,
                                    amount: amount
                                })
                                cb(null, amount)
                            })
                        })
                    })
                }
                
                Wallet.prototype._unprocessBlock = function (blockHash, cb) {
                    var self = this
                    this.transactions.get(blockHash, function (err, index) {
                        if (err && !err.notFound) return cb(err)
                        if ((err && err.notFound) || index.length === 0) return cb(null)
                        self.chain.get(blockHash, function (err, block) {
                            if (err) return cb(err)
                            async.eachSeries(index, function (txid, cb) {
                                self.transactions.get(txid, function (err, tx) {
                                    if (err) return cb(err)
                                    self._unprocessTransaction({ transaction: tx, block: block }, cb)
                                })
                            }, cb)
                        })
                    })
                }
                
                Wallet.prototype._loadRootKey = function (cb) {
                    var self = this
                    if (!cb) cb = function () { }
                    if (this.rootKey) return cb(null, this.rootKey)
                    
                    var opts = { valueEncoding: 'utf8' }
                    this.store.get('root', opts, function (err, root) {
                        if (err && !err.notFound) return cb(err)
                        if (err && err.notFound) {
                            self.rootKey = new HDPrivateKey()
                            var serialized = self.rootKey.toBuffer()
                            self.store.put('root', serialized, opts, function (err) { cb(err, self.rootKey) })
                            return
                        }
                        try {
                            self.rootKey = new HDPrivateKey(root)
                            return cb(null, self.rootKey)
                        } catch (e) {
                            return cb(null,null)
                        }
                    })
                }
                
                Wallet.prototype._initializeKeys = function (cb) {
                    try {
                        this.pubKey = this.rootKey.hdPublicKey
                        this._generateKeys(cb)
                    } catch (e) {
                    }
                }
                
                Wallet.prototype._generateKeys = function (cb) {
                    var self = this
                    var tasks = []
                    for (var i = this.state.gen; i < this.state.i + this.lookAhead; i++) {
                        (function (i) {
                            tasks.push(function (cb) {
                                var key = self.deriveKey(i)
                                var hash = keyHash(key.publicKey.toBuffer())
                                var value = {
                                    used: false,
                                    path: 'm/0/' + i
                                }
                                self.store.put(hash.toString('base64'), value, cb)
                            })
                        })(i)
                    }
                    async.series(tasks, function (err) {
                        if (err) return cb(err)
                        self.state.gen = i
                        self._saveState(cb)
                    })
                }
                
                Wallet.prototype.deriveKey = function (i) {
                    return this.pubKey.derive(0).derive(i)
                }
                
                Wallet.prototype.derivePrivateKey = function (i) {
                    return this.rootKey.derive(0).derive(i)
                }
                
                Wallet.prototype._loadUnspent = function (cb) {
                    var self = this
                    if (!cb) cb = this._error
                    
                    this.store.get('unspent', function (err, unspent) {
                        if (err && err.name !== 'NotFoundError') return cb(err)
                        if (unspent) {
                            for (var id in unspent) unspent[id] = new Output(unspent[id])
                            self.unspent = unspent
                        }
                        return cb(null, self.unspent)
                    })
                }
                
                Wallet.prototype._saveUnspent = function (cb) {
                    if (!cb) cb = this._error
                    this.store.put('unspent', this.unspent, cb)
                }
                
                Wallet.prototype._addUnspent = function (tx, cb) {
                    var self = this
                    var txid = new Buffer(tx.hash, 'hex').toString('base64')
                    this.getOwnOutputs(tx, function (err, outputs) {
                        if (err) return cb(err)
                        if (outputs.length === 0) return cb(null)
                        outputs.forEach(function (output) {
                            var i = tx.outputs.indexOf(output)
                            var id = txid + ':' + i
                            self.unspent[id] = output.toObject()
                        })
                        self._saveUnspent(cb)
                    })
                }
                
                Wallet.prototype._removeUnspent = function (tx, cb) {
                    var self = this
                    this.getOwnInputs(tx, function (err, inputs) {
                        if (err) return cb(err)
                        if (inputs.length === 0) return cb(null)
                        inputs.forEach(function (input) {
                            var id = input.prevTxId.toString('base64') + ':' + input.outputIndex
                            if (!self.unspent[id]) {
                                var err = new Error('Output ' + id + ' was not in UTXO set')
                                err.outputId = id
                                return cb(err)
                            }
                            delete self.unspent[id]
                        })
                        self._saveUnspent(cb)
                    })
                }
                
                Wallet.prototype._loadState = function (cb) {
                    var self = this
                    if (!cb) cb = this._error
                    
                    this.store.get('state', function (err, state) {
                        if (err && err.name !== 'NotFoundError') return cb(err)
                        if (!state) {
                            self.state = {
                                i: 0,
                                gen: 0,
                                tip: null,
                                createdAt: Math.floor(Date.now() / 1000),
                                balance: 0
                            }
                            self._saveState(function (err) {
                                if (err) return cb(err)
                                cb(null, self.state)
                            })
                            return
                        }
                        
                        if (state.tip) {
                            var header = new Buffer(state.tip.header, 'base64')
                            state.tip.header = BlockHeader.fromBuffer(header)
                        }
                        self.state = state
                        cb(null, self.state)
                    })
                }
                
                Wallet.prototype._saveState = function (cb) {
                    var self = this
                    if (!cb) cb = function (err) { if (err) self._error(err) }
                    var state = {
                        i: this.state.i,
                        gen: this.state.gen,
                        tip: null,
                        createdAt: this.state.createdAt,
                        balance: this.state.balance
                    }
                    if (this.state.tip) {
                        state.tip = {
                            height: this.state.tip.height,
                            header: this.state.tip.header.toBuffer().toString('base64')
                        }
                    }
                    this.store.put('state', state, cb)
                }

            }).call(this, require("buffer").Buffer)
        }, { "./transactionStore.js": 9, "./utils.js": 11, "async": 14, "bitcore": "bitcore", "buffer": 172, "events": 317, "path": 321, "util": 342 }], 13: [function (require, module, exports) {
            var crypto = require('crypto')
            var util = require('util')
            var Peer = require('./peer.js')
            
            var WebPeer = module.exports = function (conn, opts) {
                var self = this
                for (var k in opts) this[k] = opts[k]
                Peer.call(this, { socket: conn })
                delete this.port
                
                this.bestHeight = 0
                this.remoteAddress = 'WebRTC://?' // TODO: get address during signalling
                
                this.on('version', function (message) {
                    self.bestHeight = message.startHeight
                })
                
                this._startKeepAlive()
            }
            util.inherits(WebPeer, Peer)
            
            WebPeer.prototype.connect = function () {
                this.status = Peer.STATUS.CONNECTED
                this.emit('connect')
                this._sendVersion()
                return this
            }
            
            WebPeer.prototype._startKeepAlive = function () {
                var self = this
                this.heartbeat = setInterval(function () {
                    var ping = self.messages.Ping(crypto.pseudoRandomBytes(8))
                    self.sendMessage(ping)
                }, 10 * 1000)
                
                this.once('disconnect', function () {
                    clearInterval(self.heartbeat)
                })
            }

        }, { "./peer.js": 7, "crypto": 176, "util": 342 }], 14: [function (require, module, exports) {
            (function (process, global) {
                /*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
(function () {
                    
                    var async = {};
                    function noop() { }
                    
                    // global on the server, window in the browser
                    var root, previous_async;
                    
                    if (typeof window == 'object' && this === window) {
                        root = window;
                    }
                    else if (typeof global == 'object' && this === global) {
                        root = global;
                    }
                    else {
                        root = this;
                    }
                    
                    if (root != null) {
                        previous_async = root.async;
                    }
                    
                    async.noConflict = function () {
                        root.async = previous_async;
                        return async;
                    };
                    
                    function only_once(fn) {
                        var called = false;
                        return function () {
                            if (called) throw new Error("Callback was already called.");
                            called = true;
                            fn.apply(this, arguments);
                        };
                    }
                    
                    function _once(fn) {
                        var called = false;
                        return function () {
                            if (called) return;
                            called = true;
                            fn.apply(this, arguments);
                        };
                    }
                    
                    //// cross-browser compatiblity functions ////
                    
                    var _toString = Object.prototype.toString;
                    
                    var _isArray = Array.isArray || function (obj) {
                        return _toString.call(obj) === '[object Array]';
                    };
                    
                    function _isArrayLike(arr) {
                        return _isArray(arr) || (
            // has a positive integer length property
            typeof arr.length === "number" &&
            arr.length >= 0 &&
            arr.length % 1 === 0
);
                    }
                    
                    function _each(coll, iterator) {
                        return _isArrayLike(coll) ?
            _arrayEach(coll, iterator) :
            _forEachOf(coll, iterator);
                    }
                    
                    function _arrayEach(arr, iterator) {
                        var index = -1,
                            length = arr.length;
                        
                        while (++index < length) {
                            iterator(arr[index], index, arr);
                        }
                    }
                    
                    function _map(arr, iterator) {
                        var index = -1,
                            length = arr.length,
                            result = Array(length);
                        
                        while (++index < length) {
                            result[index] = iterator(arr[index], index, arr);
                        }
                        return result;
                    }
                    
                    function _range(count) {
                        return _map(Array(count), function (v, i) { return i; });
                    }
                    
                    function _reduce(arr, iterator, memo) {
                        _arrayEach(arr, function (x, i, a) {
                            memo = iterator(memo, x, i, a);
                        });
                        return memo;
                    }
                    
                    function _forEachOf(object, iterator) {
                        _arrayEach(_keys(object), function (key) {
                            iterator(object[key], key);
                        });
                    }
                    
                    var _keys = Object.keys || function (obj) {
                        var keys = [];
                        for (var k in obj) {
                            if (obj.hasOwnProperty(k)) {
                                keys.push(k);
                            }
                        }
                        return keys;
                    };
                    
                    function _keyIterator(coll) {
                        var i = -1;
                        var len;
                        var keys;
                        if (_isArrayLike(coll)) {
                            len = coll.length;
                            return function next() {
                                i++;
                                return i < len ? i : null;
                            };
                        } else {
                            keys = _keys(coll);
                            len = keys.length;
                            return function next() {
                                i++;
                                return i < len ? keys[i] : null;
                            };
                        }
                    }
                    
                    function _baseSlice(arr, start) {
                        start = start || 0;
                        var index = -1;
                        var length = arr.length;
                        
                        if (start) {
                            length -= start;
                            length = length < 0 ? 0 : length;
                        }
                        var result = Array(length);
                        
                        while (++index < length) {
                            result[index] = arr[index + start];
                        }
                        return result;
                    }
                    
                    function _withoutIndex(iterator) {
                        return function (value, index, callback) {
                            return iterator(value, callback);
                        };
                    }
                    
                    //// exported async module functions ////
                    
                    //// nextTick implementation with browser-compatible fallback ////
                    
                    // capture the global reference to guard against fakeTimer mocks
                    var _setImmediate;
                    if (typeof setImmediate === 'function') {
                        _setImmediate = setImmediate;
                    }
                    
                    if (typeof process === 'undefined' || !(process.nextTick)) {
                        if (_setImmediate) {
                            async.nextTick = function (fn) {
                                // not a direct alias for IE10 compatibility
                                _setImmediate(fn);
                            };
                            async.setImmediate = async.nextTick;
                        }
                        else {
                            async.nextTick = function (fn) {
                                setTimeout(fn, 0);
                            };
                            async.setImmediate = async.nextTick;
                        }
                    }
                    else {
                        async.nextTick = process.nextTick;
                        if (_setImmediate) {
                            async.setImmediate = function (fn) {
                                // not a direct alias for IE10 compatibility
                                _setImmediate(fn);
                            };
                        }
                        else {
                            async.setImmediate = async.nextTick;
                        }
                    }
                    
                    async.forEach =
    async.each = function (arr, iterator, callback) {
                        return async.eachOf(arr, _withoutIndex(iterator), callback);
                    };
                    
                    async.forEachSeries =
    async.eachSeries = function (arr, iterator, callback) {
                        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
                    };
                    
                    
                    async.forEachLimit =
    async.eachLimit = function (arr, limit, iterator, callback) {
                        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
                    };
                    
                    async.forEachOf =
    async.eachOf = function (object, iterator, callback) {
                        callback = _once(callback || noop);
                        object = object || [];
                        var size = _isArrayLike(object) ? object.length : _keys(object).length;
                        var completed = 0;
                        if (!size) {
                            return callback(null);
                        }
                        _each(object, function (value, key) {
                            iterator(object[key], key, only_once(done));
                        });
                        function done(err) {
                            if (err) {
                                callback(err);
                            }
                            else {
                                completed += 1;
                                if (completed >= size) {
                                    callback(null);
                                }
                            }
                        }
                    };
                    
                    async.forEachOfSeries =
    async.eachOfSeries = function (obj, iterator, callback) {
                        callback = _once(callback || noop);
                        obj = obj || [];
                        var nextKey = _keyIterator(obj);
                        var key = nextKey();
                        function iterate() {
                            var sync = true;
                            if (key === null) {
                                return callback(null);
                            }
                            iterator(obj[key], key, only_once(function (err) {
                                if (err) {
                                    callback(err);
                                }
                                else {
                                    key = nextKey();
                                    if (key === null) {
                                        return callback(null);
                                    } else {
                                        if (sync) {
                                            async.nextTick(iterate);
                                        } else {
                                            iterate();
                                        }
                                    }
                                }
                            }));
                            sync = false;
                        }
                        iterate();
                    };
                    
                    
                    
                    async.forEachOfLimit =
    async.eachOfLimit = function (obj, limit, iterator, callback) {
                        _eachOfLimit(limit)(obj, iterator, callback);
                    };
                    
                    function _eachOfLimit(limit) {
                        
                        return function (obj, iterator, callback) {
                            callback = _once(callback || noop);
                            obj = obj || [];
                            var nextKey = _keyIterator(obj);
                            if (limit <= 0) {
                                return callback(null);
                            }
                            var done = false;
                            var running = 0;
                            var errored = false;
                            
                            (function replenish() {
                                if (done && running <= 0) {
                                    return callback(null);
                                }
                                
                                while (running < limit && !errored) {
                                    var key = nextKey();
                                    if (key === null) {
                                        done = true;
                                        if (running <= 0) {
                                            callback(null);
                                        }
                                        return;
                                    }
                                    running += 1;
                                    iterator(obj[key], key, only_once(function (err) {
                                        running -= 1;
                                        if (err) {
                                            callback(err);
                                            errored = true;
                                        }
                                        else {
                                            replenish();
                                        }
                                    }));
                                }
                            })();
                        };
                    }
                    
                    
                    function doParallel(fn) {
                        return function (obj, iterator, callback) {
                            return fn(async.eachOf, obj, iterator, callback);
                        };
                    }
                    function doParallelLimit(limit, fn) {
                        return function (obj, iterator, callback) {
                            return fn(_eachOfLimit(limit), obj, iterator, callback);
                        };
                    }
                    function doSeries(fn) {
                        return function (obj, iterator, callback) {
                            return fn(async.eachOfSeries, obj, iterator, callback);
                        };
                    }
                    
                    function _asyncMap(eachfn, arr, iterator, callback) {
                        callback = _once(callback || noop);
                        var results = [];
                        eachfn(arr, function (value, index, callback) {
                            iterator(value, function (err, v) {
                                results[index] = v;
                                callback(err);
                            });
                        }, function (err) {
                            callback(err, results);
                        });
                    }
                    
                    async.map = doParallel(_asyncMap);
                    async.mapSeries = doSeries(_asyncMap);
                    async.mapLimit = function (arr, limit, iterator, callback) {
                        return _mapLimit(limit)(arr, iterator, callback);
                    };
                    
                    function _mapLimit(limit) {
                        return doParallelLimit(limit, _asyncMap);
                    }
                    
                    // reduce only has a series version, as doing reduce in parallel won't
                    // work in many situations.
                    async.inject =
    async.foldl =
    async.reduce = function (arr, memo, iterator, callback) {
                        async.eachOfSeries(arr, function (x, i, callback) {
                            iterator(memo, x, function (err, v) {
                                memo = v;
                                callback(err);
                            });
                        }, function (err) {
                            callback(err || null, memo);
                        });
                    };
                    
                    async.foldr =
    async.reduceRight = function (arr, memo, iterator, callback) {
                        var reversed = _map(arr, function (x) {
                            return x;
                        }).reverse();
                        async.reduce(reversed, memo, iterator, callback);
                    };
                    
                    function _filter(eachfn, arr, iterator, callback) {
                        var results = [];
                        arr = _map(arr, function (x, i) {
                            return { index: i, value: x };
                        });
                        eachfn(arr, function (x, index, callback) {
                            iterator(x.value, function (v) {
                                if (v) {
                                    results.push(x);
                                }
                                callback();
                            });
                        }, function () {
                            callback(_map(results.sort(function (a, b) {
                                return a.index - b.index;
                            }), function (x) {
                                return x.value;
                            }));
                        });
                    }
                    
                    async.select =
    async.filter = doParallel(_filter);
                    
                    async.selectSeries =
    async.filterSeries = doSeries(_filter);
                    
                    function _reject(eachfn, arr, iterator, callback) {
                        var results = [];
                        arr = _map(arr, function (x, i) {
                            return { index: i, value: x };
                        });
                        eachfn(arr, function (x, index, callback) {
                            iterator(x.value, function (v) {
                                if (!v) {
                                    results.push(x);
                                }
                                callback();
                            });
                        }, function () {
                            callback(_map(results.sort(function (a, b) {
                                return a.index - b.index;
                            }), function (x) {
                                return x.value;
                            }));
                        });
                    }
                    async.reject = doParallel(_reject);
                    async.rejectSeries = doSeries(_reject);
                    
                    function _detect(eachfn, arr, iterator, main_callback) {
                        eachfn(arr, function (x, index, callback) {
                            iterator(x, function (result) {
                                if (result) {
                                    main_callback(x);
                                    main_callback = noop;
                                }
                                else {
                                    callback();
                                }
                            });
                        }, function () {
                            main_callback();
                        });
                    }
                    async.detect = doParallel(_detect);
                    async.detectSeries = doSeries(_detect);
                    
                    async.any =
    async.some = function (arr, iterator, main_callback) {
                        async.eachOf(arr, function (x, _, callback) {
                            iterator(x, function (v) {
                                if (v) {
                                    main_callback(true);
                                    main_callback = noop;
                                }
                                callback();
                            });
                        }, function () {
                            main_callback(false);
                        });
                    };
                    
                    async.all =
    async.every = function (arr, iterator, main_callback) {
                        async.eachOf(arr, function (x, _, callback) {
                            iterator(x, function (v) {
                                if (!v) {
                                    main_callback(false);
                                    main_callback = noop;
                                }
                                callback();
                            });
                        }, function () {
                            main_callback(true);
                        });
                    };
                    
                    async.sortBy = function (arr, iterator, callback) {
                        async.map(arr, function (x, callback) {
                            iterator(x, function (err, criteria) {
                                if (err) {
                                    callback(err);
                                }
                                else {
                                    callback(null, { value: x, criteria: criteria });
                                }
                            });
                        }, function (err, results) {
                            if (err) {
                                return callback(err);
                            }
                            else {
                                callback(null, _map(results.sort(comparator), function (x) {
                                    return x.value;
                                }));
                            }

                        });
                        
                        function comparator(left, right) {
                            var a = left.criteria, b = right.criteria;
                            return a < b ? -1 : a > b ? 1 : 0;
                        }
                    };
                    
                    async.auto = function (tasks, callback) {
                        callback = _once(callback || noop);
                        var keys = _keys(tasks);
                        var remainingTasks = keys.length;
                        if (!remainingTasks) {
                            return callback(null);
                        }
                        
                        var results = {};
                        
                        var listeners = [];
                        function addListener(fn) {
                            listeners.unshift(fn);
                        }
                        function removeListener(fn) {
                            for (var i = 0; i < listeners.length; i += 1) {
                                if (listeners[i] === fn) {
                                    listeners.splice(i, 1);
                                    return;
                                }
                            }
                        }
                        function taskComplete() {
                            remainingTasks--;
                            _arrayEach(listeners.slice(0), function (fn) {
                                fn();
                            });
                        }
                        
                        addListener(function () {
                            if (!remainingTasks) {
                                callback(null, results);
                            }
                        });
                        
                        _arrayEach(keys, function (k) {
                            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
                            function taskCallback(err) {
                                var args = _baseSlice(arguments, 1);
                                if (args.length <= 1) {
                                    args = args[0];
                                }
                                if (err) {
                                    var safeResults = {};
                                    _arrayEach(_keys(results), function (rkey) {
                                        safeResults[rkey] = results[rkey];
                                    });
                                    safeResults[k] = args;
                                    callback(err, safeResults);
                                }
                                else {
                                    results[k] = args;
                                    async.setImmediate(taskComplete);
                                }
                            }
                            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
                            // prevent dead-locks
                            var len = requires.length;
                            var dep;
                            while (len--) {
                                if (!(dep = tasks[requires[len]])) {
                                    throw new Error('Has inexistant dependency');
                                }
                                if (_isArray(dep) && !!~dep.indexOf(k)) {
                                    throw new Error('Has cyclic dependencies');
                                }
                            }
                            function ready() {
                                return _reduce(requires, function (a, x) {
                                    return (a && results.hasOwnProperty(x));
                                }, true) && !results.hasOwnProperty(k);
                            }
                            if (ready()) {
                                task[task.length - 1](taskCallback, results);
                            }
                            else {
                                addListener(listener);
                            }
                            function listener() {
                                if (ready()) {
                                    removeListener(listener);
                                    task[task.length - 1](taskCallback, results);
                                }
                            }
                        });
                    };
                    
                    async.retry = function (times, task, callback) {
                        var DEFAULT_TIMES = 5;
                        var attempts = [];
                        // Use defaults if times not passed
                        if (typeof times === 'function') {
                            callback = task;
                            task = times;
                            times = DEFAULT_TIMES;
                        }
                        // Make sure times is a number
                        times = parseInt(times, 10) || DEFAULT_TIMES;
                        
                        function wrappedTask(wrappedCallback, wrappedResults) {
                            function retryAttempt(task, finalAttempt) {
                                return function (seriesCallback) {
                                    task(function (err, result) {
                                        seriesCallback(!err || finalAttempt, { err: err, result: result });
                                    }, wrappedResults);
                                };
                            }
                            
                            while (times) {
                                attempts.push(retryAttempt(task, !(times -= 1)));
                            }
                            async.series(attempts, function (done, data) {
                                data = data[data.length - 1];
                                (wrappedCallback || callback)(data.err, data.result);
                            });
                        }
                        
                        // If a callback is passed, run this as a controll flow
                        return callback ? wrappedTask() : wrappedTask;
                    };
                    
                    async.waterfall = function (tasks, callback) {
                        callback = _once(callback || noop);
                        if (!_isArray(tasks)) {
                            var err = new Error('First argument to waterfall must be an array of functions');
                            return callback(err);
                        }
                        if (!tasks.length) {
                            return callback();
                        }
                        function wrapIterator(iterator) {
                            return function (err) {
                                if (err) {
                                    callback.apply(null, arguments);
                                }
                                else {
                                    var args = _baseSlice(arguments, 1);
                                    var next = iterator.next();
                                    if (next) {
                                        args.push(wrapIterator(next));
                                    }
                                    else {
                                        args.push(callback);
                                    }
                                    ensureAsync(iterator).apply(null, args);
                                }
                            };
                        }
                        wrapIterator(async.iterator(tasks))();
                    };
                    
                    function _parallel(eachfn, tasks, callback) {
                        callback = callback || noop;
                        var results = _isArrayLike(tasks) ? [] : {};
                        
                        eachfn(tasks, function (task, key, callback) {
                            task(function (err) {
                                var args = _baseSlice(arguments, 1);
                                if (args.length <= 1) {
                                    args = args[0];
                                }
                                results[key] = args;
                                callback(err);
                            });
                        }, function (err) {
                            callback(err, results);
                        });
                    }
                    
                    async.parallel = function (tasks, callback) {
                        _parallel(async.eachOf, tasks, callback);
                    };
                    
                    async.parallelLimit = function (tasks, limit, callback) {
                        _parallel(_eachOfLimit(limit), tasks, callback);
                    };
                    
                    async.series = function (tasks, callback) {
                        callback = callback || noop;
                        var results = _isArrayLike(tasks) ? [] : {};
                        
                        async.eachOfSeries(tasks, function (task, key, callback) {
                            task(function (err) {
                                var args = _baseSlice(arguments, 1);
                                if (args.length <= 1) {
                                    args = args[0];
                                }
                                results[key] = args;
                                callback(err);
                            });
                        }, function (err) {
                            callback(err, results);
                        });
                    };
                    
                    async.iterator = function (tasks) {
                        function makeCallback(index) {
                            function fn() {
                                if (tasks.length) {
                                    tasks[index].apply(null, arguments);
                                }
                                return fn.next();
                            }
                            fn.next = function () {
                                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
                            };
                            return fn;
                        }
                        return makeCallback(0);
                    };
                    
                    async.apply = function (fn) {
                        var args = _baseSlice(arguments, 1);
                        return function () {
                            return fn.apply(
                                null, args.concat(_baseSlice(arguments))
                            );
                        };
                    };
                    
                    function _concat(eachfn, arr, fn, callback) {
                        var result = [];
                        eachfn(arr, function (x, index, cb) {
                            fn(x, function (err, y) {
                                result = result.concat(y || []);
                                cb(err);
                            });
                        }, function (err) {
                            callback(err, result);
                        });
                    }
                    async.concat = doParallel(_concat);
                    async.concatSeries = doSeries(_concat);
                    
                    async.whilst = function (test, iterator, callback) {
                        if (test()) {
                            iterator(function (err) {
                                if (err) {
                                    return callback(err);
                                }
                                async.whilst(test, iterator, callback);
                            });
                        }
                        else {
                            callback(null);
                        }
                    };
                    
                    async.doWhilst = function (iterator, test, callback) {
                        iterator(function (err) {
                            if (err) {
                                return callback(err);
                            }
                            var args = _baseSlice(arguments, 1);
                            if (test.apply(null, args)) {
                                async.doWhilst(iterator, test, callback);
                            }
                            else {
                                callback(null);
                            }
                        });
                    };
                    
                    async.until = function (test, iterator, callback) {
                        if (!test()) {
                            iterator(function (err) {
                                if (err) {
                                    return callback(err);
                                }
                                async.until(test, iterator, callback);
                            });
                        }
                        else {
                            callback(null);
                        }
                    };
                    
                    async.doUntil = function (iterator, test, callback) {
                        iterator(function (err) {
                            if (err) {
                                return callback(err);
                            }
                            var args = _baseSlice(arguments, 1);
                            if (!test.apply(null, args)) {
                                async.doUntil(iterator, test, callback);
                            }
                            else {
                                callback(null);
                            }
                        });
                    };
                    
                    function _queue(worker, concurrency, payload) {
                        if (concurrency == null) {
                            concurrency = 1;
                        }
                        else if (concurrency === 0) {
                            throw new Error('Concurrency must not be zero');
                        }
                        function _insert(q, data, pos, callback) {
                            if (callback != null && typeof callback !== "function") {
                                throw new Error("task callback must be a function");
                            }
                            q.started = true;
                            if (!_isArray(data)) {
                                data = [data];
                            }
                            if (data.length === 0 && q.idle()) {
                                // call drain immediately if there are no tasks
                                return async.setImmediate(function () {
                                    q.drain();
                                });
                            }
                            _arrayEach(data, function (task) {
                                var item = {
                                    data: task,
                                    callback: callback || noop
                                };
                                
                                if (pos) {
                                    q.tasks.unshift(item);
                                } else {
                                    q.tasks.push(item);
                                }
                                
                                if (q.tasks.length === q.concurrency) {
                                    q.saturated();
                                }
                            });
                            async.setImmediate(q.process);
                        }
                        function _next(q, tasks) {
                            return function () {
                                workers -= 1;
                                var args = arguments;
                                _arrayEach(tasks, function (task) {
                                    task.callback.apply(task, args);
                                });
                                if (q.tasks.length + workers === 0) {
                                    q.drain();
                                }
                                q.process();
                            };
                        }
                        
                        var workers = 0;
                        var q = {
                            tasks: [],
                            concurrency: concurrency,
                            saturated: noop,
                            empty: noop,
                            drain: noop,
                            started: false,
                            paused: false,
                            push: function (data, callback) {
                                _insert(q, data, false, callback);
                            },
                            kill: function () {
                                q.drain = noop;
                                q.tasks = [];
                            },
                            unshift: function (data, callback) {
                                _insert(q, data, true, callback);
                            },
                            process: function () {
                                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                                    while (workers < q.concurrency && q.tasks.length) {
                                        var tasks = payload ?
                            q.tasks.splice(0, payload) :
                            q.tasks.splice(0, q.tasks.length);
                                        
                                        var data = _map(tasks, function (task) {
                                            return task.data;
                                        });
                                        
                                        if (q.tasks.length === 0) {
                                            q.empty();
                                        }
                                        workers += 1;
                                        var cb = only_once(_next(q, tasks));
                                        worker(data, cb);
                                    }
                                }
                            },
                            length: function () {
                                return q.tasks.length;
                            },
                            running: function () {
                                return workers;
                            },
                            idle: function () {
                                return q.tasks.length + workers === 0;
                            },
                            pause: function () {
                                q.paused = true;
                            },
                            resume: function () {
                                if (q.paused === false) { return; }
                                q.paused = false;
                                var resumeCount = Math.min(q.concurrency, q.tasks.length);
                                // Need to call q.process once per concurrent
                                // worker to preserve full concurrency after pause
                                for (var w = 1; w <= resumeCount; w++) {
                                    async.setImmediate(q.process);
                                }
                            }
                        };
                        return q;
                    }
                    
                    async.queue = function (worker, concurrency) {
                        var q = _queue(function (items, cb) {
                            worker(items[0], cb);
                        }, concurrency, 1);
                        
                        return q;
                    };
                    
                    async.priorityQueue = function (worker, concurrency) {
                        
                        function _compareTasks(a, b) {
                            return a.priority - b.priority;
                        }
                        
                        function _binarySearch(sequence, item, compare) {
                            var beg = -1,
                                end = sequence.length - 1;
                            while (beg < end) {
                                var mid = beg + ((end - beg + 1) >>> 1);
                                if (compare(item, sequence[mid]) >= 0) {
                                    beg = mid;
                                } else {
                                    end = mid - 1;
                                }
                            }
                            return beg;
                        }
                        
                        function _insert(q, data, priority, callback) {
                            if (callback != null && typeof callback !== "function") {
                                throw new Error("task callback must be a function");
                            }
                            q.started = true;
                            if (!_isArray(data)) {
                                data = [data];
                            }
                            if (data.length === 0) {
                                // call drain immediately if there are no tasks
                                return async.setImmediate(function () {
                                    q.drain();
                                });
                            }
                            _arrayEach(data, function (task) {
                                var item = {
                                    data: task,
                                    priority: priority,
                                    callback: typeof callback === 'function' ? callback : noop
                                };
                                
                                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
                                
                                if (q.tasks.length === q.concurrency) {
                                    q.saturated();
                                }
                                async.setImmediate(q.process);
                            });
                        }
                        
                        // Start with a normal queue
                        var q = async.queue(worker, concurrency);
                        
                        // Override push to accept second parameter representing priority
                        q.push = function (data, priority, callback) {
                            _insert(q, data, priority, callback);
                        };
                        
                        // Remove unshift function
                        delete q.unshift;
                        
                        return q;
                    };
                    
                    async.cargo = function (worker, payload) {
                        return _queue(worker, 1, payload);
                    };
                    
                    function _console_fn(name) {
                        return function (fn) {
                            var args = _baseSlice(arguments, 1);
                            fn.apply(null, args.concat([function (err) {
                                    var args = _baseSlice(arguments, 1);
                                    if (typeof console !== 'undefined') {
                                        if (err) {
                                            if (console.error) {
                                                console.error(err);
                                            }
                                        }
                                        else if (console[name]) {
                                            _arrayEach(args, function (x) {
                                                console[name](x);
                                            });
                                        }
                                    }
                                }]));
                        };
                    }
                    async.log = _console_fn('log');
                    async.dir = _console_fn('dir');
                    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
                        var memo = {};
                        var queues = {};
                        hasher = hasher || function (x) {
                            return x;
                        };
                        function memoized() {
                            var args = _baseSlice(arguments);
                            var callback = args.pop();
                            var key = hasher.apply(null, args);
                            if (key in memo) {
                                async.nextTick(function () {
                                    callback.apply(null, memo[key]);
                                });
                            }
                            else if (key in queues) {
                                queues[key].push(callback);
                            }
                            else {
                                queues[key] = [callback];
                                fn.apply(null, args.concat([function () {
                                        memo[key] = _baseSlice(arguments);
                                        var q = queues[key];
                                        delete queues[key];
                                        for (var i = 0, l = q.length; i < l; i++) {
                                            q[i].apply(null, arguments);
                                        }
                                    }]));
                            }
                        }
                        memoized.memo = memo;
                        memoized.unmemoized = fn;
                        return memoized;
                    };
                    
                    async.unmemoize = function (fn) {
                        return function () {
                            return (fn.unmemoized || fn).apply(null, arguments);
                        };
                    };
                    
                    function _times(mapper) {
                        return function (count, iterator, callback) {
                            mapper(_range(count), iterator, callback);
                        };
                    }
                    
                    async.times = _times(async.map);
                    async.timesSeries = _times(async.mapSeries);
                    async.timesLimit = function (count, limit, iterator, callback) {
                        return async.mapLimit(_range(count), limit, iterator, callback);
                    };
                    
                    async.seq = function (/* functions... */) {
                        var fns = arguments;
                        return function () {
                            var that = this;
                            var args = _baseSlice(arguments);
                            
                            var callback = args.slice(-1)[0];
                            if (typeof callback == 'function') {
                                args.pop();
                            } else {
                                callback = noop;
                            }
                            
                            async.reduce(fns, args, function (newargs, fn, cb) {
                                fn.apply(that, newargs.concat([function () {
                                        var err = arguments[0];
                                        var nextargs = _baseSlice(arguments, 1);
                                        cb(err, nextargs);
                                    }]));
                            },
            function (err, results) {
                                callback.apply(that, [err].concat(results));
                            });
                        };
                    };
                    
                    async.compose = function (/* functions... */) {
                        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
                    };
                    
                    
                    function _applyEach(eachfn, fns /*args...*/) {
                        function go() {
                            var that = this;
                            var args = _baseSlice(arguments);
                            var callback = args.pop();
                            return eachfn(fns, function (fn, _, cb) {
                                fn.apply(that, args.concat([cb]));
                            },
            callback);
                        }
                        if (arguments.length > 2) {
                            var args = _baseSlice(arguments, 2);
                            return go.apply(this, args);
                        }
                        else {
                            return go;
                        }
                    }
                    
                    async.applyEach = function (/*fns, args...*/) {
                        var args = _baseSlice(arguments);
                        return _applyEach.apply(null, [async.eachOf].concat(args));
                    };
                    async.applyEachSeries = function (/*fns, args...*/) {
                        var args = _baseSlice(arguments);
                        return _applyEach.apply(null, [async.eachOfSeries].concat(args));
                    };
                    
                    
                    async.forever = function (fn, callback) {
                        var done = only_once(callback || noop);
                        var task = ensureAsync(fn);
                        function next(err) {
                            if (err) {
                                return done(err);
                            }
                            task(next);
                        }
                        next();
                    };
                    
                    function ensureAsync(fn) {
                        return function (/*...args, callback*/) {
                            var args = _baseSlice(arguments);
                            var callback = args.pop();
                            args.push(function () {
                                var innerArgs = arguments;
                                if (sync) {
                                    async.setImmediate(function () {
                                        callback.apply(null, innerArgs);
                                    });
                                } else {
                                    callback.apply(null, innerArgs);
                                }
                            });
                            var sync = true;
                            fn.apply(this, args);
                            sync = false;
                        };
                    }
                    
                    async.ensureAsync = ensureAsync;
                    
                    // Node.js
                    if (typeof module !== 'undefined' && module.exports) {
                        module.exports = async;
                    }
    // AMD / RequireJS
                    else if (typeof define !== 'undefined' && define.amd) {
                        define([], function () {
                            return async;
                        });
                    }
    // included directly via <script> tag
                    else {
                        root.async = async;
                    }

                }());

            }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, { "_process": 322 }], 15: [function (require, module, exports) {
            var bitcore = require('bitcore');
            bitcore.P2P = require('./lib');
            
            module.exports = bitcore.P2P;

        }, { "./lib": 18, "bitcore": "bitcore" }], 16: [function (require, module, exports) {
            'use strict';
            
            var bitcore = require('bitcore');
            var BloomFilter = require('bloom-filter');
            var BufferReader = bitcore.encoding.BufferReader;
            var BufferWriter = bitcore.encoding.BufferWriter;
            
            /**
 * A constructor for Bloom Filters
 * @see https://github.com/bitpay/bloom-filter
 * @param {Buffer} - payload
 */
BloomFilter.fromBuffer = function fromBuffer(payload) {
                var obj = {};
                var parser = new BufferReader(payload);
                var length = parser.readUInt8();
                obj.vData = [];
                for (var i = 0; i < length; i++) {
                    obj.vData.push(parser.readUInt8());
                }
                obj.nHashFuncs = parser.readUInt32LE();
                obj.nTweak = parser.readUInt32LE();
                obj.nFlags = parser.readUInt8();
                return new BloomFilter(obj);
            };
            
            /**
 * @returns {Buffer}
 */
BloomFilter.prototype.toBuffer = function toBuffer() {
                var bw = new BufferWriter();
                bw.writeVarintNum(this.vData.length);
                for (var i = 0; i < this.vData.length; i++) {
                    bw.writeUInt8(this.vData[i]);
                }
                bw.writeUInt32LE(this.nHashFuncs);
                bw.writeUInt32LE(this.nTweak);
                bw.writeUInt8(this.nFlags);
                return bw.concat();
            };
            
            module.exports = BloomFilter;

        }, { "bitcore": "bitcore", "bloom-filter": 48 }], 17: [function (require, module, exports) {
            (function (Buffer) {
                'use strict';
                
                var Buffers = require('buffers');
                
                Buffers.prototype.skip = function (i) {
                    if (i === 0) {
                        return;
                    }
                    
                    if (i >= this.length) {
                        this.buffers = [];
                        this.length = 0;
                        return;
                    }
                    
                    var pos = this.pos(i);
                    this.buffers = this.buffers.slice(pos.buf);
                    this.buffers[0] = new Buffer(this.buffers[0].slice(pos.offset));
                    this.length -= i;
                };
                
                module.exports = Buffers;


            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172, "buffers": 50 }], 18: [function (require, module, exports) {
            /**
 * @namespace P2P
 */

module.exports = {
                Inventory: require('./inventory'),
                BloomFilter: require('./bloomfilter'),
                Messages: require('./messages'),
                Peer: require('./peer'),
                Pool: require('./pool')
            };

        }, { "./bloomfilter": 16, "./inventory": 19, "./messages": 42, "./peer": 45, "./pool": 46 }], 19: [function (require, module, exports) {
            (function (Buffer) {
                'use strict';
                
                var bitcore = require('bitcore');
                var $ = bitcore.util.preconditions;
                var BufferUtil = bitcore.util.buffer;
                var BufferReader = bitcore.encoding.BufferReader;
                var BufferWriter = bitcore.encoding.BufferWriter;
                var _ = bitcore.deps._;
                
                /**
 * A constructor for inventory related Bitcoin messages such as
 * "getdata", "inv" and "notfound".
 * @param {Object} obj
 * @param {Number} obj.type - Inventory.TYPE
 * @param {Buffer} obj.hash - The hash for the inventory
 * @constructor
 */
function Inventory(obj) {
                    this.type = obj.type;
                    if (!BufferUtil.isBuffer(obj.hash)) {
                        throw new TypeError('Unexpected hash, expected to be a buffer');
                    }
                    this.hash = obj.hash;
                }
                
                /**
 * A convenience constructor for Inventory.
 * @param {Number} type - Inventory.TYPE
 * @param {Buffer|String} hash - The hash for the inventory
 * @returns {Inventory} - A new instance of Inventory
 */
Inventory.forItem = function (type, hash) {
                    $.checkArgument(hash);
                    if (_.isString(hash)) {
                        hash = new Buffer(hash, 'hex');
                        hash = BufferUtil.reverse(hash);
                    }
                    return new Inventory({ type: type, hash: hash });
                };
                
                /**
 * A convenience constructor for Inventory for block inventory types.
 * @param {Buffer|String} hash - The hash for the block inventory
 * @returns {Inventory} - A new instance of Inventory
 */
Inventory.forBlock = function (hash) {
                    return Inventory.forItem(Inventory.TYPE.BLOCK, hash);
                };
                
                /**
 * A convenience constructor for Inventory for filtered/merkle block inventory types.
 * @param {Buffer|String} hash - The hash for the filtered block inventory
 * @returns {Inventory} - A new instance of Inventory
 */
Inventory.forFilteredBlock = function (hash) {
                    return Inventory.forItem(Inventory.TYPE.FILTERED_BLOCK, hash);
                };
                
                /**
 * A convenience constructor for Inventory for transaction inventory types.
 * @param {Buffer|String} hash - The hash for the transaction inventory
 * @returns {Inventory} - A new instance of Inventory
 */
Inventory.forTransaction = function (hash) {
                    return Inventory.forItem(Inventory.TYPE.TX, hash);
                };
                
                /**
 * @returns {Buffer} - Serialized inventory
 */
Inventory.prototype.toBuffer = function () {
                    var bw = new BufferWriter();
                    bw.writeUInt32LE(this.type);
                    bw.write(this.hash);
                    return bw.concat();
                };
                
                /**
 * @param {BufferWriter} bw - An instance of BufferWriter
 */
Inventory.prototype.toBufferWriter = function (bw) {
                    bw.writeUInt32LE(this.type);
                    bw.write(this.hash);
                    return bw;
                };
                
                /**
 * @param {Buffer} payload - Serialized buffer of the inventory
 */
Inventory.fromBuffer = function (payload) {
                    var parser = new BufferReader(payload);
                    var obj = {};
                    obj.type = parser.readUInt32LE();
                    obj.hash = parser.read(32);
                    return new Inventory(obj);
                };
                
                /**
 * @param {BufferWriter} br - An instance of BufferWriter
 */
Inventory.fromBufferReader = function (br) {
                    var obj = {};
                    obj.type = br.readUInt32LE();
                    obj.hash = br.read(32);
                    return new Inventory(obj);
                };
                
                // https://en.bitcoin.it/wiki/Protocol_specification#Inventory_Vectors
                Inventory.TYPE = {};
                Inventory.TYPE.ERROR = 0;
                Inventory.TYPE.TX = 1;
                Inventory.TYPE.BLOCK = 2;
                Inventory.TYPE.FILTERED_BLOCK = 3;
                Inventory.TYPE_NAME = [
                    'ERROR',
                    'TX',
                    'BLOCK',
                    'FILTERED_BLOCK'
                ];
                
                module.exports = Inventory;

            }).call(this, require("buffer").Buffer)
        }, { "bitcore": "bitcore", "buffer": 172 }], 20: [function (require, module, exports) {
            'use strict';
            
            var bitcore = require('bitcore');
            var Inventory = require('../inventory');
            
            function builder(options) {
                /* jshint maxstatements: 20 */
                /* jshint maxcomplexity: 10 */
                
                if (!options) {
                    options = {};
                }
                
                if (!options.network) {
                    options.network = bitcore.Networks.defaultNetwork;
                }
                
                options.Block = options.Block || bitcore.Block;
                options.BlockHeader = options.BlockHeader || bitcore.BlockHeader;
                options.Transaction = options.Transaction || bitcore.Transaction;
                options.MerkleBlock = options.MerkleBlock || bitcore.MerkleBlock;
                options.protocolVersion = options.protocolVersion || 70000;
                
                var exported = {
                    constructors: {
                        Block: options.Block,
                        BlockHeader: options.BlockHeader,
                        Transaction: options.Transaction,
                        MerkleBlock: options.MerkleBlock
                    },
                    defaults: {
                        protocolVersion: options.protocolVersion,
                        network: options.network
                    },
                    inventoryCommands: [
                        'getdata',
                        'inv',
                        'notfound'
                    ],
                    commandsMap: {
                        version: require('./commands/version'),
                        verack: require('./commands/verack'),
                        ping: require('./commands/ping'),
                        pong: require('./commands/pong'),
                        block: require('./commands/block'),
                        tx: require('./commands/tx'),
                        getdata: require('./commands/getdata'),
                        headers: require('./commands/headers'),
                        notfound: require('./commands/notfound'),
                        inv: require('./commands/inv'),
                        addr: require('./commands/addr'),
                        alert: require('./commands/alert'),
                        reject: require('./commands/reject'),
                        merkleblock: require('./commands/merkleblock'),
                        filterload: require('./commands/filterload'),
                        filteradd: require('./commands/filteradd'),
                        filterclear: require('./commands/filterclear'),
                        getblocks: require('./commands/getblocks'),
                        getheaders: require('./commands/getheaders'),
                        mempool: require('./commands/mempool'),
                        getaddr: require('./commands/getaddr')
                    },
                    commands: {}
                };
                
                Object.keys(exported.commandsMap).forEach(function (key) {
                    var Command = exported.commandsMap[key];
                    exported.commands[key] = function (obj) {
                        return new Command(obj, options);
                    };
                    
                    exported.commands[key]._constructor = Command;
                    
                    exported.commands[key].fromBuffer = function (buffer) {
                        var message = exported.commands[key]();
                        message.setPayload(buffer);
                        return message;
                    };

                });
                
                exported.inventoryCommands.forEach(function (command) {
                    
                    // add forTransaction methods
                    exported.commands[command].forTransaction = function forTransaction(hash) {
                        return new exported.commands[command]([Inventory.forTransaction(hash)]);
                    };
                    
                    // add forBlock methods
                    exported.commands[command].forBlock = function forBlock(hash) {
                        return new exported.commands[command]([Inventory.forBlock(hash)]);
                    };
                    
                    // add forFilteredBlock methods
                    exported.commands[command].forFilteredBlock = function forFilteredBlock(hash) {
                        return new exported.commands[command]([Inventory.forFilteredBlock(hash)]);
                    };

                });
                
                return exported;

            }
            
            module.exports = builder;

        }, { "../inventory": 19, "./commands/addr": 21, "./commands/alert": 22, "./commands/block": 23, "./commands/filteradd": 24, "./commands/filterclear": 25, "./commands/filterload": 26, "./commands/getaddr": 27, "./commands/getblocks": 28, "./commands/getdata": 29, "./commands/getheaders": 30, "./commands/headers": 31, "./commands/inv": 32, "./commands/mempool": 33, "./commands/merkleblock": 34, "./commands/notfound": 35, "./commands/ping": 36, "./commands/pong": 37, "./commands/reject": 38, "./commands/tx": 39, "./commands/verack": 40, "./commands/version": 41, "bitcore": "bitcore" }], 21: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var utils = require('../utils');
            var $ = bitcore.util.preconditions;
            var _ = bitcore.deps._;
            var BufferReader = bitcore.encoding.BufferReader;
            var BufferWriter = bitcore.encoding.BufferWriter;
            
            /**
 * @param {Array=} arg - An array of addrs
 * @param {Object=} options
 * @extends Message
 * @constructor
 */
function AddrMessage(arg, options) {
                Message.call(this, options);
                this.command = 'addr';
                $.checkArgument(
                    _.isUndefined(arg) ||
      (Array.isArray(arg) &&
       !_.isUndefined(arg[0].services) &&
       !_.isUndefined(arg[0].ip) &&
       !_.isUndefined(arg[0].port)),
    'First argument is expected to be an array of addrs'
                );
                this.addresses = arg;
            }
            inherits(AddrMessage, Message);
            
            AddrMessage._name = 'Addresses';
            
            AddrMessage.prototype.setPayload = function (payload) {
                var parser = new BufferReader(payload);
                
                var addrCount = parser.readVarintNum();
                
                this.addresses = [];
                for (var i = 0; i < addrCount; i++) {
                    // todo: time only available on versions >=31402
                    var time = new Date(parser.readUInt32LE() * 1000);
                    
                    var addr = utils.parseAddr(parser);
                    addr.time = time;
                    this.addresses.push(addr);
                }
                
                utils.checkFinished(parser);
            };
            
            AddrMessage.prototype.getPayload = function () {
                var bw = new BufferWriter();
                bw.writeVarintNum(this.addresses.length);
                
                for (var i = 0; i < this.addresses.length; i++) {
                    var addr = this.addresses[i];
                    bw.writeUInt32LE(addr.time.getTime() / 1000);
                    utils.writeAddr(addr, bw);
                }
                
                return bw.concat();
            };
            
            module.exports = AddrMessage;

        }, { "../message": 43, "../utils": 44, "bitcore": "bitcore", "util": 342 }], 22: [function (require, module, exports) {
            (function (Buffer) {
                'use strict';
                
                var Message = require('../message');
                var inherits = require('util').inherits;
                var bitcore = require('bitcore');
                var utils = require('../utils');
                var BufferReader = bitcore.encoding.BufferReader;
                var BufferWriter = bitcore.encoding.BufferWriter;
                
                /**
 * @param {Object=} arg
 * @param {Buffer=} arg.payload
 * @param {Buffer=} arg.signature
 * @param {Object} options
 * @extends Message
 * @constructor
 */
function AlertMessage(arg, options) {
                    Message.call(this, options);
                    this.command = 'alert';
                    if (!arg) {
                        arg = {};
                    }
                    this.payload = arg.payload || new Buffer(32);
                    this.signature = arg.signature || new Buffer(32);
                }
                inherits(AlertMessage, Message);
                
                AlertMessage._name = 'Alert';
                
                AlertMessage.prototype.setPayload = function (payload) {
                    var parser = new BufferReader(payload);
                    this.payload = parser.readVarLengthBuffer();
                    this.signature = parser.readVarLengthBuffer();
                    utils.checkFinished(parser);
                };
                
                AlertMessage.prototype.getPayload = function () {
                    var bw = new BufferWriter();
                    bw.writeVarintNum(this.payload.length);
                    bw.write(this.payload);
                    
                    bw.writeVarintNum(this.signature.length);
                    bw.write(this.signature);
                    
                    return bw.concat();
                };
                
                module.exports = AlertMessage;

            }).call(this, require("buffer").Buffer)
        }, { "../message": 43, "../utils": 44, "bitcore": "bitcore", "buffer": 172, "util": 342 }], 23: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var $ = bitcore.util.preconditions;
            var _ = bitcore.deps._;
            
            /**
 * @param {Block=} arg - An instance of a Block
 * @param {Object} options
 * @param {Function} options.Block - A block constructor
 * @extends Message
 * @constructor
 */
function BlockMessage(arg, options) {
                Message.call(this, options);
                this.Block = options.Block;
                this.command = 'block';
                $.checkArgument(
                    _.isUndefined(arg) || arg instanceof this.Block,
    'An instance of Block or undefined is expected'
                );
                this.block = arg;
            }
            inherits(BlockMessage, Message);
            
            BlockMessage._name = 'Block';
            
            BlockMessage.prototype.setPayload = function (payload) {
                this.block = this.Block.fromBuffer(payload);
            };
            
            BlockMessage.prototype.getPayload = function () {
                return this.block.toBuffer();
            };
            
            module.exports = BlockMessage;

        }, { "../message": 43, "bitcore": "bitcore", "util": 342 }], 24: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var utils = require('../utils');
            var BufferUtil = bitcore.util.buffer;
            var BufferWriter = bitcore.encoding.BufferWriter;
            var BufferReader = bitcore.encoding.BufferReader;
            var $ = bitcore.util.preconditions;
            var _ = bitcore.deps._;
            
            /**
 * Request peer to add data to a bloom filter already set by 'filterload'
 * @param {Buffer=} data - Array of bytes representing bloom filter data
 * @param {Object=} options
 * @extends Message
 * @constructor
 */
function FilteraddMessage(arg, options) {
                Message.call(this, options);
                this.command = 'filteradd';
                $.checkArgument(
                    _.isUndefined(arg) || BufferUtil.isBuffer(arg),
    'First argument is expected to be a Buffer or undefined'
                );
                this.data = arg || BufferUtil.EMPTY_BUFFER;
            }
            inherits(FilteraddMessage, Message);
            
            FilteraddMessage._name = 'FilterAdd';
            
            FilteraddMessage.prototype.setPayload = function (payload) {
                $.checkArgument(payload);
                var parser = new BufferReader(payload);
                this.data = parser.readVarLengthBuffer();
                utils.checkFinished(parser);
            };
            
            FilteraddMessage.prototype.getPayload = function () {
                var bw = new BufferWriter();
                bw.writeVarintNum(this.data.length);
                bw.write(this.data);
                return bw.concat();
            };
            
            module.exports = FilteraddMessage;

        }, { "../message": 43, "../utils": 44, "bitcore": "bitcore", "util": 342 }], 25: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var BufferUtil = bitcore.util.buffer;
            
            /**
 * Request peer to clear data for a bloom filter
 * @extends Message
 * @constructor
 */
function FilterclearMessage(arg, options) {
                Message.call(this, options);
                this.command = 'filterclear';
            }
            inherits(FilterclearMessage, Message);
            
            FilterclearMessage._name = 'FilterClear';
            
            FilterclearMessage.prototype.setPayload = function () { };
            
            FilterclearMessage.prototype.getPayload = function () {
                return BufferUtil.EMPTY_BUFFER;
            };
            
            module.exports = FilterclearMessage;

        }, { "../message": 43, "bitcore": "bitcore", "util": 342 }], 26: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var BufferUtil = bitcore.util.buffer;
            var BloomFilter = require('../../bloomfilter');
            var $ = bitcore.util.preconditions;
            var _ = bitcore.deps._;
            
            /**
 * Request peer to send inv messages based on a bloom filter
 * @param {BloomFilter=} arg - An instance of BloomFilter
 * @param {Object} options
 * @extends Message
 * @constructor
 */
function FilterloadMessage(arg, options) {
                Message.call(this, options);
                this.command = 'filterload';
                $.checkArgument(
                    _.isUndefined(arg) || arg instanceof BloomFilter,
    'An instance of BloomFilter or undefined is expected'
                );
                this.filter = arg;
            }
            inherits(FilterloadMessage, Message);
            
            FilterloadMessage._name = 'FilterLoad';
            
            FilterloadMessage.prototype.setPayload = function (payload) {
                this.filter = BloomFilter.fromBuffer(payload);
            };
            
            FilterloadMessage.prototype.getPayload = function () {
                if (this.filter) {
                    return this.filter.toBuffer();
                } else {
                    return BufferUtil.EMPTY_BUFFER;
                }
            };
            
            module.exports = FilterloadMessage;

        }, { "../../bloomfilter": 16, "../message": 43, "bitcore": "bitcore", "util": 342 }], 27: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var BufferUtil = bitcore.util.buffer;
            
            /**
 * Request information about active peers
 * @extends Message
 * @param {Object} options
 * @constructor
 */
function GetaddrMessage(arg, options) {
                Message.call(this, options);
                this.command = 'getaddr';
            }
            inherits(GetaddrMessage, Message);
            
            GetaddrMessage._name = 'GetAddr';
            
            GetaddrMessage.prototype.setPayload = function () { };
            
            GetaddrMessage.prototype.getPayload = function () {
                return BufferUtil.EMPTY_BUFFER;
            };
            
            module.exports = GetaddrMessage;

        }, { "../message": 43, "bitcore": "bitcore", "util": 342 }], 28: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var utils = require('../utils');
            var BufferReader = bitcore.encoding.BufferReader;
            var BufferWriter = bitcore.encoding.BufferWriter;
            var $ = bitcore.util.preconditions;
            
            /**
 * Query another peer about blocks. It can query for multiple block hashes,
 * and the response will contain all the chains of blocks starting from those
 * hashes.
 * @param {Object=} arg
 * @param {Array=} arg.starts - Array of buffers or strings with the starting block hashes
 * @param {Buffer=} arg.stop - Hash of the last block
 * @param {Object} options
 * @extends Message
 * @constructor
 */
function GetblocksMessage(arg, options) {
                Message.call(this, options);
                this.command = 'getblocks';
                this.version = options.protocolVersion;
                if (!arg) {
                    arg = {};
                }
                arg = utils.sanitizeStartStop(arg);
                this.starts = arg.starts;
                this.stop = arg.stop;
            }
            inherits(GetblocksMessage, Message);
            
            GetblocksMessage._name = 'GetBlocks';
            
            GetblocksMessage.prototype.setPayload = function (payload) {
                var parser = new BufferReader(payload);
                $.checkArgument(!parser.finished(), 'No data received in payload');
                
                this.version = parser.readUInt32LE();
                var startCount = parser.readVarintNum();
                
                this.starts = [];
                for (var i = 0; i < startCount; i++) {
                    this.starts.push(parser.read(32));
                }
                this.stop = parser.read(32);
                utils.checkFinished(parser);
            };
            
            GetblocksMessage.prototype.getPayload = function () {
                var bw = new BufferWriter();
                bw.writeUInt32LE(this.version);
                bw.writeVarintNum(this.starts.length);
                for (var i = 0; i < this.starts.length; i++) {
                    bw.write(this.starts[i]);
                }
                if (this.stop.length !== 32) {
                    throw new Error('Invalid hash length: ' + this.stop.length);
                }
                bw.write(this.stop);
                return bw.concat();
            };
            
            module.exports = GetblocksMessage;

        }, { "../message": 43, "../utils": 44, "bitcore": "bitcore", "util": 342 }], 29: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var utils = require('../utils');
            var BufferReader = bitcore.encoding.BufferReader;
            var BufferWriter = bitcore.encoding.BufferWriter;
            var _ = bitcore.deps._;
            
            /**
 * @param {Object|Array=} - options - If options is an array will use as "inventory"
 * @param {Array=} options.inventory - An array of inventory items
 * @extends Message
 * @constructor
 */
function GetdataMessage(arg, options) {
                Message.call(this, options);
                this.command = 'getdata';
                utils.checkInventory(arg);
                this.inventory = arg;
            }
            inherits(GetdataMessage, Message);
            
            GetdataMessage._name = 'GetData';
            
            GetdataMessage.prototype.setPayload = function (payload) {
                this.inventory = [];
                
                var parser = new BufferReader(payload);
                var count = parser.readVarintNum();
                for (var i = 0; i < count; i++) {
                    var type = parser.readUInt32LE();
                    var hash = parser.read(32);
                    this.inventory.push({ type: type, hash: hash });
                }
                
                utils.checkFinished(parser);
            };
            
            GetdataMessage.prototype.getPayload = function () {
                var bw = new BufferWriter();
                utils.writeInventory(this.inventory, bw);
                return bw.concat();
            };
            
            module.exports = GetdataMessage;

        }, { "../message": 43, "../utils": 44, "bitcore": "bitcore", "util": 342 }], 30: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var utils = require('../utils');
            var BufferReader = bitcore.encoding.BufferReader;
            var BufferWriter = bitcore.encoding.BufferWriter;
            var $ = bitcore.util.preconditions;
            
            /**
 * Query another peer about block headers. It can query for multiple block hashes,
 * and the response will contain all the chains of blocks starting from those
 * hashes.
 * @param {Object=} options
 * @param {Array=} options.starts - Array of buffers or strings with the starting block hashes
 * @param {Buffer=} options.stop - Hash of the last block
 * @extends Message
 * @constructor
 */
function GetheadersMessage(arg, options) {
                Message.call(this, options);
                this.command = 'getheaders';
                this.version = options.protocolVersion;
                if (!arg) {
                    arg = {};
                }
                arg = utils.sanitizeStartStop(arg);
                this.starts = arg.starts;
                this.stop = arg.stop;
            }
            inherits(GetheadersMessage, Message);
            
            GetheadersMessage._name = 'GetHeaders';
            
            GetheadersMessage.prototype.setPayload = function (payload) {
                var parser = new BufferReader(payload);
                $.checkArgument(!parser.finished(), 'No data received in payload');
                
                this.version = parser.readUInt32LE();
                var startCount = Math.min(parser.readVarintNum(), 500);
                
                this.starts = [];
                for (var i = 0; i < startCount; i++) {
                    this.starts.push(parser.read(32));
                }
                this.stop = parser.read(32);
                utils.checkFinished(parser);
            };
            
            GetheadersMessage.prototype.getPayload = function () {
                var bw = new BufferWriter();
                bw.writeUInt32LE(this.version);
                bw.writeVarintNum(this.starts.length);
                for (var i = 0; i < this.starts.length; i++) {
                    bw.write(this.starts[i]);
                }
                if (this.stop.length !== 32) {
                    throw new Error('Invalid hash length: ' + this.stop.length);
                }
                bw.write(this.stop);
                return bw.concat();
            };
            
            module.exports = GetheadersMessage;

        }, { "../message": 43, "../utils": 44, "bitcore": "bitcore", "util": 342 }], 31: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var utils = require('../utils');
            var BufferReader = bitcore.encoding.BufferReader;
            var BufferWriter = bitcore.encoding.BufferWriter;
            var _ = bitcore.deps._;
            var $ = bitcore.util.preconditions;
            
            /**
 * Sent in response to a `getheaders` message. It contains information about
 * block headers.
 * @param {Array} arg - An array of BlockHeader instances
 * @param {Object=} options
 * @param {Array=} options.headers - array of block headers
 * @param {Function} options.BlockHeader - a BlockHeader constructor
 * @extends Message
 * @constructor
 */
function HeadersMessage(arg, options) {
                Message.call(this, options);
                this.BlockHeader = options.BlockHeader;
                this.command = 'headers';
                $.checkArgument(
                    _.isUndefined(arg) || (Array.isArray(arg) && arg[0] instanceof this.BlockHeader),
    'First argument is expected to be an array of BlockHeader instances'
                );
                this.headers = arg;
            }
            inherits(HeadersMessage, Message);
            
            HeadersMessage._name = 'Headers';
            
            HeadersMessage.prototype.setPayload = function (payload) {
                $.checkArgument(payload && payload.length > 0, 'No data found to create Headers message');
                var parser = new BufferReader(payload);
                var count = parser.readVarintNum();
                
                this.headers = [];
                for (var i = 0; i < count; i++) {
                    var header = this.BlockHeader.fromBufferReader(parser);
                    this.headers.push(header);
                    var txn_count = parser.readUInt8();
                    $.checkState(txn_count === 0, 'txn_count should always be 0');
                }
                utils.checkFinished(parser);
            };
            
            HeadersMessage.prototype.getPayload = function () {
                var bw = new BufferWriter();
                bw.writeVarintNum(this.headers.length);
                for (var i = 0; i < this.headers.length; i++) {
                    var buffer = this.headers[i].toBuffer();
                    bw.write(buffer);
                    bw.writeUInt8(0);
                }
                return bw.concat();
            };
            
            module.exports = HeadersMessage;

        }, { "../message": 43, "../utils": 44, "bitcore": "bitcore", "util": 342 }], 32: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var utils = require('../utils');
            var BufferReader = bitcore.encoding.BufferReader;
            var BufferWriter = bitcore.encoding.BufferWriter;
            var _ = bitcore.deps._;
            
            /**
 * @param {Array=} arg - An array of inventory
 * @param {Object} options
 * @param {Array=} options.inventory - An array of inventory items
 * @extends Message
 * @constructor
 */
function InvMessage(arg, options) {
                Message.call(this, options);
                this.command = 'inv';
                utils.checkInventory(arg);
                this.inventory = arg;
            }
            inherits(InvMessage, Message);
            
            InvMessage._name = 'Inventory';
            
            InvMessage.prototype.setPayload = function (payload) {
                this.inventory = [];
                
                var parser = new BufferReader(payload);
                var count = parser.readVarintNum();
                for (var i = 0; i < count; i++) {
                    var type = parser.readUInt32LE();
                    var hash = parser.read(32);
                    this.inventory.push({ type: type, hash: hash });
                }
                
                utils.checkFinished(parser);
            };
            
            InvMessage.prototype.getPayload = function () {
                var bw = new BufferWriter();
                utils.writeInventory(this.inventory, bw);
                return bw.concat();
            };
            
            module.exports = InvMessage;

        }, { "../message": 43, "../utils": 44, "bitcore": "bitcore", "util": 342 }], 33: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var BufferUtil = bitcore.util.buffer;
            
            /**
 * The mempool message sends a request to a node asking for information about
 * transactions it has verified but which have not yet confirmed.
 * @see https://en.bitcoin.it/wiki/Protocol_documentation#mempool
 * @param {Object} options
 * @extends Message
 * @constructor
 */
function MempoolMessage(arg, options) {
                Message.call(this, options);
                this.command = 'mempool';
            }
            inherits(MempoolMessage, Message);
            
            MempoolMessage._name = 'MemPool';
            
            MempoolMessage.prototype.setPayload = function () { };
            
            MempoolMessage.prototype.getPayload = function () {
                return BufferUtil.EMPTY_BUFFER;
            };
            
            module.exports = MempoolMessage;

        }, { "../message": 43, "bitcore": "bitcore", "util": 342 }], 34: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var BufferUtil = bitcore.util.buffer;
            var $ = bitcore.util.preconditions;
            var _ = bitcore.deps._;
            
            /**
 * Contains information about a MerkleBlock
 * @see https://en.bitcoin.it/wiki/Protocol_documentation
 * @param {MerkleBlock} arg - An instance of MerkleBlock
 * @param {Object=} options
 * @param {Function} options.MerkleBlock - a MerkleBlock constructor
 * @extends Message
 * @constructor
 */
function MerkleblockMessage(arg, options) {
                Message.call(this, options);
                this.MerkleBlock = options.MerkleBlock; // constructor
                this.command = 'merkleblock';
                $.checkArgument(
                    _.isUndefined(arg) || arg instanceof this.MerkleBlock,
    'An instance of MerkleBlock or undefined is expected'
                );
                this.merkleBlock = arg;
            }
            inherits(MerkleblockMessage, Message);
            
            MerkleblockMessage._name = 'MerkleBlock';
            
            MerkleblockMessage.prototype.setPayload = function (payload) {
                $.checkArgument(BufferUtil.isBuffer(payload));
                this.merkleBlock = this.MerkleBlock.fromBuffer(payload);
            };
            
            MerkleblockMessage.prototype.getPayload = function () {
                return this.merkleBlock ? this.merkleBlock.toBuffer() : BufferUtil.EMPTY_BUFFER;
            };
            
            module.exports = MerkleblockMessage;

        }, { "../message": 43, "bitcore": "bitcore", "util": 342 }], 35: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var utils = require('../utils');
            var BufferReader = bitcore.encoding.BufferReader;
            var BufferWriter = bitcore.encoding.BufferWriter;
            var _ = bitcore.deps._;
            
            /**
 * @param {Array} arg - An array of inventory
 * @param {Object} options
 * @param {Array=} options.inventory - An array of inventory items
 * @extends Message
 * @constructor
 */
function NotfoundMessage(arg, options) {
                Message.call(this, options);
                this.command = 'notfound';
                utils.checkInventory(arg);
                this.inventory = arg;
            }
            inherits(NotfoundMessage, Message);
            
            NotfoundMessage._name = 'NotFound';
            
            NotfoundMessage.prototype.setPayload = function (payload) {
                this.inventory = [];
                
                var parser = new BufferReader(payload);
                var count = parser.readVarintNum();
                for (var i = 0; i < count; i++) {
                    var type = parser.readUInt32LE();
                    var hash = parser.read(32);
                    this.inventory.push({ type: type, hash: hash });
                }
                
                utils.checkFinished(parser);
            };
            
            NotfoundMessage.prototype.getPayload = function () {
                var bw = new BufferWriter();
                utils.writeInventory(this.inventory, bw);
                return bw.concat();
            };
            
            module.exports = NotfoundMessage;

        }, { "../message": 43, "../utils": 44, "bitcore": "bitcore", "util": 342 }], 36: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var utils = require('../utils');
            var $ = bitcore.util.preconditions;
            var _ = bitcore.deps._;
            var BufferUtil = bitcore.util.buffer;
            var BufferReader = bitcore.encoding.BufferReader;
            
            /**
 * A message to confirm that a connection is still valid.
 * @param {Number} arg - A nonce for the Ping message
 * @param {Object=} options
 * @extends Message
 * @constructor
 */
function PingMessage(arg, options) {
                Message.call(this, options);
                this.command = 'ping';
                $.checkArgument(
                    _.isUndefined(arg) || (BufferUtil.isBuffer(arg) && arg.length === 8),
    'First argument is expected to be an 8 byte buffer'
                );
                this.nonce = arg || utils.getNonce();
            }
            inherits(PingMessage, Message);
            
            PingMessage._name = 'Ping';
            
            PingMessage.prototype.setPayload = function (payload) {
                var parser = new BufferReader(payload);
                this.nonce = parser.read(8);
                
                utils.checkFinished(parser);
            };
            
            PingMessage.prototype.getPayload = function () {
                return this.nonce;
            };
            
            module.exports = PingMessage;

        }, { "../message": 43, "../utils": 44, "bitcore": "bitcore", "util": 342 }], 37: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var utils = require('../utils');
            var $ = bitcore.util.preconditions;
            var _ = bitcore.deps._;
            var BufferUtil = bitcore.util.buffer;
            var BufferReader = bitcore.encoding.BufferReader;
            
            /**
 * A message in response to a ping message.
 * @param {Number} arg - A nonce for the Pong message
 * @param {Object=} options
 * @extends Message
 * @constructor
 */
function PongMessage(arg, options) {
                Message.call(this, options);
                this.command = 'pong';
                $.checkArgument(
                    _.isUndefined(arg) || (BufferUtil.isBuffer(arg) && arg.length === 8),
    'First argument is expected to be an 8 byte buffer'
                );
                this.nonce = arg || utils.getNonce();
            }
            inherits(PongMessage, Message);
            
            PongMessage._name = 'Pong';
            
            PongMessage.prototype.setPayload = function (payload) {
                var parser = new BufferReader(payload);
                this.nonce = parser.read(8);
                
                utils.checkFinished(parser);
            };
            
            PongMessage.prototype.getPayload = function () {
                return this.nonce;
            };
            
            module.exports = PongMessage;

        }, { "../message": 43, "../utils": 44, "bitcore": "bitcore", "util": 342 }], 38: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var BufferUtil = bitcore.util.buffer;
            
            // todo: add payload: https://en.bitcoin.it/wiki/Protocol_documentation#reject
            function RejectMessage(arg, options) {
                Message.call(this, options);
                this.command = 'reject';
            }
            inherits(RejectMessage, Message);
            
            RejectMessage._name = 'Reject';
            
            RejectMessage.prototype.setPayload = function () { };
            
            RejectMessage.prototype.getPayload = function () {
                return BufferUtil.EMPTY_BUFFER;
            };
            
            module.exports = RejectMessage;

        }, { "../message": 43, "bitcore": "bitcore", "util": 342 }], 39: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var $ = bitcore.util.preconditions;
            var _ = bitcore.deps._;
            
            /**
 * @param {Transaction=} arg - An instance of Transaction
 * @param {Object} options
 * @extends Message
 * @constructor
 */
function TransactionMessage(arg, options) {
                Message.call(this, options);
                this.command = 'tx';
                this.Transaction = options.Transaction;
                $.checkArgument(
                    _.isUndefined(arg) || arg instanceof this.Transaction,
    'An instance of Transaction or undefined is expected'
                );
                this.transaction = arg;
                if (!this.transaction) {
                    this.transaction = new this.Transaction();
                }
            }
            inherits(TransactionMessage, Message);
            
            TransactionMessage._name = 'Transaction';
            
            TransactionMessage.prototype.setPayload = function (payload) {
                if (this.Transaction.prototype.fromBuffer) {
                    this.transaction = new this.Transaction().fromBuffer(payload);
                } else {
                    this.transaction = this.Transaction.fromBuffer(payload);
                }
            };
            
            TransactionMessage.prototype.getPayload = function () {
                return this.transaction.toBuffer();
            };
            
            module.exports = TransactionMessage;

        }, { "../message": 43, "bitcore": "bitcore", "util": 342 }], 40: [function (require, module, exports) {
            'use strict';
            
            var Message = require('../message');
            var inherits = require('util').inherits;
            var bitcore = require('bitcore');
            var BufferUtil = bitcore.util.buffer;
            
            /**
 * A message in response to a version message.
 * @extends Message
 * @constructor
 */
function VerackMessage(arg, options) {
                Message.call(this, options);
                this.command = 'verack';
            }
            inherits(VerackMessage, Message);
            
            VerackMessage._name = 'VerAck';
            
            VerackMessage.prototype.setPayload = function () { };
            
            VerackMessage.prototype.getPayload = function () {
                return BufferUtil.EMPTY_BUFFER;
            };
            
            module.exports = VerackMessage;

        }, { "../message": 43, "bitcore": "bitcore", "util": 342 }], 41: [function (require, module, exports) {
            (function (Buffer) {
                'use strict';
                
                var Message = require('../message');
                var inherits = require('util').inherits;
                var bitcore = require('bitcore');
                var BufferWriter = bitcore.encoding.BufferWriter;
                var BufferReader = bitcore.encoding.BufferReader;
                var BN = bitcore.crypto.BN;
                
                var utils = require('../utils');
                var packageInfo = require('../../../package.json');
                
                /**
 * The version message is used on connection creation to advertise
 * the type of node. The remote node will respond with its version, and no
 * communication is possible until both peers have exchanged their versions.
 *
 * @see https://en.bitcoin.it/wiki/Protocol_documentation#version
 * @param {Object=} arg - properties for the version message
 * @param {Buffer=} arg.nonce - a random 8 byte buffer
 * @param {String=} arg.subversion - version of the client
 * @param {BN=} arg.services
 * @param {Date=} arg.timestamp
 * @param {Number=} arg.startHeight
 * @param {Object} options
 * @extends Message
 * @constructor
 */
function VersionMessage(arg, options) {
                    /* jshint maxcomplexity: 10 */
                    if (!arg) {
                        arg = {};
                    }
                    Message.call(this, options);
                    this.command = 'version';
                    this.version = arg.version || options.protocolVersion;
                    this.nonce = arg.nonce || utils.getNonce();
                    this.services = arg.services || new BN(1, 10);
                    this.timestamp = arg.timestamp || new Date();
                    this.subversion = arg.subversion || '/bitcore:' + packageInfo.version + '/';
                    this.startHeight = arg.startHeight || 0;
                    this.relay = arg.relay === false ? false : true;
                }
                inherits(VersionMessage, Message);
                
                VersionMessage._name = 'Version';
                
                VersionMessage.prototype.setPayload = function (payload) {
                    var parser = new BufferReader(payload);
                    this.version = parser.readUInt32LE();
                    this.services = parser.readUInt64LEBN();
                    this.timestamp = new Date(parser.readUInt64LEBN().toNumber() * 1000);
                    
                    this.addrMe = {
                        services: parser.readUInt64LEBN(),
                        ip: utils.parseIP(parser),
                        port: parser.readUInt16BE()
                    };
                    this.addrYou = {
                        services: parser.readUInt64LEBN(),
                        ip: utils.parseIP(parser),
                        port: parser.readUInt16BE()
                    };
                    this.nonce = parser.read(8);
                    this.subversion = parser.readVarLengthBuffer().toString();
                    this.startHeight = parser.readUInt32LE();
                    
                    if (parser.finished()) {
                        this.relay = true;
                    } else {
                        this.relay = !!parser.readUInt8();
                    }
                    utils.checkFinished(parser);
                };
                
                VersionMessage.prototype.getPayload = function () {
                    var bw = new BufferWriter();
                    bw.writeUInt32LE(this.version);
                    bw.writeUInt64LEBN(this.services);
                    
                    var timestampBuffer = new Buffer(Array(8));
                    timestampBuffer.writeUInt32LE(Math.round(this.timestamp.getTime() / 1000), 0);
                    bw.write(timestampBuffer);
                    
                    utils.writeAddr(this.addrMe, bw);
                    utils.writeAddr(this.addrYou, bw);
                    bw.write(this.nonce);
                    bw.writeVarintNum(this.subversion.length);
                    bw.write(new Buffer(this.subversion, 'ascii'));
                    bw.writeUInt32LE(this.startHeight);
                    bw.writeUInt8(this.relay);
                    
                    return bw.concat();
                };
                
                module.exports = VersionMessage;

            }).call(this, require("buffer").Buffer)
        }, { "../../../package.json": 57, "../message": 43, "../utils": 44, "bitcore": "bitcore", "buffer": 172, "util": 342 }], 42: [function (require, module, exports) {
            'use strict';
            
            var bitcore = require('bitcore');
            var BufferUtil = bitcore.util.buffer;
            var Hash = bitcore.crypto.Hash;
            var $ = bitcore.util.preconditions;
            
            /**
 * A factory to build Bitcoin protocol messages.
 * @param {Object=} options
 * @param {Network=} options.network
 * @param {Function=} options.Block - A block constructor
 * @param {Function=} options.BlockHeader - A block header constructor
 * @param {Function=} options.MerkleBlock - A merkle block constructor
 * @param {Function=} options.Transaction - A transaction constructor
 * @constructor
 */
function Messages(options) {
                this.builder = Messages.builder(options);
                
                // map message constructors by name
                for (var key in this.builder.commandsMap) {
                    var name = this.builder.commandsMap[key]._name;
                    this[name] = this.builder.commands[key];
                }
                
                if (!options) {
                    options = {};
                }
                this.network = options.network || bitcore.Networks.defaultNetwork;
            }
            
            Messages.MINIMUM_LENGTH = 20;
            Messages.PAYLOAD_START = 16;
            Messages.Message = require('./message');
            Messages.builder = require('./builder');
            
            /**
 * @param {Buffers} dataBuffer
 */
Messages.prototype.parseBuffer = function (dataBuffer) {
                /* jshint maxstatements: 18 */
                if (dataBuffer.length < Messages.MINIMUM_LENGTH) {
                    return;
                }
                
                // Search the next magic number
                if (!this._discardUntilNextMessage(dataBuffer)) {
                    return;
                }
                
                var payloadLen = (dataBuffer.get(Messages.PAYLOAD_START)) +
    (dataBuffer.get(Messages.PAYLOAD_START + 1) << 8) +
    (dataBuffer.get(Messages.PAYLOAD_START + 2) << 16) +
    (dataBuffer.get(Messages.PAYLOAD_START + 3) << 24);
                
                var messageLength = 24 + payloadLen;
                if (dataBuffer.length < messageLength) {
                    return;
                }
                
                var command = dataBuffer.slice(4, 16).toString('ascii').replace(/\0+$/, '');
                var payload = dataBuffer.slice(24, messageLength);
                var checksum = dataBuffer.slice(20, 24);
                
                var checksumConfirm = Hash.sha256sha256(payload).slice(0, 4);
                if (!BufferUtil.equals(checksumConfirm, checksum)) {
                    dataBuffer.skip(messageLength);
                    return;
                }
                
                dataBuffer.skip(messageLength);
                
                return this._buildFromBuffer(command, payload);
            };
            
            Messages.prototype._discardUntilNextMessage = function (dataBuffer) {
                $.checkArgument(dataBuffer);
                $.checkState(this.network, 'network must be set');
                var i = 0;
                for (;;) {
                    // check if it's the beginning of a new message
                    var packageNumber = dataBuffer.slice(0, 4).toString('hex');
                    if (packageNumber === this.network.networkMagic.toString('hex')) {
                        dataBuffer.skip(i);
                        return true;
                    }
                    
                    // did we reach the end of the buffer?
                    if (i > (dataBuffer.length - 4)) {
                        dataBuffer.skip(i);
                        return false;
                    }
                    
                    i++; // continue scanning
                }
            };
            
            Messages.prototype._buildFromBuffer = function (command, payload) {
                if (!this.builder.commands[command]) {
                    throw new Error('Unsupported message command: ' + command);
                }
                return this.builder.commands[command].fromBuffer(payload);
            };
            
            module.exports = Messages;

        }, { "./builder": 20, "./message": 43, "bitcore": "bitcore" }], 43: [function (require, module, exports) {
            (function (Buffer) {
                'use strict';
                
                var bitcore = require('bitcore');
                var $ = bitcore.util.preconditions;
                var BufferWriter = bitcore.encoding.BufferWriter;
                var Hash = bitcore.crypto.Hash;
                
                /**
 * Base message that can be inherited to add an additional
 * `getPayload` method to modify the message payload.
 * @param {Object=} options
 * @param {String=} options.command
 * @param {Network=} options.network
 * @constructor
 */
function Message(options) {
                    this.command = options.command;
                    this.network = options.network;
                }
                
                /**
 * @returns {Buffer} - Serialized message
 * @constructor
 */
Message.prototype.toBuffer = Message.prototype.serialize = function () {
                    $.checkState(this.network, 'Need to have a defined network to serialize message');
                    var commandBuf = new Buffer(Array(12));
                    commandBuf.write(this.command, 'ascii');
                    
                    var payload = this.getPayload();
                    var checksum = Hash.sha256sha256(payload).slice(0, 4);
                    
                    var bw = new BufferWriter();
                    bw.write(this.network.networkMagic);
                    bw.write(commandBuf);
                    bw.writeUInt32LE(payload.length);
                    bw.write(checksum);
                    bw.write(payload);
                    
                    return bw.concat();
                };
                
                module.exports = Message;

            }).call(this, require("buffer").Buffer)
        }, { "bitcore": "bitcore", "buffer": 172 }], 44: [function (require, module, exports) {
            (function (Buffer) {
                'use strict';
                
                var bitcore = require('bitcore');
                var BufferUtil = bitcore.util.buffer;
                var $ = bitcore.util.preconditions;
                var _ = bitcore.deps._;
                var utils;
                
                module.exports = utils = {
                    checkInventory: function (arg) {
                        $.checkArgument(
                            _.isUndefined(arg) ||
        (Array.isArray(arg) && arg.length === 0) ||
        (Array.isArray(arg) && !_.isUndefined(arg[0].type) && !_.isUndefined(arg[0].hash)),
      'Argument is expected to be an array of inventory objects'
                        );
                    },
                    checkFinished: function checkFinished(parser) {
                        if (!parser.finished()) {
                            throw new Error('Data still available after parsing');
                        }
                    },
                    getNonce: function getNonce() {
                        return bitcore.crypto.Random.getRandomBuffer(8);
                    },
                    writeIP: function writeIP(ip, bw) {
                        var words = ip.v6.split(':').map(function (s) {
                            return new Buffer(s, 'hex');
                        });
                        for (var i = 0; i < words.length; i++) {
                            var word = words[i];
                            bw.write(word);
                        }
                    },
                    writeAddr: function writeAddr(addr, bw) {
                        if (_.isUndefined(addr)) {
                            var pad = new Buffer(Array(26));
                            bw.write(pad);
                            return;
                        }
                        
                        bw.writeUInt64LEBN(addr.services);
                        utils.writeIP(addr.ip, bw);
                        bw.writeUInt16BE(addr.port);
                    },
                    writeInventory: function writeInventory(inventory, bw) {
                        bw.writeVarintNum(inventory.length);
                        inventory.forEach(function (value) {
                            bw.writeUInt32LE(value.type);
                            bw.write(value.hash);
                        });
                    },
                    parseIP: function parseIP(parser) {
                        var ipv6 = [];
                        var ipv4 = [];
                        for (var a = 0; a < 8; a++) {
                            var word = parser.read(2);
                            ipv6.push(word.toString('hex'));
                            if (a >= 6) {
                                ipv4.push(word[0]);
                                ipv4.push(word[1]);
                            }
                        }
                        ipv6 = ipv6.join(':');
                        ipv4 = ipv4.join('.');
                        return {
                            v6: ipv6,
                            v4: ipv4
                        };
                    },
                    parseAddr: function parseAddr(parser) {
                        var services = parser.readUInt64LEBN();
                        var ip = utils.parseIP(parser);
                        var port = parser.readUInt16BE();
                        return {
                            services: services,
                            ip: ip,
                            port: port
                        };
                    },
                    sanitizeStartStop: function sanitizeStartStop(obj) {
                        /* jshint maxcomplexity: 10 */
                        /* jshint maxstatements: 20 */
                        $.checkArgument(_.isUndefined(obj.starts) || _.isArray(obj.starts));
                        var starts = obj.starts;
                        var stop = obj.stop;
                        if (starts) {
                            starts = starts.map(function (hash) {
                                if (_.isString(hash)) {
                                    return BufferUtil.reverse(new Buffer(hash, 'hex'));
                                } else {
                                    return hash;
                                }
                            });
                        } else {
                            starts = [];
                        }
                        
                        for (var i = 0; i < starts.length; i++) {
                            if (starts[i].length !== 32) {
                                throw new Error('Invalid hash ' + i + ' length: ' + starts[i].length);
                            }
                        }
                        
                        stop = obj.stop;
                        if (_.isString(stop)) {
                            stop = BufferUtil.reverse(new Buffer(stop, 'hex'));
                        }
                        if (!stop) {
                            stop = BufferUtil.NULL_HASH;
                        }
                        obj.starts = starts;
                        obj.stop = stop;
                        
                        return obj;
                    }
                };

            }).call(this, require("buffer").Buffer)
        }, { "bitcore": "bitcore", "buffer": 172 }], 45: [function (require, module, exports) {
            'use strict';
            
            var Buffers = require('./buffers');
            var EventEmitter = require('events').EventEmitter;
            var Net = require('net');
            var Socks5Client = require('socks5-client');
            var bitcore = require('bitcore');
            var Networks = bitcore.Networks;
            var Messages = require('./messages');
            var $ = bitcore.util.preconditions;
            var util = require('util');
            
            /**
 * The Peer constructor will create an instance of Peer to send and receive messages
 * using the standard Bitcoin protocol. A Peer instance represents one connection
 * on the Bitcoin network. To create a new peer connection provide the host and port
 * options and then invoke the connect method. Additionally, a newly connected socket
 * can be provided instead of host and port.
 *
 * @example
 * ```javascript
 *
 * var peer = new Peer({host: '127.0.0.1'}).setProxy('127.0.0.1', 9050);
 * peer.on('tx', function(tx) {
 *  console.log('New transaction: ', tx.id);
 * });
 * peer.connect();
 * ```
 *
 * @param {Object} options
 * @param {String} options.host - IP address of the remote host
 * @param {Number} options.port - Port number of the remote host
 * @param {Network} options.network - The network configuration
 * @param {Boolean=} options.relay - An option to disable automatic inventory relaying from the remote peer
 * @param {Socket=} options.socket - An existing connected socket

 * @returns {Peer} A new instance of Peer.
 * @constructor
 */
function Peer(options) {
                /* jshint maxstatements: 26 */
                /* jshint maxcomplexity: 8 */
                
                if (!(this instanceof Peer)) {
                    return new Peer(options);
                }
                
                if (options.socket) {
                    this.socket = options.socket;
                    this.host = this.socket.remoteAddress;
                    this.port = this.socket.remotePort;
                    this.status = Peer.STATUS.CONNECTED;
                    this._addSocketEventHandlers();
                } else {
                    this.host = options.host || 'localhost';
                    this.status = Peer.STATUS.DISCONNECTED;
                    this.port = options.port;
                }
                
                this.network = Networks.get(options.network) || Networks.defaultNetwork;
                
                if (!this.port) {
                    this.port = this.network.port;
                }
                
                this.messages = options.messages || new Messages({
                    network: this.network,
                    Block: bitcore.Block,
                    Transaction: bitcore.Transaction
                });
                
                this.dataBuffer = new Buffers();
                
                this.version = 0;
                this.bestHeight = 0;
                this.subversion = null;
                this.relay = options.relay === false ? false : true;
                
                this.versionSent = false;
                
                // set message handlers
                var self = this;
                this.on('verack', function () {
                    self.status = Peer.STATUS.READY;
                    self.emit('ready');
                });
                
                this.on('version', function (message) {
                    self.version = message.version;
                    self.subversion = message.subversion;
                    self.bestHeight = message.startHeight;
                    
                    var verackResponse = self.messages.VerAck();
                    self.sendMessage(verackResponse);
                    
                    if (!self.versionSent) {
                        self._sendVersion();
                    }
                });
                
                this.on('ping', function (message) {
                    self._sendPong(message.nonce);
                });
                
                return this;

            }
            util.inherits(Peer, EventEmitter);
            
            Peer.MAX_RECEIVE_BUFFER = 10000000;
            Peer.STATUS = {
                DISCONNECTED: 'disconnected',
                CONNECTING: 'connecting',
                CONNECTED: 'connected',
                READY: 'ready'
            };
            
            /**
 * Set a socks5 proxy for the connection. Enables the use of the TOR network.
 * @param {String} host - IP address of the proxy
 * @param {Number} port - Port number of the proxy
 * @returns {Peer} The same Peer instance.
 */
Peer.prototype.setProxy = function (host, port) {
                $.checkState(this.status === Peer.STATUS.DISCONNECTED);
                
                this.proxy = {
                    host: host,
                    port: port
                };
                return this;
            };
            
            /**
 * Init the connection with the remote peer.
 * @returns {Peer} The same peer instance.
 */
Peer.prototype.connect = function () {
                this.socket = this._getSocket();
                this.status = Peer.STATUS.CONNECTING;
                
                var self = this;
                this.socket.on('connect', function (ev) {
                    self.status = Peer.STATUS.CONNECTED;
                    self.emit('connect');
                    self._sendVersion();
                });
                
                this._addSocketEventHandlers();
                this.socket.connect(this.port, this.host);
                return this;
            };
            
            Peer.prototype._addSocketEventHandlers = function () {
                var self = this;
                
                this.socket.on('error', self._onError.bind(this));
                this.socket.on('end', self.disconnect.bind(this));
                
                this.socket.on('data', function (data) {
                    self.dataBuffer.push(data);
                    
                    if (self.dataBuffer.length > Peer.MAX_RECEIVE_BUFFER) {
                        // TODO: handle this case better
                        return self.disconnect();
                    }
                    self._readMessage();
                });
            };
            
            Peer.prototype._onError = function (e) {
                this.emit('error', e);
                if (this.status !== Peer.STATUS.DISCONNECTED) {
                    this.disconnect();
                }
            };
            
            /**
 * Disconnects the remote connection.
 * @returns {Peer} The same peer instance.
 */
Peer.prototype.disconnect = function () {
                this.status = Peer.STATUS.DISCONNECTED;
                this.socket.destroy();
                this.emit('disconnect');
                return this;
            };
            
            /**
 * Send a Message to the remote peer.
 * @param {Message} message - A message instance
 */
Peer.prototype.sendMessage = function (message) {
                this.socket.write(message.toBuffer());
            };
            
            /**
 * Internal function that sends VERSION message to the remote peer.
 */
Peer.prototype._sendVersion = function () {
                // todo: include sending local ip address
                var message = this.messages.Version({ relay: this.relay });
                this.versionSent = true;
                this.sendMessage(message);
            };
            
            /**
 * Send a PONG message to the remote peer.
 */
Peer.prototype._sendPong = function (nonce) {
                var message = this.messages.Pong(nonce);
                this.sendMessage(message);
            };
            
            /**
 * Internal function that tries to read a message from the data buffer
 */
Peer.prototype._readMessage = function () {
                var message = this.messages.parseBuffer(this.dataBuffer);
                if (message) {
                    this.emit(message.command, message);
                    this._readMessage();
                }
            };
            
            /**
 * Internal function that creates a socket using a proxy if necessary.
 * @returns {Socket} A Socket instance not yet connected.
 */
Peer.prototype._getSocket = function () {
                if (this.proxy) {
                    return new Socks5Client(this.proxy.host, this.proxy.port);
                }
                
                return new Net.Socket();
            };
            
            module.exports = Peer;

        }, { "./buffers": 17, "./messages": 42, "bitcore": "bitcore", "events": 317, "net": 169, "socks5-client": 51, "util": 342 }], 46: [function (require, module, exports) {
            (function (Buffer) {
                'use strict';
                
                var dns = require('dns');
                var EventEmitter = require('events').EventEmitter;
                var bitcore = require('bitcore');
                var sha256 = bitcore.crypto.Hash.sha256;
                var Peer = require('./peer');
                var Networks = bitcore.Networks;
                var util = require('util');
                var net = require('net');
                
                function now() {
                    return Math.floor(new Date().getTime() / 1000);
                }
                
                /**
 * A pool is a collection of Peers. A pool will discover peers from DNS seeds, and
 * collect information about new peers in the network. When a peer disconnects the pool
 * will connect to others that are available to maintain a max number of
 * ongoing peer connections. Peer events are relayed to the pool.
 *
 * @example
 * ```javascript
 *
 * var pool = new Pool({network: Networks.livenet});
 * pool.on('peerinv', function(peer, message) {
 *   // do something with the inventory announcement
 * });
 * pool.connect();
 * ```
 *
 * @param {Object=} options
 * @param {Network=} options.network - The network configuration
 * @param {Boolean=} options.listenAddr - Prevent new peers being added from addr messages
 * @param {Boolean=} options.dnsSeed - Prevent seeding with DNS discovered known peers
 * @param {Boolean=} options.relay - Prevent inventory announcements until a filter is loaded
 * @param {Number=} options.maxSize - The max number of peers
 * @returns {Pool}
 * @constructor
 */
function Pool(options) {
                    /* jshint maxcomplexity: 10 */
                    /* jshint maxstatements: 20 */
                    
                    var self = this;
                    
                    options = options || {};
                    this.keepalive = false;
                    
                    this._connectedPeers = {};
                    this._addrs = [];
                    
                    this.listenAddr = options.listenAddr !== false;
                    this.dnsSeed = options.dnsSeed !== false;
                    this.maxSize = options.maxSize || Pool.MaxConnectedPeers;
                    this.messages = options.messages;
                    this.network = Networks.get(options.network) || Networks.defaultNetwork;
                    this.relay = options.relay === false ? false : true;
                    
                    if (options.addrs) {
                        for (var i = 0; i < options.addrs.length; i++) {
                            this._addAddr(options.addrs[i]);
                        }
                    }
                    
                    if (this.listenAddr) {
                        this.on('peeraddr', function peerAddrEvent(peer, message) {
                            var addrs = message.addresses;
                            var length = addrs.length;
                            for (var i = 0; i < length; i++) {
                                var addr = addrs[i];
                                var future = new Date().getTime() + (10 * 60 * 1000);
                                if (addr.time.getTime() <= 100000000000 || addr.time.getTime() > future) {
                                    // In case of an invalid time, assume "5 days ago"
                                    var past = new Date(new Date().getTime() - 5 * 24 * 60 * 60 * 1000);
                                    addr.time = past;
                                }
                                this._addAddr(addr);
                            }
                        });
                    }
                    
                    this.on('seed', function seedEvent(ips) {
                        ips.forEach(function (ip) {
                            self._addAddr({
                                ip: {
                                    v4: ip
                                }
                            });
                        });
                        if (self.keepalive) {
                            self._fillConnections();
                        }
                    });
                    
                    this.on('peerdisconnect', function peerDisconnectEvent(peer, addr) {
                        self._deprioritizeAddr(addr);
                        self._removeConnectedPeer(addr);
                        if (self.keepalive) {
                            self._fillConnections();
                        }
                    });
                    
                    return this;

                }
                
                util.inherits(Pool, EventEmitter);
                
                Pool.MaxConnectedPeers = 8;
                Pool.RetrySeconds = 30;
                Pool.PeerEvents = ['version', 'inv', 'getdata', 'ping', 'pong', 'addr',
  'getaddr', 'verack', 'reject', 'alert', 'headers', 'block', 'merkleblock',
  'tx', 'getblocks', 'getheaders', 'error', 'filterload', 'filteradd',
  'filterclear'
                ];
                
                /**
 * Will initiatiate connection to peers, if available peers have been added to
 * the pool, it will connect to those, otherwise will use DNS seeds to find
 * peers to connect. When a peer disconnects it will add another.
 */
Pool.prototype.connect = function connect() {
                    this.keepalive = true;
                    var self = this;
                    if (this.dnsSeed) {
                        self._addAddrsFromSeeds();
                    } else {
                        self._fillConnections();
                    }
                    return this;
                };
                
                /**
 * Will disconnect all peers that are connected.
 */
Pool.prototype.disconnect = function disconnect() {
                    this.keepalive = false;
                    for (var i in this._connectedPeers) {
                        this._connectedPeers[i].disconnect();
                    }
                    return this;
                };
                
                /**
 * @returns {Number} The number of peers currently connected.
 */
Pool.prototype.numberConnected = function numberConnected() {
                    return Object.keys(this._connectedPeers).length;
                };
                
                /**
 * Will fill the conneted peers to the maximum amount.
 */
Pool.prototype._fillConnections = function _fillConnections() {
                    var length = this._addrs.length;
                    for (var i = 0; i < length; i++) {
                        if (this.numberConnected() >= this.maxSize) {
                            break;
                        }
                        var addr = this._addrs[i];
                        if (!addr.retryTime || now() > addr.retryTime) {
                            this._connectPeer(addr);
                        }
                    }
                    return this;
                };
                
                /**
 * Will remove a peer from the list of connected peers.
 * @param {Object} addr - An addr from the list of addrs
 */
Pool.prototype._removeConnectedPeer = function _removeConnectedPeer(addr) {
                    if (this._connectedPeers[addr.hash].status !== Peer.STATUS.DISCONNECTED) {
                        this._connectedPeers[addr.hash].disconnect();
                    } else {
                        delete this._connectedPeers[addr.hash];
                    }
                    return this;
                };
                
                /**
 * Will connect a peer and add to the list of connected peers.
 * @param {Object} addr - An addr from the list of addrs
 */
Pool.prototype._connectPeer = function _connectPeer(addr) {
                    var self = this;
                    
                    if (!this._connectedPeers[addr.hash]) {
                        var port = addr.port || self.network.port;
                        var ip = addr.ip.v4 || addr.ip.v6;
                        var peer = new Peer({
                            host: ip,
                            port: port,
                            messages: self.messages,
                            network: this.network,
                            relay: self.relay
                        });
                        
                        peer.on('connect', function peerConnect() {
                            self.emit('peerconnect', peer, addr);
                        });
                        
                        self._addPeerEventHandlers(peer, addr);
                        peer.connect();
                        self._connectedPeers[addr.hash] = peer;
                    }
                    
                    return this;
                };
                
                /**
 * Adds a peer with a connected socket to the _connectedPeers object, and
 * intializes the associated event handlers.
 * @param {Socket} - socket - A new connected socket
 * @param {Object} - addr - The associated addr object for the peer
 */
Pool.prototype._addConnectedPeer = function _addConnectedPeer(socket, addr) {
                    var self = this;
                    
                    if (!this._connectedPeers[addr.hash]) {
                        var peer = new Peer({
                            socket: socket,
                            network: this.network,
                            messages: self.messages
                        });
                        
                        self._addPeerEventHandlers(peer, addr);
                        self._connectedPeers[addr.hash] = peer;
                        self.emit('peerconnect', peer, addr);
                    }
                    
                    return this;
                };
                
                /**
 * Will add disconnect and ready events for a peer and intialize
 * handlers for relay peer message events.
 */
Pool.prototype._addPeerEventHandlers = function (peer, addr) {
                    var self = this;
                    
                    peer.on('disconnect', function peerDisconnect() {
                        self.emit('peerdisconnect', peer, addr);
                    });
                    peer.on('ready', function peerReady() {
                        self.emit('peerready', peer, addr);
                    });
                    Pool.PeerEvents.forEach(function addPeerEvents(event) {
                        peer.on(event, function peerEvent(message) {
                            self.emit('peer' + event, peer, message);
                        });
                    });
                };
                
                /**
 * Will deprioritize an addr in the list of addrs by moving it to the end
 * of the array, and setting a retryTime
 * @param {Object} addr - An addr from the list of addrs
 */
Pool.prototype._deprioritizeAddr = function _deprioritizeAddr(addr) {
                    for (var i = 0; i < this._addrs.length; i++) {
                        if (this._addrs[i].hash === addr.hash) {
                            var middle = this._addrs[i];
                            middle.retryTime = now() + Pool.RetrySeconds;
                            var beginning = this._addrs.splice(0, i);
                            var end = this._addrs.splice(i + 1, this._addrs.length);
                            var combined = beginning.concat(end);
                            this._addrs = combined.concat([middle]);
                        }
                    }
                    return this;
                };
                
                /**
 * Will add an addr to the beginning of the addrs array
 * @param {Object}
 */
Pool.prototype._addAddr = function _addAddr(addr) {
                    // Use default port if not specified
                    addr.port = addr.port || this.network.port;
                    
                    // make a unique key
                    addr.hash = sha256(new Buffer(addr.ip.v6 + addr.ip.v4 + addr.port)).toString('hex');
                    
                    var length = this._addrs.length;
                    var exists = false;
                    for (var i = 0; i < length; i++) {
                        if (this._addrs[i].hash === addr.hash) {
                            exists = true;
                        }
                    }
                    if (!exists) {
                        this._addrs.unshift(addr);
                    }
                    return addr;
                };
                
                /**
 * Will add addrs to the list of addrs from a DNS seed
 * @param {String} seed - A domain name to resolve known peers
 * @param {Function} done
 */
Pool.prototype._addAddrsFromSeed = function _addAddrsFromSeed(seed) {
                    var self = this;
                    dns.resolve(seed, function (err, ips) {
                        if (err) {
                            self.emit('seederror', err);
                            return;
                        }
                        if (!ips || !ips.length) {
                            self.emit('seederror', new Error('No IPs found from seed lookup.'));
                            return;
                        }
                        // announce to pool
                        self.emit('seed', ips);
                    });
                    return this;
                };
                
                /**
 * Will add addrs to the list of addrs from network DNS seeds
 * @param {Function} done
 */
Pool.prototype._addAddrsFromSeeds = function _addAddrsFromSeeds() {
                    var self = this;
                    var seeds = this.network.dnsSeeds;
                    seeds.forEach(function (seed) {
                        self._addAddrsFromSeed(seed);
                    });
                    return this;
                };
                
                /**
 * @returns {String} A string formatted for the console
 */
Pool.prototype.inspect = function inspect() {
                    return '<Pool network: ' +
    this.network + ', connected: ' +
    this.numberConnected() + ', available: ' +
    this._addrs.length + '>';
                };
                
                /**
 * Will send a message to all of the peers in the pool.
 * @param {Message} message - An instance of the message to send
 */
Pool.prototype.sendMessage = function (message) {
                    // broadcast to peers
                    for (var key in this._connectedPeers) {
                        var peer = this._connectedPeers[key];
                        peer.sendMessage(message);
                    }
                };
                
                /**
 * Will enable a listener for peer connections, when a peer connects
 * it will be added to the pool.
 */
Pool.prototype.listen = function () {
                    var self = this;
                    
                    // Create server
                    this.server = net.createServer(function (socket) {
                        var addr = {
                            ip: {}
                        };
                        if (net.isIPv6(socket.remoteAddress)) {
                            addr.ip.v6 = socket.remoteAddress;
                        } else {
                            addr.ip.v4 = socket.remoteAddress;
                        }
                        addr.port = socket.remotePort;
                        
                        addr = self._addAddr(addr);
                        self._addConnectedPeer(socket, addr);
                    });
                    this.server.listen(this.network.port);
                };
                
                module.exports = Pool;

            }).call(this, require("buffer").Buffer)
        }, { "./peer": 45, "bitcore": "bitcore", "buffer": 172, "dns": 169, "events": 317, "net": 169, "util": 342 }], 47: [function (require, module, exports) {
            'use strict';
            
            var MurmurHash3 = require('./murmurhash3');
            
            /**
 * A Bloom Filter implemented as for use in Bitcoin Connection Bloom Filtering (BIP37) that
 * uses version 3 of the 32-bit Murmur hash function.
 *
 * @see https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki
 * @see https://github.com/bitcoin/bitcoin/blob/master/src/bloom.cpp
 *
 * @param {Object} data - The data object used to initialize the filter.
 * @param {Array} data.vData - The data of the bloom filter.
 * @param {Number} data.nHashFuncs - The number of hash functions.
 * @param {Number} data.nTweak - A random value to seed the hash functions.
 * @param {Number} data.nFlag - A flag to determine how matched items are added to the filter.
 * @constructor
 */
function Filter(arg) {
                /* jshint maxcomplexity: 10 */
                if (typeof (arg) === 'object') {
                    if (!arg.vData) {
                        throw new TypeError('Data object should include filter data "vData"');
                    }
                    if (arg.vData.length > Filter.MAX_BLOOM_FILTER_SIZE * 8) {
                        throw new TypeError('"vData" exceeded max size "' + Filter.MAX_BLOOM_FILTER_SIZE + '"');
                    }
                    this.vData = arg.vData;
                    if (!arg.nHashFuncs) {
                        throw new TypeError('Data object should include number of hash functions "nHashFuncs"');
                    }
                    if (arg.nHashFuncs > Filter.MAX_HASH_FUNCS) {
                        throw new TypeError('"nHashFuncs" exceeded max size "' + Filter.MAX_HASH_FUNCS + '"');
                    }
                    this.nHashFuncs = arg.nHashFuncs;
                    this.nTweak = arg.nTweak || 0;
                    this.nFlags = arg.nFlags || Filter.BLOOM_UPDATE_NONE;
                } else {
                    throw new TypeError('Unrecognized argument');
                }
            }
            
            Filter.prototype.toObject = function toObject() {
                return {
                    vData: this.vData,
                    nHashFuncs: this.nHashFuncs,
                    nTweak: this.nTweak,
                    nFlags: this.nFlags
                };
            };
            
            Filter.create = function create(elements, falsePositiveRate, nTweak, nFlags) {
                /* jshint maxstatements: 18 */
                
                var info = {};
                
                // The ideal size for a bloom filter with a given number of elements and false positive rate is:
                // * - nElements * log(fp rate) / ln(2)^2
                // See: https://github.com/bitcoin/bitcoin/blob/master/src/bloom.cpp
                var size = -1.0 / Filter.LN2SQUARED * elements * Math.log(falsePositiveRate);
                var filterSize = Math.floor(size / 8);
                var max = Filter.MAX_BLOOM_FILTER_SIZE * 8;
                if (filterSize > max) {
                    filterSize = max;
                }
                info.vData = [];
                for (var i = 0; i < filterSize; i++) {
                    info.vData.push(0);
                }
                
                // The ideal number of hash functions is:
                // filter size * ln(2) / number of elements
                // See: https://github.com/bitcoin/bitcoin/blob/master/src/bloom.cpp
                var nHashFuncs = Math.floor(info.vData.length * 8 / elements * Filter.LN2);
                if (nHashFuncs > Filter.MAX_HASH_FUNCS) {
                    nHashFuncs = Filter.MAX_HASH_FUNCS;
                }
                if (nHashFuncs < Filter.MIN_HASH_FUNCS) {
                    nHashFuncs = Filter.MIN_HASH_FUNCS;
                }
                
                info.nHashFuncs = nHashFuncs;
                info.nTweak = nTweak;
                info.nFlags = nFlags;
                
                return new Filter(info);

            };
            
            Filter.prototype.hash = function hash(nHashNum, vDataToHash) {
                var h = MurmurHash3(((nHashNum * 0xFBA4C795) + this.nTweak) & 0xFFFFFFFF, vDataToHash);
                return h % (this.vData.length * 8);
            };
            
            Filter.prototype.insert = function insert(data) {
                for (var i = 0; i < this.nHashFuncs; i++) {
                    var index = this.hash(i, data);
                    var position = (1 << (7 & index));
                    this.vData[index >> 3] |= position;
                }
                return this;
            };
            
            /**
 * @param {Buffer} Data to check if exists in the filter
 * @returns {Boolean} If the data matches
 */
Filter.prototype.contains = function contains(data) {
                if (!this.vData.length) {
                    return false;
                }
                for (var i = 0; i < this.nHashFuncs; i++) {
                    var index = this.hash(i, data);
                    if (!(this.vData[index >> 3] & (1 << (7 & index)))) {
                        return false;
                    }
                }
                return true;
            };
            
            Filter.prototype.clear = function clear() {
                this.vData = [];
            };
            
            Filter.prototype.inspect = function inspect() {
                return '<BloomFilter:' +
    this.vData + ' nHashFuncs:' +
    this.nHashFuncs + ' nTweak:' +
    this.nTweak + ' nFlags:' +
    this.nFlags + '>';
            };
            
            Filter.BLOOM_UPDATE_NONE = 0;
            Filter.BLOOM_UPDATE_ALL = 1;
            Filter.BLOOM_UPDATE_P2PUBKEY_ONLY = 2;
            Filter.MAX_BLOOM_FILTER_SIZE = 36000; // bytes
            Filter.MAX_HASH_FUNCS = 50;
            Filter.MIN_HASH_FUNCS = 1;
            Filter.LN2SQUARED = Math.pow(Math.log(2), 2); // 0.4804530139182014246671025263266649717305529515945455
            Filter.LN2 = Math.log(2); // 0.6931471805599453094172321214581765680755001343602552
            
            module.exports = Filter;

        }, { "./murmurhash3": 49 }], 48: [function (require, module, exports) {
            'use strict';
            
            module.exports = {};
            module.exports = require('./filter');
            module.exports.MurmurHash3 = require('./murmurhash3');

        }, { "./filter": 47, "./murmurhash3": 49 }], 49: [function (require, module, exports) {
            'use strict';
            
            /**
 * MurmurHash is a non-cryptographic hash function suitable for general hash-based lookup
 *
 * @see https://en.wikipedia.org/wiki/MurmurHash
 * @see https://github.com/petertodd/python-bitcoinlib/blob/master/bitcoin/bloom.py
 * @see https://github.com/bitcoinj/bitcoinj/blob/master/core/src/main/java/org/bitcoinj/core/BloomFilter.java#L170
 * @see https://github.com/bitcoin/bitcoin/blob/master/src/hash.cpp
 * @see https://github.com/indutny/bcoin/blob/master/lib/bcoin/bloom.js
 * @see https://github.com/garycourt/murmurhash-js
 *
 * @param {Buffer} data to be hashed
 * @param {Number} seed Positive integer only
 * @return {Number} a 32-bit positive integer hash
*/
function MurmurHash3(seed, data) {
                /* jshint maxstatements: 32, maxcomplexity: 10 */
                
                var c1 = 0xcc9e2d51;
                var c2 = 0x1b873593;
                var r1 = 15;
                var r2 = 13;
                var m = 5;
                var n = 0x6b64e654;
                
                var hash = seed;
                
                function mul32(a, b) {
                    return (a & 0xffff) * b + (((a >>> 16) * b & 0xffff) << 16) & 0xffffffff;
                }
                
                function sum32(a, b) {
                    return (a & 0xffff) + (b >>> 16) + (((a >>> 16) + b & 0xffff) << 16) & 0xffffffff;
                }
                
                function rotl32(a, b) {
                    return (a << b) | (a >>> (32 - b));
                }
                
                var k1;
                
                for (var i = 0; i + 4 <= data.length; i += 4) {
                    k1 = data[i] |
      (data[i + 1] << 8) |
      (data[i + 2] << 16) |
      (data[i + 3] << 24);
                    
                    k1 = mul32(k1, c1);
                    k1 = rotl32(k1, r1);
                    k1 = mul32(k1, c2);
                    
                    hash ^= k1;
                    hash = rotl32(hash, r2);
                    hash = mul32(hash, m);
                    hash = sum32(hash, n);
                }
                
                k1 = 0;
                
                switch (data.length & 3) {
                    case 3:
                        k1 ^= data[i + 2] << 16;
      /* falls through */
                    case 2:
                        k1 ^= data[i + 1] << 8;
      /* falls through */
                    case 1:
                        k1 ^= data[i];
                        k1 = mul32(k1, c1);
                        k1 = rotl32(k1, r1);
                        k1 = mul32(k1, c2);
                        hash ^= k1;
                }
                
                hash ^= data.length;
                hash ^= hash >>> 16;
                hash = mul32(hash, 0x85ebca6b);
                hash ^= hash >>> 13;
                hash = mul32(hash, 0xc2b2ae35);
                hash ^= hash >>> 16;
                
                return hash >>> 0;
            }
            
            module.exports = MurmurHash3;

        }, {}], 50: [function (require, module, exports) {
            (function (Buffer) {
                module.exports = Buffers;
                
                function Buffers(bufs) {
                    if (!(this instanceof Buffers)) return new Buffers(bufs);
                    this.buffers = bufs || [];
                    this.length = this.buffers.reduce(function (size, buf) {
                        return size + buf.length
                    }, 0);
                }
                
                Buffers.prototype.push = function () {
                    for (var i = 0; i < arguments.length; i++) {
                        if (!Buffer.isBuffer(arguments[i])) {
                            throw new TypeError('Tried to push a non-buffer');
                        }
                    }
                    
                    for (var i = 0; i < arguments.length; i++) {
                        var buf = arguments[i];
                        this.buffers.push(buf);
                        this.length += buf.length;
                    }
                    return this.length;
                };
                
                Buffers.prototype.unshift = function () {
                    for (var i = 0; i < arguments.length; i++) {
                        if (!Buffer.isBuffer(arguments[i])) {
                            throw new TypeError('Tried to unshift a non-buffer');
                        }
                    }
                    
                    for (var i = 0; i < arguments.length; i++) {
                        var buf = arguments[i];
                        this.buffers.unshift(buf);
                        this.length += buf.length;
                    }
                    return this.length;
                };
                
                Buffers.prototype.copy = function (dst, dStart, start, end) {
                    return this.slice(start, end).copy(dst, dStart, 0, end - start);
                };
                
                Buffers.prototype.splice = function (i, howMany) {
                    var buffers = this.buffers;
                    var index = i >= 0 ? i : this.length - i;
                    var reps = [].slice.call(arguments, 2);
                    
                    if (howMany === undefined) {
                        howMany = this.length - index;
                    }
                    else if (howMany > this.length - index) {
                        howMany = this.length - index;
                    }
                    
                    for (var i = 0; i < reps.length; i++) {
                        this.length += reps[i].length;
                    }
                    
                    var removed = new Buffers();
                    var bytes = 0;
                    
                    var startBytes = 0;
                    for (
        var ii = 0;
        ii < buffers.length && startBytes + buffers[ii].length < index;
        ii++
    ) { startBytes += buffers[ii].length }
                    
                    if (index - startBytes > 0) {
                        var start = index - startBytes;
                        
                        if (start + howMany < buffers[ii].length) {
                            removed.push(buffers[ii].slice(start, start + howMany));
                            
                            var orig = buffers[ii];
                            //var buf = new Buffer(orig.length - howMany);
                            var buf0 = new Buffer(start);
                            for (var i = 0; i < start; i++) {
                                buf0[i] = orig[i];
                            }
                            
                            var buf1 = new Buffer(orig.length - start - howMany);
                            for (var i = start + howMany; i < orig.length; i++) {
                                buf1[ i - howMany - start ] = orig[i]
                            }
                            
                            if (reps.length > 0) {
                                var reps_ = reps.slice();
                                reps_.unshift(buf0);
                                reps_.push(buf1);
                                buffers.splice.apply(buffers, [ii, 1].concat(reps_));
                                ii += reps_.length;
                                reps = [];
                            }
                            else {
                                buffers.splice(ii, 1, buf0, buf1);
                                //buffers[ii] = buf;
                                ii += 2;
                            }
                        }
                        else {
                            removed.push(buffers[ii].slice(start));
                            buffers[ii] = buffers[ii].slice(0, start);
                            ii++;
                        }
                    }
                    
                    if (reps.length > 0) {
                        buffers.splice.apply(buffers, [ii, 0].concat(reps));
                        ii += reps.length;
                    }
                    
                    while (removed.length < howMany) {
                        var buf = buffers[ii];
                        var len = buf.length;
                        var take = Math.min(len, howMany - removed.length);
                        
                        if (take === len) {
                            removed.push(buf);
                            buffers.splice(ii, 1);
                        }
                        else {
                            removed.push(buf.slice(0, take));
                            buffers[ii] = buffers[ii].slice(take);
                        }
                    }
                    
                    this.length -= removed.length;
                    
                    return removed;
                };
                
                Buffers.prototype.slice = function (i, j) {
                    var buffers = this.buffers;
                    if (j === undefined) j = this.length;
                    if (i === undefined) i = 0;
                    
                    if (j > this.length) j = this.length;
                    
                    var startBytes = 0;
                    for (
        var si = 0;
        si < buffers.length && startBytes + buffers[si].length <= i;
        si++
    ) { startBytes += buffers[si].length }
                    
                    var target = new Buffer(j - i);
                    
                    var ti = 0;
                    for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
                        var len = buffers[ii].length;
                        
                        var start = ti === 0 ? i - startBytes : 0;
                        var end = ti + len >= j - i
            ? Math.min(start + (j - i) - ti, len)
            : len
        ;
                        
                        buffers[ii].copy(target, ti, start, end);
                        ti += end - start;
                    }
                    
                    return target;
                };
                
                Buffers.prototype.pos = function (i) {
                    if (i < 0 || i >= this.length) throw new Error('oob');
                    var l = i, bi = 0, bu = null;
                    for (;;) {
                        bu = this.buffers[bi];
                        if (l < bu.length) {
                            return { buf: bi, offset: l };
                        } else {
                            l -= bu.length;
                        }
                        bi++;
                    }
                };
                
                Buffers.prototype.get = function get(i) {
                    var pos = this.pos(i);
                    
                    return this.buffers[pos.buf].get(pos.offset);
                };
                
                Buffers.prototype.set = function set(i, b) {
                    var pos = this.pos(i);
                    
                    return this.buffers[pos.buf].set(pos.offset, b);
                };
                
                Buffers.prototype.indexOf = function (needle, offset) {
                    if ("string" === typeof needle) {
                        needle = new Buffer(needle);
                    } else if (needle instanceof Buffer) {
        // already a buffer
                    } else {
                        throw new Error('Invalid type for a search string');
                    }
                    
                    if (!needle.length) {
                        return 0;
                    }
                    
                    if (!this.length) {
                        return -1;
                    }
                    
                    var i = 0, j = 0, match = 0, mstart, pos = 0;
                    
                    // start search from a particular point in the virtual buffer
                    if (offset) {
                        var p = this.pos(offset);
                        i = p.buf;
                        j = p.offset;
                        pos = offset;
                    }
                    
                    // for each character in virtual buffer
                    for (;;) {
                        while (j >= this.buffers[i].length) {
                            j = 0;
                            i++;
                            
                            if (i >= this.buffers.length) {
                                // search string not found
                                return -1;
                            }
                        }
                        
                        var char = this.buffers[i][j];
                        
                        if (char == needle[match]) {
                            // keep track where match started
                            if (match == 0) {
                                mstart = {
                                    i: i,
                                    j: j,
                                    pos: pos
                                };
                            }
                            match++;
                            if (match == needle.length) {
                                // full match
                                return mstart.pos;
                            }
                        } else if (match != 0) {
                            // a partial match ended, go back to match starting position
                            // this will continue the search at the next character
                            i = mstart.i;
                            j = mstart.j;
                            pos = mstart.pos;
                            match = 0;
                        }
                        
                        j++;
                        pos++;
                    }
                };
                
                Buffers.prototype.toBuffer = function () {
                    return this.slice();
                }
                
                Buffers.prototype.toString = function (encoding, start, end) {
                    return this.slice(start, end).toString(encoding);
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 51: [function (require, module, exports) {
            (function (Buffer) {
                /**
 * @author Matthew Caruana Galizia <m@m.cg>
 * @license MIT
 * @copyright Copyright (c) 2013, Matthew Caruana Galizia
 * @preserve
 *
 * Portions of this code are copyright (c) 2011 Valentin HÃ¡loiu, redistributed and modified under the following license (MIT).
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

'use strict';
                
                /*jshint node:true*/
                
                var net = require('net');
                var EventEmitter = require('events').EventEmitter;
                var inherits = require('util').inherits;
                
                var htons = require('network-byte-order').htons;
                var ipv6 = require('ipv6').v6;
                
                module.exports = exports = Socks5ClientSocket;
                
                exports.createConnection = function (options) {
                    var socksSocket, socksHost, socksPort;
                    
                    socksHost = options.socksHost || 'localhost';
                    socksPort = options.socksPort || 1080;
                    socksSocket = new Socks5ClientSocket(socksHost, socksPort);
                    
                    return socksSocket.connect(options.port, options.host);
                };
                
                function Socks5ClientSocket(socksHost, socksPort) {
                    var self = this;
                    
                    EventEmitter.call(self);
                    
                    self.socket = new net.Socket();
                    self.socksHost = socksHost;
                    self.socksPort = socksPort;
                    
                    self.socket.on('error', function (err) {
                        self.emit('error', err);
                    });
                    
                    self.on('error', function (err) {
                        if (!self.socket.destroyed) {
                            self.socket.destroy();
                        }
                    });
                }
                
                inherits(Socks5ClientSocket, EventEmitter);
                
                Socks5ClientSocket.prototype.setTimeout = function (msecs, callback) {
                    return this.socket.setTimeout(msecs, callback);
                };
                
                Socks5ClientSocket.prototype.setNoDelay = function () {
                    return this.socket.setNoDelay();
                };
                
                Socks5ClientSocket.prototype.setKeepAlive = function (setting, msecs) {
                    return this.socket.setKeepAlive(setting, msecs);
                };
                
                Socks5ClientSocket.prototype.address = function () {
                    return this.socket.address();
                };
                
                Socks5ClientSocket.prototype.pause = function () {
                    return this.socket.pause();
                };
                
                Socks5ClientSocket.prototype.resume = function () {
                    return this.socket.resume();
                };
                
                Socks5ClientSocket.prototype.end = function (data, encoding) {
                    return this.socket.end(data, encoding);
                };
                
                Socks5ClientSocket.prototype.destroy = function (exception) {
                    return this.socket.destroy(exception);
                };
                
                Socks5ClientSocket.prototype.destroySoon = function () {
                    var ret = this.socket.destroySoon();
                    
                    this.writable = false; // node's http library asserts writable to be false after destroySoon
                    
                    return ret;
                };
                
                Socks5ClientSocket.prototype.setEncoding = function (encoding) {
                    return this.socket.setEncoding(encoding);
                };
                
                Socks5ClientSocket.prototype.write = function (data, arg1, arg2) {
                    return this.socket.write(data, arg1, arg2);
                };
                
                Socks5ClientSocket.prototype.connect = function (port, host) {
                    var self = this;
                    
                    self.socket.connect(self.socksPort, self.socksHost, function () {
                        self.establishSocksConnection(host, port);
                    });
                    
                    return self;
                };
                
                Socks5ClientSocket.prototype.handleSocksConnectToHost = function () {
                    var self = this;
                    
                    self.socket.on('close', function (hadError) {
                        self.emit('close', hadError);
                    });
                    
                    self.socket.on('end', function () {
                        self.emit('end');
                    });
                    
                    self.socket.on('data', function (data) {
                        self.emit('data', data);
                    });
                    
                    self.socket._httpMessage = self._httpMessage;
                    self.socket.parser = self.parser;
                    self.socket.ondata = self.ondata;
                    self.writable = true;
                    self.readable = true;
                    self.emit('connect');
                };
                
                Socks5ClientSocket.prototype.establishSocksConnection = function (host, port) {
                    var self = this;
                    
                    self.authenticateWithSocks(function () {
                        self.connectSocksToHost(host, port, function () {
                            self.handleSocksConnectToHost();
                        });
                    });
                };
                
                Socks5ClientSocket.prototype.authenticateWithSocks = function (cb) {
                    var request, self = this;
                    
                    self.socket.ondata = function (d, start, end) {
                        var error;
                        
                        if (end - start !== 2) {
                            error = new Error('SOCKS authentication failed. Unexpected number of bytes received.');
                        } else if (d[start] !== 0x05) {
                            error = new Error('SOCKS authentication failed. Unexpected SOCKS version number: ' + d[start] + '.');
                        } else if (d[start + 1] !== 0x00) {
                            error = new Error('SOCKS authentication failed. Unexpected SOCKS authentication method: ' + d[start + 1] + '.');
                        }
                        
                        if (error) {
                            self.emit('error', error);
                            return;
                        }
                        
                        if (cb) {
                            cb();
                        }
                    };
                    
                    request = new Buffer(3);
                    request[0] = 0x05;  // SOCKS version
                    request[1] = 0x01;  // number of authentication methods
                    request[2] = 0x00;  // no authentication
                    self.socket.write(request);
                };
                
                Socks5ClientSocket.prototype.connectSocksToHost = function (host, port, cb) {
                    var buffer, request, self = this;
                    
                    this.socket.ondata = function (d, start, end) {
                        var i, address, addressLength, error;
                        
                        if (d[start] !== 0x05) {
                            error = new Error('SOCKS connection failed. Unexpected SOCKS version number: ' + d[start] + '.');
                        } else if (d[start + 1] !== 0x00) {
                            error = new Error('SOCKS connection failed. ' + getErrorMessage(d[start + 1]) + '.');
                        } else if (d[start + 2] !== 0x00) {
                            error = new Error('SOCKS connection failed. The reserved byte must be 0x00.');
                        }
                        
                        if (error) {
                            self.emit('error', error);
                            return;
                        }
                        
                        address = '';
                        addressLength = 0;
                        
                        switch (d[start + 3]) {
                            case 1:
                                address = d[start + 4] + '.' + d[start + 5] + '.' + d[start + 6] + '.' + d[start + 7];
                                addressLength = 4;
                                break;
                            case 3:
                                addressLength = d[start + 4] + 1;
                                for (i = start + 5; i < start + addressLength; i++) {
                                    address += String.fromCharCode(d[i]);
                                }
                                break;
                            case 4:
                                addressLength = 16;
                                break;
                            default:
                                self.emit('error', new Error('SOCKS connection failed. Unknown addres type: ' + d[start + 3] + '.'));
                                return;
                        }
                        
                        if (cb) {
                            cb();
                        }
                    };
                    
                    buffer = [];
                    buffer.push(0x05); // SOCKS version
                    buffer.push(0x01); // Command code: establish a TCP/IP stream connection
                    buffer.push(0x00); // Reserved - myst be 0x00
                    
                    switch (net.isIP(host)) {
                        case 0:
                            buffer.push(0x03);
                            parseDomainName(host, buffer);
                            break;
                        case 4:
                            buffer.push(0x01);
                            parseIPv4(host, buffer);
                            break;
                        case 6:
                            buffer.push(0x04);
                            if (parseIPv6(host, buffer) === false) {
                                self.emit('error', new Error('IPv6 host parsing failed. Invalid address.'));
                                return;
                            }
                            break;
                    }
                    
                    parsePort(port, buffer);
                    
                    request = new Buffer(buffer);
                    this.socket.write(request);
                };
                
                function parseIPv4(host, buffer) {
                    var i, ip, groups = host.split('.');
                    
                    for (i = 0; i < groups.length; i++) {
                        ip = parseInt(groups[i], 10);
                        buffer.push(ip);
                    }
                }
                
                function parseIPv6(host, buffer) {
                    var i, b1, b2, part1, part2, address, groups;
                    
                    address = new ipv6.Address(host).canonicalForm();
                    if (!address) {
                        return false;
                    }
                    
                    groups = address.split(':');
                    
                    for (i = 0; i < groups.length; i++) {
                        part1 = groups[i].substr(0, 2);
                        part2 = groups[i].substr(2, 2);
                        
                        b1 = parseInt(part1, 16);
                        b2 = parseInt(part2, 16);
                        
                        buffer.push(b1);
                        buffer.push(b2);
                    }
                    
                    return true;
                }
                
                function parseDomainName(host, buffer) {
                    var i, c;
                    
                    buffer.push(host.length);
                    for (i = 0; i < host.length; i++) {
                        c = host.charCodeAt(i);
                        buffer.push(c);
                    }
                }
                
                function parsePort(port, buffer) {
                    htons(buffer, buffer.length, port);
                }
                
                function getErrorMessage(code) {
                    switch (code) {
                        case 1:
                            return 'General SOCKS server failure';
                        case 2:
                            return 'Connection not allowed by ruleset';
                        case 3:
                            return 'Network unreachable';
                        case 4:
                            return 'Host unreachable';
                        case 5:
                            return 'Connection refused';
                        case 6:
                            return 'TTL expired';
                        case 7:
                            return 'Command not supported';
                        case 8:
                            return 'Address type not supported';
                        default:
                            return 'Unknown status code ' + code;
                    }
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172, "events": 317, "ipv6": 52, "net": 169, "network-byte-order": 56, "util": 342 }], 52: [function (require, module, exports) {
            exports = module.exports = require('./ipv6.js');
        }, { "./ipv6.js": 53 }], 53: [function (require, module, exports) {
            if (typeof exports !== 'undefined') {
                var sprintf = require('sprintf').sprintf;
                var BigInteger = require('./lib/node/bigint').BigInteger;
            }
            
            var v4 = this.v4 = {};
            var v6 = this.v6 = {};
            
            v4.GROUPS = 4;
            v6.GROUPS = 8;
            
            v4.BITS = 32;
            v6.BITS = 128;
            
            v6.SCOPES = {
                0: 'Reserved',
                1: 'Interface local',
                2: 'Link local',
                4: 'Admin local',
                5: 'Site local',
                8: 'Organization local',
                15: 'Global',
                16: 'Reserved'
            };
            
            v4.RE_ADDRESS = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
            v4.RE_SUBNET_STRING = /\/\d{1,2}$/;
            
            v6.RE_BAD_CHARACTERS = /([^0-9a-f:\/%])/ig;
            v6.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/ig;
            
            v6.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
            v6.RE_ZONE_STRING = /%.*$/;
            
            v6.RE_URL = new RegExp(/([0-9a-f:]+)/);
            v6.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
            
            // Convenience functions
            function map(array, fn) {
                var results = [];
                var i;
                
                for (i = 0; i < array.length; i++) {
                    results.push(fn(array[i], i));
                }
                
                return results;
            }
            
            function repeatString(s, n) {
                var result = '';
                var i;
                
                for (i = 0; i < n; i++) {
                    result += s;
                }
                
                return result;
            }
            
            function addCommas(number) {
                var r = /(\d+)(\d{3})/;
                
                while (r.test(number)) {
                    number = number.replace(r, '$1,$2');
                }
                
                return number;
            }
            
            function spanLeadingZeroesSimple(group) {
                return group.replace(/^(0+)/, '<span class="zero">$1</span>');
            }
            
            function spanLeadingZeroes4(n) {
                n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
                n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
                
                return n;
            }
            
            function simpleRegularExpression(addressArray) {
                var output = [];
                var i;
                
                for (i = 0; i < addressArray.length; i++) {
                    var segment = addressArray[i];
                    
                    if (segment.length < 4) {
                        output.push(sprintf('0{0,%d}%s', 4 - segment.length, segment));
                    } else {
                        output.push(segment);
                    }
                }
                
                return output.join(':');
            }
            
            function zeroPad(s, n) {
                return String(repeatString(0, n) + s).slice(n * -1);
            }
            
            function isInSubnet(address) {
                // XXX: This is a hunch
                if (this.subnetMask < address.subnetMask) {
                    return false;
                }
                
                if (this.mask(address.subnetMask) === address.mask()) {
                    return true;
                }
                
                return false;
            }
            
            /*
 * Instantiates an IPv4 address
 */
v4.Address = function (address) {
                this.valid = false;
                this.address = address;
                this.groups = v4.GROUPS;
                
                this.v4 = true;
                
                this.subnet = '/32';
                this.subnetMask = 32;
                
                var subnet = v4.RE_SUBNET_STRING.exec(address);
                
                if (subnet) {
                    this.parsedSubnet = subnet[0].replace('/', '');
                    this.subnetMask = parseInt(this.parsedSubnet, 10);
                    this.subnet = '/' + this.subnetMask;
                    
                    if (this.subnetMask < 0 || this.subnetMask > v4.BITS) {
                        this.valid = false;
                        this.error = "Invalid subnet mask.";
                        
                        return;
                    }
                    
                    address = address.replace(v4.RE_SUBNET_STRING, '');
                }
                
                this.addressMinusSuffix = address;
                
                this.parsedAddress = this.parse(address);
            };
            
            /*
 * Parses a v4 address
 */
v4.Address.prototype.parse = function (address) {
                var groups = address.split('.');
                
                if (address.match(v4.RE_ADDRESS)) {
                    this.valid = true;
                } else {
                    this.error = 'Invalid IPv4 address.';
                }
                
                return groups;
            };
            
            /*
 * Returns true if the address is valid
 */
v4.Address.prototype.isValid = function () {
                return this.valid;
            };
            
            /*
 * Returns the correct form of an address
 */
v4.Address.prototype.correctForm = function () {
                return this.parsedAddress.map(function (part) {
                    return parseInt(part, 10);
                }).join('.');
            };
            
            /*
 * Returns true if the address is correct, false otherwise
 */
v4.Address.prototype.isCorrect = function () {
                return this.addressMinusSuffix === this.correctForm() &&
    (this.subnetMask === 32 ||
      this.parsedSubnet === String(this.subnet.replace('/')));
            };
            
            /*
 * Converts a hex string to an IPv4 address object
 */
v4.Address.fromHex = function (hex) {
                var padded = zeroPad(hex.replace(/:/g, ''), 8);
                var groups = [];
                var i;
                
                for (i = 0; i < 8; i += 2) {
                    var h = padded.slice(i, i + 2);
                    
                    groups.push(parseInt(h, 16));
                }
                
                return new v4.Address(groups.join('.'));
            };
            
            /*
 * Converts an integer into a IPv4 address object
 */
v4.Address.fromInteger = function (integer) {
                return v4.Address.fromHex(integer.toString(16));
            };
            
            /*
 * Converts an IPv4 address object to a hex string
 */
v4.Address.prototype.toHex = function () {
                return this.parsedAddress.map(function (part) {
                    return sprintf('%02x', parseInt(part, 10));
                }).join(':');
            };
            
            /*
 * Converts an IPv4 address object to an array of bytes
 */
v4.Address.prototype.toArray = function () {
                return this.parsedAddress.map(function (part) {
                    return parseInt(part, 10);
                });
            };
            
            /*
 * Converts an IPv4 address object to an IPv6 address group
 */
v4.Address.prototype.toV6Group = function () {
                var output = [];
                var i;
                
                for (i = 0; i < v4.GROUPS; i += 2) {
                    var hex = sprintf('%02x%02x',
      parseInt(this.parsedAddress[i], 10),
      parseInt(this.parsedAddress[i + 1], 10));
                    
                    output.push(sprintf('%x', parseInt(hex, 16)));
                }
                
                return output.join(':');
            };
            
            /*
 * Returns the address as a BigInteger
 */
v4.Address.prototype.bigInteger = function () {
                if (!this.valid) {
                    return;
                }
                
                return new BigInteger(map(this.parsedAddress, function (n) {
                    return sprintf("%02x", parseInt(n, 10));
                }).join(''), 16);
            };
            
            /*
 * The first address in the range given by this address' subnet.
 * Often referred to as the Network Address.
 */
v4.Address.prototype.startAddress = function () {
                var startAddress = new BigInteger(this.mask() + repeatString(0,
    v4.BITS - this.subnetMask), 2);
                
                return v4.Address.fromBigInteger(startAddress);
            };
            
            /*
 * The last address in the range given by this address' subnet
 * Often referred to as the Broadcast
 */
v4.Address.prototype.endAddress = function () {
                var endAddress = new BigInteger(this.mask() + repeatString(1,
    v4.BITS - this.subnetMask), 2);
                
                return v4.Address.fromBigInteger(endAddress);
            };
            
            /*
 * Converts a BigInteger to a v4 address object
 */
v4.Address.fromBigInteger = function (bigInteger) {
                return v4.Address.fromInteger(parseInt(bigInteger.toString(), 10));
            };
            
            /*
 * Returns the first n bits of the address, defaulting to the
 * subnet mask
 */
v4.Address.prototype.mask = function (opt_mask) {
                if (opt_mask === undefined) {
                    opt_mask = this.subnetMask;
                }
                
                return this.getBitsBase2(0, opt_mask);
            };
            
            /*
 * Returns the bits in the given range as a base-2 string
 */
v4.Address.prototype.getBitsBase2 = function (start, end) {
                return this.binaryZeroPad().slice(start, end);
            };
            
            /*
 * Returns true if the given address is in the subnet of the current address
 */
v4.Address.prototype.isInSubnet = isInSubnet;
            
            /*
 * Returns a zero-padded base-2 string representation of the address
 */
v4.Address.prototype.binaryZeroPad = function () {
                return zeroPad(this.bigInteger().toString(2), v4.BITS);
            };
            
            /*
 * Instantiates an IPv6 address
 */
v6.Address = function (address, opt_groups) {
                if (opt_groups === undefined) {
                    this.groups = v6.GROUPS;
                } else {
                    this.groups = opt_groups;
                }
                
                this.v4 = false;
                
                this.subnet = '/128';
                this.subnetMask = 128;
                
                this.zone = '';
                
                this.address = address;
                
                var subnet = v6.RE_SUBNET_STRING.exec(address);
                
                if (subnet) {
                    this.parsedSubnet = subnet[0].replace('/', '');
                    this.subnetMask = parseInt(this.parsedSubnet, 10);
                    this.subnet = '/' + this.subnetMask;
                    
                    if (isNaN(this.subnetMask) ||
      this.subnetMask < 0 ||
      this.subnetMask > v6.BITS) {
                        this.valid = false;
                        this.error = "Invalid subnet mask.";
                        
                        return;
                    }
                    
                    address = address.replace(v6.RE_SUBNET_STRING, '');
                } else if (/\//.test(address)) {
                    this.valid = false;
                    this.error = "Invalid subnet mask.";
                    
                    return;
                }
                
                var zone = v6.RE_ZONE_STRING.exec(address);
                
                if (zone) {
                    this.zone = zone[0];
                    
                    address = address.replace(v6.RE_ZONE_STRING, '');
                }
                
                this.addressMinusSuffix = address;
                
                this.parsedAddress = this.parse(this.addressMinusSuffix);
            };
            
            /*
 * Converts a BigInteger to a v6 address object
 */
v6.Address.fromBigInteger = function (bigInteger) {
                var hex = zeroPad(bigInteger.toString(16), 32);
                var groups = [];
                var i;
                
                for (i = 0; i < 8; i++) {
                    groups.push(hex.slice(i * 4, (i + 1) * 4));
                }
                
                return new v6.Address(groups.join(':'));
            };
            
            /*
 * Converts a URL (optional port number) to an address object
 */
v6.Address.fromURL = function (url) {
                var host;
                var port;
                var result;
                
                // If we have brackets parse them and find a port
                if (url.indexOf('[') !== -1 && url.indexOf(']') !== -1) {
                    result = v6.RE_URL_WITH_PORT.exec(url);
                    
                    if (result === null) {
                        return {
                            error: 'failed to parse address with port',
                            address: null,
                            port: null
                        };
                    }
                    
                    host = result[1];
                    port = result[2];
  // If there's a URL extract the address
                } else if (url.indexOf('/') !== -1) {
                    // Remove the protocol prefix
                    url = url.replace(/^[a-z0-9]+:\/\//, '');
                    
                    // Parse the address
                    result = v6.RE_URL.exec(url);
                    
                    if (result === null) {
                        return {
                            error: 'failed to parse address from URL',
                            address: null,
                            port: null
                        };
                    }
                    
                    host = result[1];
  // Otherwise just assign the URL to the host and let the library parse it
                } else {
                    host = url;
                }
                
                // If there's a port convert it to an integer
                if (port) {
                    port = parseInt(port, 10);
                    
                    //squelch out of range ports
                    if (port < 0 || port > 65536) {
                        port = null;
                    }
                } else {
                    // Standardize `undefined` to `null`
                    port = null;
                }
                
                return {
                    address: new v6.Address(host),
                    port: port
                };
            };
            
            /*
 * A helper function to compact an array
 */
v6.Address.compact = function (address, slice) {
                var s1 = [];
                var s2 = [];
                var i;
                
                for (i = 0; i < address.length; i++) {
                    if (i < slice[0]) {
                        s1.push(address[i]);
                    } else if (i > slice[1]) {
                        s2.push(address[i]);
                    }
                }
                
                return s1.concat(['compact']).concat(s2);
            };
            
            /*
 * Returns true if the address is valid, false otherwise
 */
v6.Address.prototype.isValid = function () {
                return this.valid;
            };
            
            /*
 * Returns true if the address is correct, false otherwise
 */
v6.Address.prototype.isCorrect = function () {
                return this.addressMinusSuffix === this.correctForm() &&
    (this.subnetMask === 128 ||
      this.parsedSubnet === String(this.subnet.replace('/')));
            };
            
            /*
 * Returns true if the address is a link local address, false otherwise
 */
v6.Address.prototype.isLinkLocal = function () {
                // Zeroes are required, i.e. we can't check isInSubnet with 'fe80::/10'
                if (this.getBitsBase2(0, 64) ===
    "1111111010000000000000000000000000000000000000000000000000000000") {
                    return true;
                }
                
                return false;
            };
            
            /*
 * Returns true if the address is in the canonical form, false otherwise
 */
v6.Address.prototype.isCanonical = function () {
                return this.addressMinusSuffix === this.canonicalForm();
            };
            
            /*
 * Returns true if the address is a multicast address, false otherwise
 */
v6.Address.prototype.isMulticast = function () {
                return this.getType() === 'Multicast';
            };
            
            /*
 * Returns true if the address is a v4-in-v6 address, false otherwise
 */
v6.Address.prototype.is4 = function () {
                return this.v4;
            };
            
            /*
 * Returns true if the address is a Teredo address, false otherwise
 */
v6.Address.prototype.isTeredo = function () {
                if (this.isInSubnet(new v6.Address('2001::/32'))) {
                    return true;
                }
                
                return false;
            };
            
            /*
 * Returns true if the address is a 6to4 address, false otherwise
 */
v6.Address.prototype.is6to4 = function () {
                if (this.isInSubnet(new v6.Address('2002::/16'))) {
                    return true;
                }
                
                return false;
            };
            
            /*
 * Returns true if the address is a loopback address, false otherwise
 */
v6.Address.prototype.isLoopback = function () {
                return this.getType() === 'Loopback';
            };
            
            /*
 * Returns the Microsoft UNC transcription of the address
 */
v6.Address.prototype.microsoftTranscription = function () {
                return sprintf('%s.ipv6-literal.net',
    this.correctForm().replace(/:/g, '-'));
            };
            
            /*
 * Returns the address in link form with a default port of 80
 */
v6.Address.prototype.href = function (opt_port) {
                if (opt_port === undefined) {
                    opt_port = '';
                } else {
                    opt_port = sprintf(':%s', opt_port);
                }
                
                return sprintf('http://[%s]%s/', this.correctForm(), opt_port);
            };
            
            /*
 * Returns the first n bits of the address, defaulting to the
 * subnet mask
 */
v6.Address.prototype.mask = function (opt_mask) {
                if (opt_mask === undefined) {
                    opt_mask = this.subnetMask;
                }
                
                return this.getBitsBase2(0, opt_mask);
            };
            
            /*
 * Returns a link suitable for conveying the address via a URL hash
 */
v6.Address.prototype.link = function (options) {
                if (!options) {
                    options = {};
                }
                
                if (options.className === undefined) {
                    options.className = '';
                }
                
                if (options.prefix === undefined) {
                    options.prefix = '/#address=';
                }
                
                if (options.v4 === undefined) {
                    options.v4 = false;
                }
                
                var formFunction = this.correctForm;
                
                if (options.v4) {
                    formFunction = this.v4inv6;
                }
                
                if (options.className) {
                    return sprintf('<a href="%1$s%2$s" class="%3$s">%2$s</a>',
      options.prefix, formFunction.call(this), options.className);
                }
                
                return sprintf('<a href="%1$s%2$s">%2$s</a>', options.prefix,
    formFunction.call(this));
            };
            
            /*
 * Returns the number of possible subnets of a given size in the address
 */
v6.Address.prototype.possibleAddresses = function (opt_subnetSize) {
                if (opt_subnetSize === undefined) {
                    opt_subnetSize = 0;
                }
                
                return addCommas(new BigInteger('2', 10).pow((v6.BITS - this.subnetMask) -
    (v6.BITS - opt_subnetSize)).toString(10));
            };
            
            /*
 * Returns true if the given address is in the subnet of the current address
 */
v6.Address.prototype.isInSubnet = isInSubnet;
            
            /*
 * Create an IPv6-mapped address given an IPv4 address
 */
v6.Address.fromAddress4 = function (address4) {
                return new v6.Address('::ffff:' + address4);
            };
            
            /*
 * The first address in the range given by this address' subnet
 */
v6.Address.prototype.startAddress = function () {
                var startAddress = new BigInteger(this.mask() + repeatString(0,
    v6.BITS - this.subnetMask), 2);
                
                return v6.Address.fromBigInteger(startAddress);
            };
            
            /*
 * The last address in the range given by this address' subnet
 */
v6.Address.prototype.endAddress = function () {
                var endAddress = new BigInteger(this.mask() + repeatString(1,
    v6.BITS - this.subnetMask), 2);
                
                return v6.Address.fromBigInteger(endAddress);
            };
            
            /*
 * Returns the scope of the address
 */
v6.Address.prototype.getScope = function () {
                var scope = v6.SCOPES[this.getBits(12, 16)];
                
                if (this.getType() === "Global unicast") {
                    if (scope !== "Link local") {
                        scope = "Global";
                    }
                }
                
                return scope;
            };
            
            /*
 * Returns the type of the address
 */
v6.Address.prototype.getType = function () {
                // TODO: Refactor this
                // TODO: Add ff0x::fb, etc. for multicast DNS
                var TYPES = {
                    'ff01::1/128': 'Multicast (All nodes on this interface)',
                    'ff01::2/128': 'Multicast (All routers on this interface)',
                    'ff02::1/128': 'Multicast (All nodes on this link)',
                    'ff02::2/128': 'Multicast (All routers on this link)',
                    'ff05::2/128': 'Multicast (All routers in this site)',
                    'ff02::5/128': 'Multicast (OSPFv3 AllSPF routers)',
                    'ff02::6/128': 'Multicast (OSPFv3 AllDR routers)',
                    'ff02::9/128': 'Multicast (RIP routers)',
                    'ff02::a/128': 'Multicast (EIGRP routers)',
                    'ff02::d/128': 'Multicast (PIM routers)',
                    'ff02::16/128': 'Multicast (MLDv2 reports)',
                    'ff01::fb/128': 'Multicast (mDNSv6)',
                    'ff02::fb/128': 'Multicast (mDNSv6)',
                    'ff05::fb/128': 'Multicast (mDNSv6)',
                    'ff02::1:2/128': 'Multicast (All DHCP servers and relay agents on this link)',
                    'ff05::1:2/128': 'Multicast (All DHCP servers and relay agents in this site)',
                    'ff02::1:3/128': 'Multicast (All DHCP servers on this link)',
                    'ff05::1:3/128': 'Multicast (All DHCP servers in this site)',
                    '::/128': 'Unspecified',
                    '::1/128': 'Loopback',
                    'ff00::/8': 'Multicast',
                    'fe80::/10': 'Link-local unicast'
                };
                
                var type = 'Global unicast';
                var p;
                
                for (p in TYPES) {
                    if (TYPES.hasOwnProperty(p)) {
                        if (this.isInSubnet(new v6.Address(p))) {
                            type = TYPES[p];
                            
                            break;
                        }
                    }
                }
                
                return type;
            };
            
            /*
 * Returns the bits in the given range as a BigInteger
 */
v6.Address.prototype.getBits = function (start, end) {
                return new BigInteger(this.getBitsBase2(start, end), 2);
            };
            
            /*
 * Returns the bits in the given range as a base-2 string
 */
v6.Address.prototype.getBitsBase2 = function (start, end) {
                return this.binaryZeroPad().slice(start, end);
            };
            
            /*
 * Returns the bits in the given range as a base-16 string
 */
v6.Address.prototype.getBitsBase16 = function (start, end) {
                var length = end - start;
                
                if (length % 4 !== 0) {
                    return;
                }
                
                return zeroPad(this.getBits(start, end).toString(16), length / 4);
            };
            
            /*
 * Returns the bits that are set past the subnet mask length
 */
v6.Address.prototype.getBitsPastSubnet = function () {
                return this.getBitsBase2(this.subnetMask, v6.BITS);
            };
            
            /*
 * Returns the string with each character contained in a <span>
 */
v6.Address.spanAll = function (s, opt_offset) {
                if (opt_offset === undefined) {
                    opt_offset = 0;
                }
                
                var letters = s.split('');
                
                return map(letters, function (n, i) {
                    return sprintf('<span class="digit value-%s position-%d">%s</span>', n,
      i + opt_offset,
      v6.Address.spanAllZeroes(n)); // XXX Use #base-2 .value-0 instead?
                }).join('');
            };
            
            /*
 * Returns the string with all zeroes contained in a <span>
 */
v6.Address.spanAllZeroes = function (s) {
                return s.replace(/(0+)/g, '<span class="zero">$1</span>');
            };
            
            /*
 * Returns the string with leading zeroes contained in a <span>
 */
v6.Address.spanLeadingZeroes = function (address) {
                var groups = address.split(':');
                
                groups = map(groups, function (g) {
                    return spanLeadingZeroesSimple(g);
                });
                
                return groups.join(':');
            };
            
            /*
 * Groups an address
 */
v6.Address.simpleGroup = function (addressString, offset) {
                var groups = addressString.split(':');
                
                if (!offset) {
                    offset = 0;
                }
                
                groups = map(groups, function (g, i) {
                    if (/group-v4/.test(g)) {
                        return g;
                    }
                    
                    return sprintf('<span class="hover-group group-%d">%s</span>',
      i + offset,
      spanLeadingZeroesSimple(g));
                });
                
                return groups.join(':');
            };
            
            /*
 * Groups an address
 */
v6.Address.group = function (addressString) {
                var address6 = new v6.Address(addressString);
                var address4 = address6.address.match(v4.RE_ADDRESS);
                var i;
                
                if (address4) {
                    // The IPv4 case
                    var segments = address4[0].split('.');
                    
                    address6.address = address6.address.replace(v4.RE_ADDRESS,
      sprintf('<span class="hover-group group-v4 group-6">%s</span>' +
        '.' +
        '<span class="hover-group group-v4 group-7">%s</span>',
        segments.slice(0, 2).join('.'),
        segments.slice(2, 4).join('.')));
                }
                
                if (address6.elidedGroups === 0) {
                    // The simple case
                    return v6.Address.simpleGroup(address6.address);
                }
                
                // The elided case
                var output = [];
                
                var halves = address6.address.split('::');
                
                if (halves[0].length) {
                    output.push(v6.Address.simpleGroup(halves[0]));
                } else {
                    output.push('');
                }
                
                var classes = ['hover-group'];
                
                for (i = address6.elisionBegin; i < address6.elisionBegin +
    address6.elidedGroups; i++) {
                    classes.push(sprintf('group-%d', i));
                }
                
                output.push(sprintf('<span class="%s"></span>', classes.join(' ')));
                
                if (halves[1].length) {
                    output.push(v6.Address.simpleGroup(halves[1], address6.elisionEnd));
                } else {
                    output.push('');
                }
                
                return output.join(':');
            };
            
            /*
 * Returns the reversed ip6.arpa form of the address
 */
v6.Address.prototype.reverseForm = function () {
                var characters = Math.floor(this.subnetMask / 4);
                
                var reversed = this.canonicalForm()
    .replace(/:/g, '')
    .split('')
    .slice(0, characters)
    .reverse()
    .join('.');
                
                if (characters > 0) {
                    return sprintf("%s.ip6.arpa.", reversed);
                }
                
                return 'ip6.arpa.';
            };
            
            /*
 * Returns the correct form of the address
 */
v6.Address.prototype.correctForm = function () {
                if (!this.parsedAddress) {
                    return;
                }
                
                var i;
                var groups = [];
                
                var zeroCounter = 0;
                var zeroes = [];
                
                for (i = 0; i < this.parsedAddress.length; i++) {
                    var value = parseInt(this.parsedAddress[i], 16);
                    
                    if (value === 0) {
                        zeroCounter++;
                    }
                    
                    if (value !== 0 && zeroCounter > 0) {
                        if (zeroCounter > 1) {
                            zeroes.push([i - zeroCounter, i - 1]);
                        }
                        
                        zeroCounter = 0;
                    }
                }
                
                // Do we end with a string of zeroes?
                if (zeroCounter > 1) {
                    zeroes.push([this.parsedAddress.length - zeroCounter,
      this.parsedAddress.length - 1]);
                }
                
                var zeroLengths = map(zeroes, function (n) {
                    return (n[1] - n[0]) + 1;
                });
                
                if (zeroes.length > 0) {
                    var max = Math.max.apply(Math, zeroLengths);
                    var index = zeroLengths.indexOf(max);
                    
                    groups = v6.Address.compact(this.parsedAddress, zeroes[index]);
                } else {
                    groups = this.parsedAddress;
                }
                
                for (i = 0; i < groups.length; i++) {
                    if (groups[i] !== 'compact') {
                        groups[i] = parseInt(groups[i], 16).toString(16);
                    }
                }
                
                var correct = groups.join(':');
                
                correct = correct.replace(/^compact$/, '::');
                correct = correct.replace(/^compact|compact$/, ':');
                correct = correct.replace(/compact/, '');
                
                return correct;
            };
            
            /*
 * Returns a zero-padded base-2 string representation of the address
 */
v6.Address.prototype.binaryZeroPad = function () {
                return zeroPad(this.bigInteger().toString(2), v6.BITS);
            };
            
            // TODO: Improve the semantics of this helper function
            v6.Address.prototype.parse4in6 = function (address) {
                var groups = address.split(':');
                var lastGroup = groups.slice(-1)[0];
                
                var address4 = lastGroup.match(v4.RE_ADDRESS);
                
                if (address4) {
                    var temp4 = new v4.Address(address4[0]);
                    
                    for (var i = 0; i < temp4.groups; i++) {
                        if (/^0[0-9]+/.test(temp4.parsedAddress[i])) {
                            this.valid = false;
                            this.error = 'IPv4 addresses can not have leading zeroes.';
                            
                            this.parseError = address.replace(v4.RE_ADDRESS,
          map(temp4.parsedAddress, spanLeadingZeroes4).join('.'));
                            
                            return;
                        }
                    }
                    
                    this.v4 = true;
                    
                    groups[groups.length - 1] = temp4.toV6Group();
                    
                    address = groups.join(':');
                }
                
                return address;
            };
            
            // TODO: Make private?
            v6.Address.prototype.parse = function (address) {
                address = this.parse4in6(address);
                
                if (this.error) {
                    return;
                }
                
                var badCharacters = address.match(v6.RE_BAD_CHARACTERS);
                
                if (badCharacters) {
                    this.valid = false;
                    this.error = sprintf("Bad character%s detected in address: %s",
      badCharacters.length > 1 ? 's' : '', badCharacters.join(''));
                    
                    this.parseError = address.replace(v6.RE_BAD_CHARACTERS,
      '<span class="parse-error">$1</span>');
                    
                    return;
                }
                
                var badAddress = address.match(v6.RE_BAD_ADDRESS);
                
                if (badAddress) {
                    this.valid = false;
                    this.error = sprintf("Address failed regex: %s", badAddress.join(''));
                    
                    this.parseError = address.replace(v6.RE_BAD_ADDRESS,
      '<span class="parse-error">$1</span>');
                    
                    return;
                }
                
                var groups = [];
                
                var halves = address.split('::');
                
                if (halves.length === 2) {
                    var first = halves[0].split(':');
                    var last = halves[1].split(':');
                    
                    if (first.length === 1 &&
      first[0] === '') {
                        first = [];
                    }
                    
                    if (last.length === 1 &&
      last[0] === '') {
                        last = [];
                    }
                    
                    var remaining = this.groups - (first.length + last.length);
                    
                    if (!remaining) {
                        this.valid = false;
                        this.error = "Error parsing groups";
                        
                        return;
                    }
                    
                    this.elidedGroups = remaining;
                    
                    this.elisionBegin = first.length;
                    this.elisionEnd = first.length + this.elidedGroups;
                    
                    first.forEach(function (group) {
                        groups.push(group);
                    });
                    
                    for (var i = 0; i < remaining; i++) {
                        groups.push(0);
                    }
                    
                    last.forEach(function (group) {
                        groups.push(group);
                    });
                } else if (halves.length === 1) {
                    groups = address.split(':');
                    
                    this.elidedGroups = 0;
                } else {
                    this.valid = false;
                    this.error = "Too many :: groups found";
                    
                    return;
                }
                
                groups = map(groups, function (g) {
                    return sprintf('%x', parseInt(g, 16));
                });
                
                if (groups.length !== this.groups) {
                    this.valid = false;
                    this.error = "Incorrect number of groups found";
                    
                    return;
                }
                
                groups.forEach(function (group, i) {
                    if (groups.length > 4 && !this.v4) {
                        this.valid = false;
                        this.error = sprintf("Group %d is too long", i + 1);
                        
                        return;
                    }
                });
                
                this.valid = true;
                
                return groups;
            };
            
            /*
 * Generate a regular expression string that can be used to find or validate all
 * variations of this address.
 */
v6.Address.prototype.regularExpressionString = function (opt_subString) {
                if (opt_subString === undefined) {
                    opt_subString = false;
                }
                
                var i;
                var output = [];
                
                var address6 = new v6.Address(this.correctForm());
                
                if (address6.elidedGroups === 0) {
                    // The simple case
                    output = simpleRegularExpression(address6.parsedAddress);
                } else if (address6.elidedGroups === 8) {
                    output.push('::|');
                    
                    // TODO: Validate this
                    for (i = 0; i < address6.elidedGroups; i++) {
                        var pipe = '|';
                        
                        if (i === address6.elidedGroups - 1) {
                            pipe = '';
                        }
                        
                        output.push(sprintf('(0{1,4}:){%d}:%s', address6.elidedGroups, pipe));
                    }
                } else {
                    // The elided case
                    
                    // TODO: Allow sloppy elision
                    // TODO: Compute all possible elisions
                    var halves = address6.address.split('::');
                    
                    if (halves[0].length) {
                        output = output.concat(simpleRegularExpression(halves[0].split(':')));
                        output.push(':');
                    }
                    
                    output.push(sprintf('((0{1,4}:){%d}|:)', address6.elidedGroups));
                    
                    if (halves[1].length) {
                        output = output.concat(simpleRegularExpression(halves[1].split(':')));
                    }
                }
                
                if (!opt_subString) {
                    output = [].concat('\\b', output, '\\b');
                }
                
                return output.join('');
            };
            
            /*
 * Generate a regular expression that can be used to find or validate all
 * variations of this address.
 */
v6.Address.prototype.regularExpression = function () {
                return new RegExp(this.regularExpressionString(), 'i');
            };
            
            /*
 * Returns the canonical form of the address
 */
v6.Address.prototype.canonicalForm = function () {
                if (!this.valid) {
                    return;
                }
                
                return map(this.parsedAddress, function (n) {
                    return sprintf("%04x", parseInt(n, 16));
                }).join(':');
            };
            
            /*
 * Returns the decimal form of the address
 */
v6.Address.prototype.decimal = function () {
                if (!this.valid) {
                    return;
                }
                
                return map(this.parsedAddress, function (n) {
                    return sprintf("%05d", parseInt(n, 16));
                }).join(':');
            };
            
            /*
 * Returns the address as a BigInteger
 */
v6.Address.prototype.bigInteger = function () {
                if (!this.valid) {
                    return;
                }
                
                return new BigInteger(map(this.parsedAddress, function (n) {
                    return sprintf("%04x", parseInt(n, 16));
                }).join(''), 16);
            };
            
            /*
 * Returns the v4-in-v6 form of the address
 */
v6.Address.prototype.v4inv6 = function () {
                var binary = this.binaryZeroPad().split('');
                
                var address4 = v4.Address.fromHex(new BigInteger(binary.slice(96, 128)
    .join(''), 2).toString(16));
                var address6 = new v6.Address(this.parsedAddress.slice(0, 6).join(':'), 6);
                
                var correct = address6.correctForm();
                
                var infix = '';
                
                if (!/:$/.test(correct)) {
                    infix = ':';
                }
                
                return address6.correctForm() + infix + address4.address;
            };
            
            /*
 * Returns an object containing the Teredo properties of the address
 */
v6.Address.prototype.teredo = function () {
                /*
  - Bits 0 to 31 are set to the Teredo prefix (normally 2001:0000::/32).
  - Bits 32 to 63 embed the primary IPv4 address of the Teredo server that
  is used.
  - Bits 64 to 79 can be used to define some flags. Currently only the
  higher order bit is used; it is set to 1 if the Teredo client is
  located behind a cone NAT, 0 otherwise. For Microsoft's Windows Vista
  and Windows Server 2008 implementations, more bits are used. In those
  implementations, the format for these 16 bits is "CRAAAAUG AAAAAAAA",
  where "C" remains the "Cone" flag. The "R" bit is reserved for future
  use. The "U" bit is for the Universal/Local flag (set to 0). The "G" bit
  is Individual/Group flag (set to 0). The A bits are set to a 12-bit
  randomly generated number chosen by the Teredo client to introduce
  additional protection for the Teredo node against IPv6-based scanning
  attacks.
  - Bits 80 to 95 contains the obfuscated UDP port number. This is the
  port number that is mapped by the NAT to the Teredo client with all
  bits inverted.
  - Bits 96 to 127 contains the obfuscated IPv4 address. This is the
  public IPv4 address of the NAT with all bits inverted.
  */

  var prefix = this.getBitsBase16(0, 32);
                
                var udpPort = this.getBits(80, 96).xor(new BigInteger('ffff', 16)).toString();
                
                var server4 = v4.Address.fromHex(this.getBitsBase16(32, 64));
                var client4 = v4.Address.fromHex(this.getBits(96, 128)
    .xor(new BigInteger('ffffffff', 16)).toString(16));
                
                var flags = this.getBits(64, 80);
                var flagsBase2 = this.getBitsBase2(64, 80);
                
                var coneNat = flags.testBit(15);
                var reserved = flags.testBit(14);
                var groupIndividual = flags.testBit(8);
                var universalLocal = flags.testBit(9);
                var nonce = new BigInteger(flagsBase2.slice(2, 6) +
    flagsBase2.slice(8, 16), 2).toString(10);
                
                return {
                    prefix: sprintf('%s:%s', prefix.slice(0, 4), prefix.slice(4, 8)),
                    server4: server4.address,
                    client4: client4.address,
                    flags: flagsBase2,
                    coneNat: coneNat,
                    microsoft: {
                        reserved: reserved,
                        universalLocal: universalLocal,
                        groupIndividual: groupIndividual,
                        nonce: nonce
                    },
                    udpPort: udpPort
                };
            };
            
            /*
 * Returns an object containing the 6to4 properties of the address
 */
v6.Address.prototype.six2four = function () {
                /*
  - Bits 0 to 15 are set to the 6to4 prefix (2002::/16).
  - Bits 16 to 48 embed the IPv4 address of the 6to4 gateway that is used.
  */

  var prefix = this.getBitsBase16(0, 16);
                
                var gateway = v4.Address.fromHex(this.getBitsBase16(16, 48));
                
                return {
                    prefix: sprintf('%s', prefix.slice(0, 4)),
                    gateway: gateway.address
                };
            };

        }, { "./lib/node/bigint": 54, "sprintf": 55 }], 54: [function (require, module, exports) {
            /**
 * copped from https://github.com/joyent/node/blob/master/deps/v8/benchmarks/crypto.js (under same license).
 * 
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */

// V8 optimized constants.
var dbits = 26
            var BI_DB = dbits;
            var BI_DM = ((1 << dbits) - 1);
            var BI_DV = (1 << dbits);
            
            var BI_FP = 52;
            var BI_FV = Math.pow(2, BI_FP);
            var BI_F1 = BI_FP - dbits;
            var BI_F2 = 2 * dbits - BI_FP;
            
            BigInteger = module.exports.BigInteger = function (a, b, c) {
                this.array = new Array();
                if (a != null)
                    if ("number" == typeof a) this.fromNumber(a, b, c);
                    else if (b == null && "string" != typeof a) this.fromString(a, 256);
                    else this.fromString(a, b);
            }
            
            // return new, unset BigInteger
            function nbi() { return new BigInteger(null); }
            
            // am: Compute w_j += (x*this_i), propagate carries,
            // c is initial carry, returns final carry.
            // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
            // We need to select the fastest one that works in this environment.
            
            // This is tailored to VMs with 2-bit tagging. It makes sure
            // that all the computations stay within the 29 bits available.
            function am4(i, x, w, j, c, n) {
                var this_array = this.array;
                var w_array = w.array;
                
                var xl = x & 0x1fff, xh = x >> 13;
                while (--n >= 0) {
                    var l = this_array[i] & 0x1fff;
                    var h = this_array[i++] >> 13;
                    var m = xh * l + h * xl;
                    l = xl * l + ((m & 0x1fff) << 13) + w_array[j] + c;
                    c = (l >> 26) + (m >> 13) + xh * h;
                    w_array[j++] = l & 0x3ffffff;
                }
                return c;
            }
            
            // Digit conversions
            var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
            var BI_RC = new Array();
            var rr, vv;
            rr = "0".charCodeAt(0);
            for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
            rr = "a".charCodeAt(0);
            for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
            rr = "A".charCodeAt(0);
            for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
            
            function int2char(n) { return BI_RM.charAt(n); }
            function intAt(s, i) {
                var c = BI_RC[s.charCodeAt(i)];
                return (c == null)?-1:c;
            }
            
            // (protected) copy this to r
            function bnpCopyTo(r) {
                var this_array = this.array;
                var r_array = r.array;
                
                for (var i = this.t - 1; i >= 0; --i) r_array[i] = this_array[i];
                r.t = this.t;
                r.s = this.s;
            }
            
            // (protected) set from integer value x, -DV <= x < DV
            function bnpFromInt(x) {
                var this_array = this.array;
                this.t = 1;
                this.s = (x < 0)?-1:0;
                if (x > 0) this_array[0] = x;
                else if (x < -1) this_array[0] = x + DV; // WTH is DV?  BI_DV maybe?
                else this.t = 0;
            }
            
            // return bigint initialized to value
            function nbv(i) { var r = nbi(); r.fromInt(i); return r; }
            
            // (protected) set from string and radix
            function bnpFromString(s, b) {
                var this_array = this.array;
                var k;
                if (b == 16) k = 4;
                else if (b == 8) k = 3;
                else if (b == 256) k = 8; // byte array
                else if (b == 2) k = 1;
                else if (b == 32) k = 5;
                else if (b == 4) k = 2;
                else { this.fromRadix(s, b); return; }
                this.t = 0;
                this.s = 0;
                var i = s.length, mi = false, sh = 0;
                while (--i >= 0) {
                    var x = (k == 8)?s[i] & 0xff:intAt(s, i);
                    if (x < 0) {
                        if (s.charAt(i) == "-") mi = true;
                        continue;
                    }
                    mi = false;
                    if (sh == 0)
                        this_array[this.t++] = x;
                    else if (sh + k > BI_DB) {
                        this_array[this.t - 1] |= (x & ((1 << (BI_DB - sh)) - 1)) << sh;
                        this_array[this.t++] = (x >> (BI_DB - sh));
                    }
                    else
                        this_array[this.t - 1] |= x << sh;
                    sh += k;
                    if (sh >= BI_DB) sh -= BI_DB;
                }
                if (k == 8 && (s[0] & 0x80) != 0) {
                    this.s = -1;
                    if (sh > 0) this_array[this.t - 1] |= ((1 << (BI_DB - sh)) - 1) << sh;
                }
                this.clamp();
                if (mi) BigInteger.ZERO.subTo(this, this);
            }
            
            // (protected) clamp off excess high words
            function bnpClamp() {
                var this_array = this.array;
                var c = this.s & BI_DM;
                while (this.t > 0 && this_array[this.t - 1] == c) --this.t;
            }
            
            // (public) return string representation in given radix
            function bnToString(b) {
                var this_array = this.array;
                if (this.s < 0) return "-" + this.negate().toString(b);
                var k;
                if (b == 16) k = 4;
                else if (b == 8) k = 3;
                else if (b == 2) k = 1;
                else if (b == 32) k = 5;
                else if (b == 4) k = 2;
                else return this.toRadix(b);
                var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
                var p = BI_DB - (i * BI_DB) % k;
                if (i-- > 0) {
                    if (p < BI_DB && (d = this_array[i] >> p) > 0) { m = true; r = int2char(d); }
                    while (i >= 0) {
                        if (p < k) {
                            d = (this_array[i] & ((1 << p) - 1)) << (k - p);
                            d |= this_array[--i] >> (p += BI_DB - k);
                        }
                        else {
                            d = (this_array[i] >> (p -= k)) & km;
                            if (p <= 0) { p += BI_DB; --i; }
                        }
                        if (d > 0) m = true;
                        if (m) r += int2char(d);
                    }
                }
                return m?r:"0";
            }
            
            // (public) -this
            function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this, r); return r; }
            
            // (public) |this|
            function bnAbs() { return (this.s < 0)?this.negate():this; }
            
            // (public) return + if this > a, - if this < a, 0 if equal
            function bnCompareTo(a) {
                var this_array = this.array;
                var a_array = a.array;
                
                var r = this.s - a.s;
                if (r != 0) return r;
                var i = this.t;
                r = i - a.t;
                if (r != 0) return r;
                while (--i >= 0) if ((r = this_array[i] - a_array[i]) != 0) return r;
                return 0;
            }
            
            // returns bit length of the integer x
            function nbits(x) {
                var r = 1, t;
                if ((t = x >>> 16) != 0) { x = t; r += 16; }
                if ((t = x >> 8) != 0) { x = t; r += 8; }
                if ((t = x >> 4) != 0) { x = t; r += 4; }
                if ((t = x >> 2) != 0) { x = t; r += 2; }
                if ((t = x >> 1) != 0) { x = t; r += 1; }
                return r;
            }
            
            // (public) return the number of bits in "this"
            function bnBitLength() {
                var this_array = this.array;
                if (this.t <= 0) return 0;
                return BI_DB * (this.t - 1) + nbits(this_array[this.t - 1] ^ (this.s & BI_DM));
            }
            
            // (protected) r = this << n*DB
            function bnpDLShiftTo(n, r) {
                var this_array = this.array;
                var r_array = r.array;
                var i;
                for (i = this.t - 1; i >= 0; --i) r_array[i + n] = this_array[i];
                for (i = n - 1; i >= 0; --i) r_array[i] = 0;
                r.t = this.t + n;
                r.s = this.s;
            }
            
            // (protected) r = this >> n*DB
            function bnpDRShiftTo(n, r) {
                var this_array = this.array;
                var r_array = r.array;
                for (var i = n; i < this.t; ++i) r_array[i - n] = this_array[i];
                r.t = Math.max(this.t - n, 0);
                r.s = this.s;
            }
            
            // (protected) r = this << n
            function bnpLShiftTo(n, r) {
                var this_array = this.array;
                var r_array = r.array;
                var bs = n % BI_DB;
                var cbs = BI_DB - bs;
                var bm = (1 << cbs) - 1;
                var ds = Math.floor(n / BI_DB), c = (this.s << bs) & BI_DM, i;
                for (i = this.t - 1; i >= 0; --i) {
                    r_array[i + ds + 1] = (this_array[i] >> cbs) | c;
                    c = (this_array[i] & bm) << bs;
                }
                for (i = ds - 1; i >= 0; --i) r_array[i] = 0;
                r_array[ds] = c;
                r.t = this.t + ds + 1;
                r.s = this.s;
                r.clamp();
            }
            
            // (protected) r = this >> n
            function bnpRShiftTo(n, r) {
                var this_array = this.array;
                var r_array = r.array;
                r.s = this.s;
                var ds = Math.floor(n / BI_DB);
                if (ds >= this.t) { r.t = 0; return; }
                var bs = n % BI_DB;
                var cbs = BI_DB - bs;
                var bm = (1 << bs) - 1;
                r_array[0] = this_array[ds] >> bs;
                for (var i = ds + 1; i < this.t; ++i) {
                    r_array[i - ds - 1] |= (this_array[i] & bm) << cbs;
                    r_array[i - ds] = this_array[i] >> bs;
                }
                if (bs > 0) r_array[this.t - ds - 1] |= (this.s & bm) << cbs;
                r.t = this.t - ds;
                r.clamp();
            }
            
            // (protected) r = this - a
            function bnpSubTo(a, r) {
                var this_array = this.array;
                var r_array = r.array;
                var a_array = a.array;
                var i = 0, c = 0, m = Math.min(a.t, this.t);
                while (i < m) {
                    c += this_array[i] - a_array[i];
                    r_array[i++] = c & BI_DM;
                    c >>= BI_DB;
                }
                if (a.t < this.t) {
                    c -= a.s;
                    while (i < this.t) {
                        c += this_array[i];
                        r_array[i++] = c & BI_DM;
                        c >>= BI_DB;
                    }
                    c += this.s;
                }
                else {
                    c += this.s;
                    while (i < a.t) {
                        c -= a_array[i];
                        r_array[i++] = c & BI_DM;
                        c >>= BI_DB;
                    }
                    c -= a.s;
                }
                r.s = (c < 0)?-1:0;
                if (c < -1) r_array[i++] = BI_DV + c;
                else if (c > 0) r_array[i++] = c;
                r.t = i;
                r.clamp();
            }
            
            // (protected) r = this * a, r != this,a (HAC 14.12)
            // "this" should be the larger one if appropriate.
            function bnpMultiplyTo(a, r) {
                var this_array = this.array; // Unused local var?
                var r_array = r.array;
                var x = this.abs(), y = a.abs();
                var y_array = y.array;
                
                var i = x.t;
                r.t = i + y.t;
                while (--i >= 0) r_array[i] = 0;
                for (i = 0; i < y.t; ++i) r_array[i + x.t] = x.am(0, y_array[i], r, i, 0, x.t);
                r.s = 0;
                r.clamp();
                if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
            }
            
            // (protected) r = this^2, r != this (HAC 14.16)
            function bnpSquareTo(r) {
                var x = this.abs();
                var x_array = x.array;
                var r_array = r.array;
                
                var i = r.t = 2 * x.t;
                while (--i >= 0) r_array[i] = 0;
                for (i = 0; i < x.t - 1; ++i) {
                    var c = x.am(i, x_array[i], r, 2 * i, 0, 1);
                    if ((r_array[i + x.t] += x.am(i + 1, 2 * x_array[i], r, 2 * i + 1, c, x.t - i - 1)) >= BI_DV) {
                        r_array[i + x.t] -= BI_DV;
                        r_array[i + x.t + 1] = 1;
                    }
                }
                if (r.t > 0) r_array[r.t - 1] += x.am(i, x_array[i], r, 2 * i, 0, 1);
                r.s = 0;
                r.clamp();
            }
            
            // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
            // r != q, this != m.  q or r may be null.
            function bnpDivRemTo(m, q, r) {
                var pm = m.abs();
                if (pm.t <= 0) return;
                var pt = this.abs();
                if (pt.t < pm.t) {
                    if (q != null) q.fromInt(0);
                    if (r != null) this.copyTo(r);
                    return;
                }
                if (r == null) r = nbi();
                var y = nbi(), ts = this.s, ms = m.s;
                var pm_array = pm.array;
                var nsh = BI_DB - nbits(pm_array[pm.t - 1]);	// normalize modulus
                if (nsh > 0) { pm.lShiftTo(nsh, y); pt.lShiftTo(nsh, r); }
                else { pm.copyTo(y); pt.copyTo(r); }
                var ys = y.t;
                
                var y_array = y.array;
                var y0 = y_array[ys - 1];
                if (y0 == 0) return;
                var yt = y0 * (1 << BI_F1) + ((ys > 1)?y_array[ys - 2] >> BI_F2:0);
                var d1 = BI_FV / yt, d2 = (1 << BI_F1) / yt, e = 1 << BI_F2;
                var i = r.t, j = i - ys, t = (q == null)?nbi():q;
                y.dlShiftTo(j, t);
                
                var r_array = r.array;
                if (r.compareTo(t) >= 0) {
                    r_array[r.t++] = 1;
                    r.subTo(t, r);
                }
                BigInteger.ONE.dlShiftTo(ys, t);
                t.subTo(y, y);	// "negative" y so we can replace sub with am later
                while (y.t < ys) y_array[y.t++] = 0;
                while (--j >= 0) {
                    // Estimate quotient digit
                    var qd = (r_array[--i] == y0)?BI_DM:Math.floor(r_array[i] * d1 + (r_array[i - 1] + e) * d2);
                    if ((r_array[i] += y.am(0, qd, r, j, 0, ys)) < qd) {	// Try it out
                        y.dlShiftTo(j, t);
                        r.subTo(t, r);
                        while (r_array[i] < --qd) r.subTo(t, r);
                    }
                }
                if (q != null) {
                    r.drShiftTo(ys, q);
                    if (ts != ms) BigInteger.ZERO.subTo(q, q);
                }
                r.t = ys;
                r.clamp();
                if (nsh > 0) r.rShiftTo(nsh, r);	// Denormalize remainder
                if (ts < 0) BigInteger.ZERO.subTo(r, r);
            }
            
            // (public) this mod a
            function bnMod(a) {
                var r = nbi();
                this.abs().divRemTo(a, null, r);
                if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
                return r;
            }
            
            // Modular reduction using "classic" algorithm
            function Classic(m) { this.m = m; }
            function cConvert(x) {
                if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
                else return x;
            }
            function cRevert(x) { return x; }
            function cReduce(x) { x.divRemTo(this.m, null, x); }
            function cMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r); }
            function cSqrTo(x, r) { x.squareTo(r); this.reduce(r); }
            
            Classic.prototype.convert = cConvert;
            Classic.prototype.revert = cRevert;
            Classic.prototype.reduce = cReduce;
            Classic.prototype.mulTo = cMulTo;
            Classic.prototype.sqrTo = cSqrTo;
            
            // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
            // justification:
            //         xy == 1 (mod m)
            //         xy =  1+km
            //   xy(2-xy) = (1+km)(1-km)
            // x[y(2-xy)] = 1-k^2m^2
            // x[y(2-xy)] == 1 (mod m^2)
            // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
            // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
            // JS multiply "overflows" differently from C/C++, so care is needed here.
            function bnpInvDigit() {
                var this_array = this.array;
                if (this.t < 1) return 0;
                var x = this_array[0];
                if ((x & 1) == 0) return 0;
                var y = x & 3;		// y == 1/x mod 2^2
                y = (y * (2 - (x & 0xf) * y)) & 0xf;	// y == 1/x mod 2^4
                y = (y * (2 - (x & 0xff) * y)) & 0xff;	// y == 1/x mod 2^8
                y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;	// y == 1/x mod 2^16
                // last step - calculate inverse mod DV directly;
                // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
                y = (y * (2 - x * y % BI_DV)) % BI_DV;		// y == 1/x mod 2^dbits
                // we really want the negative inverse, and -DV < y < DV
                return (y > 0)?BI_DV - y:-y;
            }
            
            // Montgomery reduction
            function Montgomery(m) {
                this.m = m;
                this.mp = m.invDigit();
                this.mpl = this.mp & 0x7fff;
                this.mph = this.mp >> 15;
                this.um = (1 << (BI_DB - 15)) - 1;
                this.mt2 = 2 * m.t;
            }
            
            // xR mod m
            function montConvert(x) {
                var r = nbi();
                x.abs().dlShiftTo(this.m.t, r);
                r.divRemTo(this.m, null, r);
                if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
                return r;
            }
            
            // x/R mod m
            function montRevert(x) {
                var r = nbi();
                x.copyTo(r);
                this.reduce(r);
                return r;
            }
            
            // x = x/R mod m (HAC 14.32)
            function montReduce(x) {
                var x_array = x.array;
                while (x.t <= this.mt2)	// pad x so am has enough room later
                    x_array[x.t++] = 0;
                for (var i = 0; i < this.m.t; ++i) {
                    // faster way of calculating u0 = x[i]*mp mod DV
                    var j = x_array[i] & 0x7fff;
                    var u0 = (j * this.mpl + (((j * this.mph + (x_array[i] >> 15) * this.mpl) & this.um) << 15)) & BI_DM;
                    // use am to combine the multiply-shift-add into one call
                    j = i + this.m.t;
                    x_array[j] += this.m.am(0, u0, x, i, 0, this.m.t);
                    // propagate carry
                    while (x_array[j] >= BI_DV) { x_array[j] -= BI_DV; x_array[++j]++; }
                }
                x.clamp();
                x.drShiftTo(this.m.t, x);
                if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
            }
            
            // r = "x^2/R mod m"; x != r
            function montSqrTo(x, r) { x.squareTo(r); this.reduce(r); }
            
            // r = "xy/R mod m"; x,y != r
            function montMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r); }
            
            Montgomery.prototype.convert = montConvert;
            Montgomery.prototype.revert = montRevert;
            Montgomery.prototype.reduce = montReduce;
            Montgomery.prototype.mulTo = montMulTo;
            Montgomery.prototype.sqrTo = montSqrTo;
            
            // (protected) true iff this is even
            function bnpIsEven() {
                var this_array = this.array;
                return ((this.t > 0)?(this_array[0] & 1):this.s) == 0;
            }
            
            // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
            function bnpExp(e, z) {
                if (e > 0xffffffff || e < 1) return BigInteger.ONE;
                var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
                g.copyTo(r);
                while (--i >= 0) {
                    z.sqrTo(r, r2);
                    if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
                    else { var t = r; r = r2; r2 = t; }
                }
                return z.revert(r);
            }
            
            // (public) this^e % m, 0 <= e < 2^32
            function bnModPowInt(e, m) {
                var z;
                if (e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
                return this.exp(e, z);
            }
            
            // protected
            BigInteger.prototype.copyTo = bnpCopyTo;
            BigInteger.prototype.fromInt = bnpFromInt;
            BigInteger.prototype.fromString = bnpFromString;
            BigInteger.prototype.clamp = bnpClamp;
            BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
            BigInteger.prototype.drShiftTo = bnpDRShiftTo;
            BigInteger.prototype.lShiftTo = bnpLShiftTo;
            BigInteger.prototype.rShiftTo = bnpRShiftTo;
            BigInteger.prototype.subTo = bnpSubTo;
            BigInteger.prototype.multiplyTo = bnpMultiplyTo;
            BigInteger.prototype.squareTo = bnpSquareTo;
            BigInteger.prototype.divRemTo = bnpDivRemTo;
            BigInteger.prototype.invDigit = bnpInvDigit;
            BigInteger.prototype.isEven = bnpIsEven;
            BigInteger.prototype.exp = bnpExp;
            
            // public
            BigInteger.prototype.toString = bnToString;
            BigInteger.prototype.negate = bnNegate;
            BigInteger.prototype.abs = bnAbs;
            BigInteger.prototype.compareTo = bnCompareTo;
            BigInteger.prototype.bitLength = bnBitLength;
            BigInteger.prototype.mod = bnMod;
            BigInteger.prototype.modPowInt = bnModPowInt;
            
            // "constants"
            BigInteger.ZERO = nbv(0);
            BigInteger.ONE = nbv(1);
            // Copyright (c) 2005  Tom Wu
            // All Rights Reserved.
            // See "LICENSE" for details.
            
            // Extended JavaScript BN functions, required for RSA private ops.
            
            // (public)
            function bnClone() { var r = nbi(); this.copyTo(r); return r; }
            
            // (public) return value as integer
            function bnIntValue() {
                var this_array = this.array;
                if (this.s < 0) {
                    if (this.t == 1) return this_array[0] - BI_DV;
                    else if (this.t == 0) return -1;
                }
                else if (this.t == 1) return this_array[0];
                else if (this.t == 0) return 0;
                // assumes 16 < DB < 32
                return ((this_array[1] & ((1 << (32 - BI_DB)) - 1)) << BI_DB) | this_array[0];
            }
            
            // (public) return value as byte
            function bnByteValue() {
                var this_array = this.array;
                return (this.t == 0)?this.s:(this_array[0] << 24) >> 24;
            }
            
            // (public) return value as short (assumes DB>=16)
            function bnShortValue() {
                var this_array = this.array;
                return (this.t == 0)?this.s:(this_array[0] << 16) >> 16;
            }
            
            // (protected) return x s.t. r^x < DV
            function bnpChunkSize(r) { return Math.floor(Math.LN2 * BI_DB / Math.log(r)); }
            
            // (public) 0 if this == 0, 1 if this > 0
            function bnSigNum() {
                var this_array = this.array;
                if (this.s < 0) return -1;
                else if (this.t <= 0 || (this.t == 1 && this_array[0] <= 0)) return 0;
                else return 1;
            }
            
            // (protected) convert to radix string
            function bnpToRadix(b) {
                if (b == null) b = 10;
                if (this.signum() == 0 || b < 2 || b > 36) return "0";
                var cs = this.chunkSize(b);
                var a = Math.pow(b, cs);
                var d = nbv(a), y = nbi(), z = nbi(), r = "";
                this.divRemTo(d, y, z);
                while (y.signum() > 0) {
                    r = (a + z.intValue()).toString(b).substr(1) + r;
                    y.divRemTo(d, y, z);
                }
                return z.intValue().toString(b) + r;
            }
            
            // (protected) convert from radix string
            function bnpFromRadix(s, b) {
                this.fromInt(0);
                if (b == null) b = 10;
                var cs = this.chunkSize(b);
                var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
                for (var i = 0; i < s.length; ++i) {
                    var x = intAt(s, i);
                    if (x < 0) {
                        if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
                        continue;
                    }
                    w = b * w + x;
                    if (++j >= cs) {
                        this.dMultiply(d);
                        this.dAddOffset(w, 0);
                        j = 0;
                        w = 0;
                    }
                }
                if (j > 0) {
                    this.dMultiply(Math.pow(b, j));
                    this.dAddOffset(w, 0);
                }
                if (mi) BigInteger.ZERO.subTo(this, this);
            }
            
            // (protected) alternate constructor
            function bnpFromNumber(a, b, c) {
                if ("number" == typeof b) {
                    // new BigInteger(int,int,RNG)
                    if (a < 2) this.fromInt(1);
                    else {
                        this.fromNumber(a, c);
                        if (!this.testBit(a - 1))	// force MSB set
                            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                        if (this.isEven()) this.dAddOffset(1, 0); // force odd
                        while (!this.isProbablePrime(b)) {
                            this.dAddOffset(2, 0);
                            if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                        }
                    }
                }
                else {
                    // todo: we don't need this.
                    // new BigInteger(int,RNG)
                    var x = new Array(), t = a & 7;
                    x.length = (a >> 3) + 1;
                    b.nextBytes(x);
                    if (t > 0) x[0] &= ((1 << t) - 1); else x[0] = 0;
                    this.fromString(x, 256);
                }
            }
            
            // (public) convert to bigendian byte array
            function bnToByteArray() {
                var this_array = this.array;
                var i = this.t, r = new Array();
                r[0] = this.s;
                var p = BI_DB - (i * BI_DB) % 8, d, k = 0;
                if (i-- > 0) {
                    if (p < BI_DB && (d = this_array[i] >> p) != (this.s & BI_DM) >> p)
                        r[k++] = d | (this.s << (BI_DB - p));
                    while (i >= 0) {
                        if (p < 8) {
                            d = (this_array[i] & ((1 << p) - 1)) << (8 - p);
                            d |= this_array[--i] >> (p += BI_DB - 8);
                        }
                        else {
                            d = (this_array[i] >> (p -= 8)) & 0xff;
                            if (p <= 0) { p += BI_DB; --i; }
                        }
                        if ((d & 0x80) != 0) d |= -256;
                        if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;
                        if (k > 0 || d != this.s) r[k++] = d;
                    }
                }
                return r;
            }
            
            function bnEquals(a) { return (this.compareTo(a) == 0); }
            function bnMin(a) { return (this.compareTo(a) < 0)?this:a; }
            function bnMax(a) { return (this.compareTo(a) > 0)?this:a; }
            
            // (protected) r = this op a (bitwise)
            function bnpBitwiseTo(a, op, r) {
                var this_array = this.array;
                var a_array = a.array;
                var r_array = r.array;
                var i, f, m = Math.min(a.t, this.t);
                for (i = 0; i < m; ++i) r_array[i] = op(this_array[i], a_array[i]);
                if (a.t < this.t) {
                    f = a.s & BI_DM;
                    for (i = m; i < this.t; ++i) r_array[i] = op(this_array[i], f);
                    r.t = this.t;
                }
                else {
                    f = this.s & BI_DM;
                    for (i = m; i < a.t; ++i) r_array[i] = op(f, a_array[i]);
                    r.t = a.t;
                }
                r.s = op(this.s, a.s);
                r.clamp();
            }
            
            // (public) this & a
            function op_and(x, y) { return x & y; }
            function bnAnd(a) { var r = nbi(); this.bitwiseTo(a, op_and, r); return r; }
            
            // (public) this | a
            function op_or(x, y) { return x | y; }
            function bnOr(a) { var r = nbi(); this.bitwiseTo(a, op_or, r); return r; }
            
            // (public) this ^ a
            function op_xor(x, y) { return x ^ y; }
            function bnXor(a) { var r = nbi(); this.bitwiseTo(a, op_xor, r); return r; }
            
            // (public) this & ~a
            function op_andnot(x, y) { return x & ~y; }
            function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a, op_andnot, r); return r; }
            
            // (public) ~this
            function bnNot() {
                var this_array = this.array;
                var r = nbi();
                var r_array = r.array;
                
                for (var i = 0; i < this.t; ++i) r_array[i] = BI_DM & ~this_array[i];
                r.t = this.t;
                r.s = ~this.s;
                return r;
            }
            
            // (public) this << n
            function bnShiftLeft(n) {
                var r = nbi();
                if (n < 0) this.rShiftTo(-n, r); else this.lShiftTo(n, r);
                return r;
            }
            
            // (public) this >> n
            function bnShiftRight(n) {
                var r = nbi();
                if (n < 0) this.lShiftTo(-n, r); else this.rShiftTo(n, r);
                return r;
            }
            
            // return index of lowest 1-bit in x, x < 2^31
            function lbit(x) {
                if (x == 0) return -1;
                var r = 0;
                if ((x & 0xffff) == 0) { x >>= 16; r += 16; }
                if ((x & 0xff) == 0) { x >>= 8; r += 8; }
                if ((x & 0xf) == 0) { x >>= 4; r += 4; }
                if ((x & 3) == 0) { x >>= 2; r += 2; }
                if ((x & 1) == 0) ++r;
                return r;
            }
            
            // (public) returns index of lowest 1-bit (or -1 if none)
            function bnGetLowestSetBit() {
                var this_array = this.array;
                for (var i = 0; i < this.t; ++i)
                    if (this_array[i] != 0) return i * BI_DB + lbit(this_array[i]);
                if (this.s < 0) return this.t * BI_DB;
                return -1;
            }
            
            // return number of 1 bits in x
            function cbit(x) {
                var r = 0;
                while (x != 0) { x &= x - 1; ++r; }
                return r;
            }
            
            // (public) return number of set bits
            function bnBitCount() {
                var this_array = this.array;
                var r = 0, x = this.s & BI_DM;
                for (var i = 0; i < this.t; ++i) r += cbit(this_array[i] ^ x);
                return r;
            }
            
            // (public) true iff nth bit is set
            function bnTestBit(n) {
                var this_array = this.array;
                var j = Math.floor(n / BI_DB);
                if (j >= this.t) return (this.s != 0);
                return ((this_array[j] & (1 << (n % BI_DB))) != 0);
            }
            
            // (protected) this op (1<<n)
            function bnpChangeBit(n, op) {
                var r = BigInteger.ONE.shiftLeft(n);
                this.bitwiseTo(r, op, r);
                return r;
            }
            
            // (public) this | (1<<n)
            function bnSetBit(n) { return this.changeBit(n, op_or); }
            
            // (public) this & ~(1<<n)
            function bnClearBit(n) { return this.changeBit(n, op_andnot); }
            
            // (public) this ^ (1<<n)
            function bnFlipBit(n) { return this.changeBit(n, op_xor); }
            
            // (protected) r = this + a
            function bnpAddTo(a, r) {
                var this_array = this.array;
                var a_array = a.array;
                var r_array = r.array;
                var i = 0, c = 0, m = Math.min(a.t, this.t);
                while (i < m) {
                    c += this_array[i] + a_array[i];
                    r_array[i++] = c & BI_DM;
                    c >>= BI_DB;
                }
                if (a.t < this.t) {
                    c += a.s;
                    while (i < this.t) {
                        c += this_array[i];
                        r_array[i++] = c & BI_DM;
                        c >>= BI_DB;
                    }
                    c += this.s;
                }
                else {
                    c += this.s;
                    while (i < a.t) {
                        c += a_array[i];
                        r_array[i++] = c & BI_DM;
                        c >>= BI_DB;
                    }
                    c += a.s;
                }
                r.s = (c < 0)?-1:0;
                if (c > 0) r_array[i++] = c;
                else if (c < -1) r_array[i++] = BI_DV + c;
                r.t = i;
                r.clamp();
            }
            
            // (public) this + a
            function bnAdd(a) { var r = nbi(); this.addTo(a, r); return r; }
            
            // (public) this - a
            function bnSubtract(a) { var r = nbi(); this.subTo(a, r); return r; }
            
            // (public) this * a
            function bnMultiply(a) { var r = nbi(); this.multiplyTo(a, r); return r; }
            
            // (public) this / a
            function bnDivide(a) { var r = nbi(); this.divRemTo(a, r, null); return r; }
            
            // (public) this % a
            function bnRemainder(a) { var r = nbi(); this.divRemTo(a, null, r); return r; }
            
            // (public) [this/a,this%a]
            function bnDivideAndRemainder(a) {
                var q = nbi(), r = nbi();
                this.divRemTo(a, q, r);
                return new Array(q, r);
            }
            
            // (protected) this *= n, this >= 0, 1 < n < DV
            function bnpDMultiply(n) {
                var this_array = this.array;
                this_array[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
                ++this.t;
                this.clamp();
            }
            
            // (protected) this += n << w words, this >= 0
            function bnpDAddOffset(n, w) {
                var this_array = this.array;
                while (this.t <= w) this_array[this.t++] = 0;
                this_array[w] += n;
                while (this_array[w] >= BI_DV) {
                    this_array[w] -= BI_DV;
                    if (++w >= this.t) this_array[this.t++] = 0;
                    ++this_array[w];
                }
            }
            
            // A "null" reducer
            function NullExp() { }
            function nNop(x) { return x; }
            function nMulTo(x, y, r) { x.multiplyTo(y, r); }
            function nSqrTo(x, r) { x.squareTo(r); }
            
            NullExp.prototype.convert = nNop;
            NullExp.prototype.revert = nNop;
            NullExp.prototype.mulTo = nMulTo;
            NullExp.prototype.sqrTo = nSqrTo;
            
            // (public) this^e
            function bnPow(e) { return this.exp(e, new NullExp()); }
            
            // (protected) r = lower n words of "this * a", a.t <= n
            // "this" should be the larger one if appropriate.
            function bnpMultiplyLowerTo(a, n, r) {
                var r_array = r.array;
                var a_array = a.array;
                var i = Math.min(this.t + a.t, n);
                r.s = 0; // assumes a,this >= 0
                r.t = i;
                while (i > 0) r_array[--i] = 0;
                var j;
                for (j = r.t - this.t; i < j; ++i) r_array[i + this.t] = this.am(0, a_array[i], r, i, 0, this.t);
                for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a_array[i], r, i, 0, n - i);
                r.clamp();
            }
            
            // (protected) r = "this * a" without lower n words, n > 0
            // "this" should be the larger one if appropriate.
            function bnpMultiplyUpperTo(a, n, r) {
                var r_array = r.array;
                var a_array = a.array;
                --n;
                var i = r.t = this.t + a.t - n;
                r.s = 0; // assumes a,this >= 0
                while (--i >= 0) r_array[i] = 0;
                for (i = Math.max(n - this.t, 0); i < a.t; ++i)
                    r_array[this.t + i - n] = this.am(n - i, a_array[i], r, 0, 0, this.t + i - n);
                r.clamp();
                r.drShiftTo(1, r);
            }
            
            // Barrett modular reduction
            function Barrett(m) {
                // setup Barrett
                this.r2 = nbi();
                this.q3 = nbi();
                BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
                this.mu = this.r2.divide(m);
                this.m = m;
            }
            
            function barrettConvert(x) {
                if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
                else if (x.compareTo(this.m) < 0) return x;
                else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
            }
            
            function barrettRevert(x) { return x; }
            
            // x = x mod m (HAC 14.42)
            function barrettReduce(x) {
                x.drShiftTo(this.m.t - 1, this.r2);
                if (x.t > this.m.t + 1) { x.t = this.m.t + 1; x.clamp(); }
                this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
                this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
                while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
                x.subTo(this.r2, x);
                while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
            }
            
            // r = x^2 mod m; x != r
            function barrettSqrTo(x, r) { x.squareTo(r); this.reduce(r); }
            
            // r = x*y mod m; x,y != r
            function barrettMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r); }
            
            Barrett.prototype.convert = barrettConvert;
            Barrett.prototype.revert = barrettRevert;
            Barrett.prototype.reduce = barrettReduce;
            Barrett.prototype.mulTo = barrettMulTo;
            Barrett.prototype.sqrTo = barrettSqrTo;
            
            // (public) this^e % m (HAC 14.85)
            function bnModPow(e, m) {
                var e_array = e.array;
                var i = e.bitLength(), k, r = nbv(1), z;
                if (i <= 0) return r;
                else if (i < 18) k = 1;
                else if (i < 48) k = 3;
                else if (i < 144) k = 4;
                else if (i < 768) k = 5;
                else k = 6;
                if (i < 8)
                    z = new Classic(m);
                else if (m.isEven())
                    z = new Barrett(m);
                else
                    z = new Montgomery(m);
                
                // precomputation
                var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
                g[1] = z.convert(this);
                if (k > 1) {
                    var g2 = nbi();
                    z.sqrTo(g[1], g2);
                    while (n <= km) {
                        g[n] = nbi();
                        z.mulTo(g2, g[n - 2], g[n]);
                        n += 2;
                    }
                }
                
                var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
                i = nbits(e_array[j]) - 1;
                while (j >= 0) {
                    if (i >= k1) w = (e_array[j] >> (i - k1)) & km;
                    else {
                        w = (e_array[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                        if (j > 0) w |= e_array[j - 1] >> (BI_DB + i - k1);
                    }
                    
                    n = k;
                    while ((w & 1) == 0) { w >>= 1; --n; }
                    if ((i -= n) < 0) { i += BI_DB; --j; }
                    if (is1) {	// ret == 1, don't bother squaring or multiplying it
                        g[w].copyTo(r);
                        is1 = false;
                    }
                    else {
                        while (n > 1) { z.sqrTo(r, r2); z.sqrTo(r2, r); n -= 2; }
                        if (n > 0) z.sqrTo(r, r2); else { t = r; r = r2; r2 = t; }
                        z.mulTo(r2, g[w], r);
                    }
                    
                    while (j >= 0 && (e_array[j] & (1 << i)) == 0) {
                        z.sqrTo(r, r2); t = r; r = r2; r2 = t;
                        if (--i < 0) { i = BI_DB - 1; --j; }
                    }
                }
                return z.revert(r);
            }
            
            // (public) gcd(this,a) (HAC 14.54)
            function bnGCD(a) {
                var x = (this.s < 0)?this.negate():this.clone();
                var y = (a.s < 0)?a.negate():a.clone();
                if (x.compareTo(y) < 0) { var t = x; x = y; y = t; }
                var i = x.getLowestSetBit(), g = y.getLowestSetBit();
                if (g < 0) return x;
                if (i < g) g = i;
                if (g > 0) {
                    x.rShiftTo(g, x);
                    y.rShiftTo(g, y);
                }
                while (x.signum() > 0) {
                    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
                    if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
                    if (x.compareTo(y) >= 0) {
                        x.subTo(y, x);
                        x.rShiftTo(1, x);
                    }
                    else {
                        y.subTo(x, y);
                        y.rShiftTo(1, y);
                    }
                }
                if (g > 0) y.lShiftTo(g, y);
                return y;
            }
            
            // (protected) this % n, n < 2^26
            function bnpModInt(n) {
                var this_array = this.array;
                if (n <= 0) return 0;
                var d = BI_DV % n, r = (this.s < 0)?n - 1:0;
                if (this.t > 0)
                    if (d == 0) r = this_array[0] % n;
                    else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this_array[i]) % n;
                return r;
            }
            
            // (public) 1/this % m (HAC 14.61)
            function bnModInverse(m) {
                var ac = m.isEven();
                if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
                var u = m.clone(), v = this.clone();
                var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
                while (u.signum() != 0) {
                    while (u.isEven()) {
                        u.rShiftTo(1, u);
                        if (ac) {
                            if (!a.isEven() || !b.isEven()) { a.addTo(this, a); b.subTo(m, b); }
                            a.rShiftTo(1, a);
                        }
                        else if (!b.isEven()) b.subTo(m, b);
                        b.rShiftTo(1, b);
                    }
                    while (v.isEven()) {
                        v.rShiftTo(1, v);
                        if (ac) {
                            if (!c.isEven() || !d.isEven()) { c.addTo(this, c); d.subTo(m, d); }
                            c.rShiftTo(1, c);
                        }
                        else if (!d.isEven()) d.subTo(m, d);
                        d.rShiftTo(1, d);
                    }
                    if (u.compareTo(v) >= 0) {
                        u.subTo(v, u);
                        if (ac) a.subTo(c, a);
                        b.subTo(d, b);
                    }
                    else {
                        v.subTo(u, v);
                        if (ac) c.subTo(a, c);
                        d.subTo(b, d);
                    }
                }
                if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
                if (d.compareTo(m) >= 0) return d.subtract(m);
                if (d.signum() < 0) d.addTo(m, d); else return d;
                if (d.signum() < 0) return d.add(m); else return d;
            }
            
            var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
            var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
            
            // (public) test primality with certainty >= 1-.5^t
            function bnIsProbablePrime(t) {
                var i, x = this.abs();
                var x_array = x.array;
                if (x.t == 1 && x_array[0] <= lowprimes[lowprimes.length - 1]) {
                    for (i = 0; i < lowprimes.length; ++i)
                        if (x_array[0] == lowprimes[i]) return true;
                    return false;
                }
                if (x.isEven()) return false;
                i = 1;
                while (i < lowprimes.length) {
                    var m = lowprimes[i], j = i + 1;
                    while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
                    m = x.modInt(m);
                    while (i < j) if (m % lowprimes[i++] == 0) return false;
                }
                return x.millerRabin(t);
            }
            
            // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
            function bnpMillerRabin(t) {
                var n1 = this.subtract(BigInteger.ONE);
                var k = n1.getLowestSetBit();
                if (k <= 0) return false;
                var r = n1.shiftRight(k);
                t = (t + 1) >> 1;
                if (t > lowprimes.length) t = lowprimes.length;
                var a = nbi();
                for (var i = 0; i < t; ++i) {
                    a.fromInt(lowprimes[i]);
                    var y = a.modPow(r, this);
                    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                        var j = 1;
                        while (j++ < k && y.compareTo(n1) != 0) {
                            y = y.modPowInt(2, this);
                            if (y.compareTo(BigInteger.ONE) == 0) return false;
                        }
                        if (y.compareTo(n1) != 0) return false;
                    }
                }
                return true;
            }            ;
            
            // protected
            BigInteger.prototype.chunkSize = bnpChunkSize;
            BigInteger.prototype.toRadix = bnpToRadix;
            BigInteger.prototype.fromRadix = bnpFromRadix;
            BigInteger.prototype.fromNumber = bnpFromNumber;
            BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
            BigInteger.prototype.changeBit = bnpChangeBit;
            BigInteger.prototype.addTo = bnpAddTo;
            BigInteger.prototype.dMultiply = bnpDMultiply;
            BigInteger.prototype.dAddOffset = bnpDAddOffset;
            BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
            BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
            BigInteger.prototype.modInt = bnpModInt;
            BigInteger.prototype.millerRabin = bnpMillerRabin;
            
            // public
            BigInteger.prototype.clone = bnClone;
            BigInteger.prototype.intValue = bnIntValue;
            BigInteger.prototype.byteValue = bnByteValue;
            BigInteger.prototype.shortValue = bnShortValue;
            BigInteger.prototype.signum = bnSigNum;
            BigInteger.prototype.toByteArray = bnToByteArray;
            BigInteger.prototype.equals = bnEquals;
            BigInteger.prototype.min = bnMin;
            BigInteger.prototype.max = bnMax;
            BigInteger.prototype.and = bnAnd;
            BigInteger.prototype.or = bnOr;
            BigInteger.prototype.xor = bnXor;
            BigInteger.prototype.andNot = bnAndNot;
            BigInteger.prototype.not = bnNot;
            BigInteger.prototype.shiftLeft = bnShiftLeft;
            BigInteger.prototype.shiftRight = bnShiftRight;
            BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
            BigInteger.prototype.bitCount = bnBitCount;
            BigInteger.prototype.testBit = bnTestBit;
            BigInteger.prototype.setBit = bnSetBit;
            BigInteger.prototype.clearBit = bnClearBit;
            BigInteger.prototype.flipBit = bnFlipBit;
            BigInteger.prototype.add = bnAdd;
            BigInteger.prototype.subtract = bnSubtract;
            BigInteger.prototype.multiply = bnMultiply;
            BigInteger.prototype.divide = bnDivide;
            BigInteger.prototype.remainder = bnRemainder;
            BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
            BigInteger.prototype.modPow = bnModPow;
            BigInteger.prototype.modInverse = bnModInverse;
            BigInteger.prototype.pow = bnPow;
            BigInteger.prototype.gcd = bnGCD;
            BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
            BigInteger.prototype.am = am4;

// end of stuff copied from github.
        }, {}], 55: [function (require, module, exports) {
            /**
sprintf() for JavaScript 0.7-beta1
http://www.diveintojavascript.com/projects/javascript-sprintf

Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of sprintf() for JavaScript nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Alexandru Marasteanu BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


Changelog:
2010.11.07 - 0.7-beta1-node
  - converted it to a node.js compatible module

2010.09.06 - 0.7-beta1
  - features: vsprintf, support for named placeholders
  - enhancements: format cache, reduced global namespace pollution

2010.05.22 - 0.6:
 - reverted to 0.4 and fixed the bug regarding the sign of the number 0
 Note:
 Thanks to Raphael Pigulla <raph (at] n3rd [dot) org> (http://www.n3rd.org/)
 who warned me about a bug in 0.5, I discovered that the last update was
 a regress. I appologize for that.

2010.05.09 - 0.5:
 - bug fix: 0 is now preceeded with a + sign
 - bug fix: the sign was not at the right position on padded results (Kamal Abdali)
 - switched from GPL to BSD license

2007.10.21 - 0.4:
 - unit test and patch (David Baird)

2007.09.17 - 0.3:
 - bug fix: no longer throws exception on empty paramenters (Hans Pufal)

2007.09.11 - 0.2:
 - feature: added argument swapping

2007.04.03 - 0.1:
 - initial release
**/

var sprintf = (function () {
                function get_type(variable) {
                    return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
                }
                function str_repeat(input, multiplier) {
                    for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */ }
                    return output.join('');
                }
                
                var str_format = function () {
                    if (!str_format.cache.hasOwnProperty(arguments[0])) {
                        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
                    }
                    return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
                };
                
                // convert object to simple one line string without indentation or
                // newlines. Note that this implementation does not print array
                // values to their actual place for sparse arrays. 
                //
                // For example sparse array like this
                //    l = []
                //    l[4] = 1
                // Would be printed as "[1]" instead of "[, , , , 1]"
                // 
                // If argument 'seen' is not null and array the function will check for 
                // circular object references from argument.
                str_format.object_stringify = function (obj, depth, maxdepth, seen) {
                    var str = '';
                    if (obj != null) {
                        switch (typeof (obj)) {
                            case 'function':
                                return '[Function' + (obj.name ? ': ' + obj.name : '') + ']';
                                break;
                            case 'object':
                                if (obj instanceof Error) { return '[' + obj.toString() + ']' }                                ;
                                if (depth >= maxdepth) return '[Object]'
                                if (seen) {
                                    // add object to seen list
                                    seen = seen.slice(0)
                                    seen.push(obj);
                                }
                                if (obj.length != null) { //array
                                    str += '[';
                                    var arr = []
                                    for (var i in obj) {
                                        if (seen && seen.indexOf(obj[i]) >= 0) arr.push('[Circular]');
                                        else arr.push(str_format.object_stringify(obj[i], depth + 1, maxdepth, seen));
                                    }
                                    str += arr.join(', ') + ']';
                                } else if ('getMonth' in obj) { // date
                                    return 'Date(' + obj + ')';
                                } else { // object
                                    str += '{';
                                    var arr = []
                                    for (var k in obj) {
                                        if (obj.hasOwnProperty(k)) {
                                            if (seen && seen.indexOf(obj[k]) >= 0) arr.push(k + ': [Circular]');
                                            else arr.push(k + ': ' + str_format.object_stringify(obj[k], depth + 1, maxdepth, seen));
                                        }
                                    }
                                    str += arr.join(', ') + '}';
                                }
                                return str;
                                break;
                            case 'string':
                                return '"' + obj + '"';
                                break
                        }
                    }
                    return '' + obj;
                }
                
                str_format.format = function (parse_tree, argv) {
                    var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
                    for (i = 0; i < tree_length; i++) {
                        node_type = get_type(parse_tree[i]);
                        if (node_type === 'string') {
                            output.push(parse_tree[i]);
                        }
                        else if (node_type === 'array') {
                            match = parse_tree[i]; // convenience purposes only
                            if (match[2]) { // keyword argument
                                arg = argv[cursor];
                                for (k = 0; k < match[2].length; k++) {
                                    if (!arg.hasOwnProperty(match[2][k])) {
                                        throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                                    }
                                    arg = arg[match[2][k]];
                                }
                            }
                            else if (match[1]) { // positional argument (explicit)
                                arg = argv[match[1]];
                            }
                            else { // positional argument (implicit)
                                arg = argv[cursor++];
                            }
                            
                            if (/[^sO]/.test(match[8]) && (get_type(arg) != 'number')) {
                                throw new Error(sprintf('[sprintf] expecting number but found %s "' + arg + '"', get_type(arg)));
                            }
                            switch (match[8]) {
                                case 'b': arg = arg.toString(2); break;
                                case 'c': arg = String.fromCharCode(arg); break;
                                case 'd': arg = parseInt(arg, 10); break;
                                case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
                                case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
                                case 'O': arg = str_format.object_stringify(arg, 0, parseInt(match[7]) || 5); break;
                                case 'o': arg = arg.toString(8); break;
                                case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
                                case 'u': arg = Math.abs(arg); break;
                                case 'x': arg = arg.toString(16); break;
                                case 'X': arg = arg.toString(16).toUpperCase(); break;
                            }
                            arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg);
                            pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                            pad_length = match[6] - String(arg).length;
                            pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                            output.push(match[5] ? arg + pad : pad + arg);
                        }
                    }
                    return output.join('');
                };
                
                str_format.cache = {};
                
                str_format.parse = function (fmt) {
                    var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
                    while (_fmt) {
                        if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                            parse_tree.push(match[0]);
                        }
                        else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                            parse_tree.push('%');
                        }
                        else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosOuxX])/.exec(_fmt)) !== null) {
                            if (match[2]) {
                                arg_names |= 1;
                                var field_list = [], replacement_field = match[2], field_match = [];
                                if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                    while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                        if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                            field_list.push(field_match[1]);
                                        }
                                        else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                            field_list.push(field_match[1]);
                                        }
                                        else {
                                            throw new Error('[sprintf] ' + replacement_field);
                                        }
                                    }
                                }
                                else {
                                    throw new Error('[sprintf] ' + replacement_field);
                                }
                                match[2] = field_list;
                            }
                            else {
                                arg_names |= 2;
                            }
                            if (arg_names === 3) {
                                throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
                            }
                            parse_tree.push(match);
                        }
                        else {
                            throw new Error('[sprintf] ' + _fmt);
                        }
                        _fmt = _fmt.substring(match[0].length);
                    }
                    return parse_tree;
                };
                
                return str_format;
            })();
            
            var vsprintf = function (fmt, argv) {
                var argvClone = argv.slice();
                argvClone.unshift(fmt);
                return sprintf.apply(null, argvClone);
            };
            
            module.exports = sprintf;
            sprintf.sprintf = sprintf;
            sprintf.vsprintf = vsprintf;

        }, {}], 56: [function (require, module, exports) {
            /* Copyright 2010 Membase, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';
            
            /*jshint node:true*/
            
            
            /**
 * Convert a 16-bit quantity (short integer) from host byte order to network byte order (Little-Endian to Big-Endian).
 *
 * @param {Array|Buffer} b Array of octets or a nodejs Buffer
 * @param {number} i Zero-based index at which to write into b
 * @param {number} v Value to convert
 */
exports.htons = function (b, i, v) {
                b[i] = (0xff & (v >> 8));
                b[i + 1] = (0xff & (v));
            };
            
            
            /**
 * Convert a 16-bit quantity (short integer) from network byte order to host byte order (Big-Endian to Little-Endian).
 *
 * @param {Array|Buffer} b Array of octets or a nodejs Buffer to read value from
 * @param {number} i Zero-based index at which to read from b
 * @returns {number}
 */
exports.ntohs = function (b, i) {
                return ((0xff & b[i]) << 8) | 
	       ((0xff & b[i + 1]));
            };
            
            
            /**
 * Convert a 16-bit quantity (short integer) from network byte order to host byte order (Big-Endian to Little-Endian).
 *
 * @param {string} s String to read value from
 * @param {number} i Zero-based index at which to read from s
 * @returns {number}
 */
exports.ntohsStr = function (s, i) {
                return ((0xff & s.charCodeAt(i)) << 8) |
	       ((0xff & s.charCodeAt(i + 1)));
            };
            
            
            /**
 * Convert a 32-bit quantity (long integer) from host byte order to network byte order (Little-Endian to Big-Endian).
 *
 * @param {Array|Buffer} b Array of octets or a nodejs Buffer
 * @param {number} i Zero-based index at which to write into b
 * @param {number} v Value to convert
 */
exports.htonl = function (b, i, v) {
                b[i] = (0xff & (v >> 24));
                b[i + 1] = (0xff & (v >> 16));
                b[i + 2] = (0xff & (v >> 8));
                b[i + 3] = (0xff & (v));
            };
            
            
            /**
 * Convert a 32-bit quantity (long integer) from network byte order to host byte order (Big-Endian to Little-Endian).
 *
 * @param {Array|Buffer} b Array of octets or a nodejs Buffer to read value from
 * @param {number} i Zero-based index at which to read from b
 * @returns {number}
 */
exports.ntohl = function (b, i) {
                return ((0xff & b[i]) << 24) |
	       ((0xff & b[i + 1]) << 16) |
	       ((0xff & b[i + 2]) << 8) |
	       ((0xff & b[i + 3]));
            };
            
            
            /**
 * Convert a 32-bit quantity (long integer) from network byte order to host byte order (Big-Endian to Little-Endian).
 *
 * @param {string} s String to read value from
 * @param {number} i Zero-based index at which to read from s
 * @returns {number}
 */
exports.ntohlStr = function (s, i) {
                return ((0xff & s.charCodeAt(i)) << 24) |
	       ((0xff & s.charCodeAt(i + 1)) << 16) |
	       ((0xff & s.charCodeAt(i + 2)) << 8) |
	       ((0xff & s.charCodeAt(i + 3)));
            };

        }, {}], 57: [function (require, module, exports) {
            module.exports = {
                "name": "bitcore-p2p-browserify",
                "version": "0.14.0",
                "description": "A fork of bitpay/bitcore-p2p, with Browserify support",
                "author": {
                    "name": "BitPay",
                    "email": "dev@bitpay.com"
                },
                "main": "index.js",
                "scripts": {
                    "lint": "gulp lint",
                    "test": "gulp test",
                    "coverage": "gulp coverage",
                    "build": "gulp"
                },
                "contributors": [
                    {
                        "name": "Yemel Jardi",
                        "email": "yemel@bitpay.com"
                    },
                    {
                        "name": "Braydon Fuller",
                        "email": "braydon@bitpay.com"
                    },
                    {
                        "name": "Ryan X. Charles",
                        "email": "ryan@bitpay.com"
                    },
                    {
                        "name": "Eric Martindale",
                        "email": "eric@bitpay.com"
                    },
                    {
                        "name": "Philip Hutchins",
                        "email": "philip@bitpay.com"
                    },
                    {
                        "name": "Manuel Araoz",
                        "email": "maraoz@bitpay.com"
                    },
                    {
                        "name": "Esteban Ordano",
                        "email": "eordano@gmail.com"
                    },
                    {
                        "name": "Elichai Turkel"
                    }
                ],
                "keywords": [
                    "bitcoin",
                    "bitcore"
                ],
                "repository": {
                    "type": "git",
                    "url": "https://github.com/bitpay/bitcore-p2p.git"
                },
                "dependencies": {
                    "bitcore": "^0.12.0",
                    "bloom-filter": "^0.2.0",
                    "buffers": "^0.1.1",
                    "socks5-client": "^0.3.6"
                },
                "devDependencies": {
                    "bitcore-build": "git://github.com/bitpay/bitcore-build.git",
                    "brfs": "^1.2.0",
                    "chai": "~1.10.0",
                    "gulp": "^3.8.10",
                    "sinon": "^1.12.2"
                },
                "license": "MIT",
                "readme": "<img src=\"http://bitcore.io/css/images/bitcore-p2p.svg\" alt=\"bitcore payment protocol\" height=\"35\" width=\"102\">\n\nBitcore P2P\n=======\n\n[![NPM Package](https://img.shields.io/npm/v/bitcore-p2p.svg?style=flat-square)](https://www.npmjs.org/package/bitcore-p2p)\n[![Build Status](https://img.shields.io/travis/bitpay/bitcore-p2p.svg?branch=master&style=flat-square)](https://travis-ci.org/bitpay/bitcore-p2p)\n[![Coverage Status](https://img.shields.io/coveralls/bitpay/bitcore-p2p.svg?style=flat-square)](https://coveralls.io/r/bitpay/bitcore-p2p?branch=master)\n\n`bitcore-p2p` adds [Bitcoin protocol](https://en.bitcoin.it/wiki/Protocol_documentation) support for Bitcore.\n\nSee [the main bitcore repo](https://github.com/bitpay/bitcore) for more information.\n\n## Getting Started\n\n```sh\nnpm install bitcore-p2p\n```\nIn order to connect to the Bitcoin network, you'll need to know the IP address of at least one node of the network, or use [Pool](/docs/pool.md) to discover peers using a DNS seed.\n\n```javascript\nvar Peer = require('bitcore-p2p').Peer;\n\nvar peer = new Peer({host: '127.0.0.1'});\n\npeer.on('ready', function() {\n  // peer info\n  console.log(peer.version, peer.subversion, peer.bestHeight);\n});\npeer.on('disconnect', function() {\n  console.log('connection closed');\n});\npeer.connect();\n```\n\nThen, you can get information from other peers by using:\n\n```javascript\n// handle events\npeer.on('inv', function(message) {\n  // message.inventory[]\n});\npeer.on('tx', function(message) {\n  // message.transaction\n});\n```\n\nTake a look at the [bitcore guide](http://bitcore.io/guide/peer.html) on the usage of the `Peer` class.\n\n## Contributing\n\nSee [CONTRIBUTING.md](https://github.com/bitpay/bitcore) on the main bitcore repo for information about how to contribute.\n\n## License\n\nCode released under [the MIT license](https://github.com/bitpay/bitcore/blob/master/LICENSE).\n\nCopyright 2013-2015 BitPay, Inc. Bitcore is a trademark maintained by BitPay, Inc.\n",
                "readmeFilename": "README.md",
                "bugs": {
                    "url": "https://github.com/bitpay/bitcore-p2p/issues"
                },
                "_id": "bitcore-p2p-browserify@0.14.0",
                "dist": {
                    "shasum": "e567f0012deabe77848a65b1751743fcdd4fbad9"
                },
                "_from": "bitcore-p2p-browserify@^0.14.0",
                "_resolved": "https://registry.npmjs.org/bitcore-p2p-browserify/-/bitcore-p2p-browserify-0.14.0.tgz"
            }

        }, {}], 58: [function (require, module, exports) {
            (function (Buffer) {
                'use strict';
                
                
                // requires node 3.1
                var events = require('events');
                var util = require('util');
                
                var buffertools = {};
                module.exports.Buffer = Buffer;
                
                
                var is_buffer = function (x) {
                    return x instanceof Buffer || x instanceof Uint8Array;
                };
                
                var unaryAction = function (f) {
                    return function () {
                        var target = this;
                        if (is_buffer(target)) { } else if (is_buffer(arguments[0])) {
                            target = arguments[0];
                            Array.prototype.shift.apply(arguments);
                        } else {
                            throw new Error('Argument should be a buffer object.');
                        }
                        return f.apply(target, arguments);
                    };
                };
                
                var binaryAction = function (f) {
                    return function () {
                        var target = this;
                        
                        // first argument
                        if (is_buffer(target)) { } else if (is_buffer(arguments[0])) {
                            target = arguments[0];
                            Array.prototype.shift.apply(arguments);
                        } else {
                            throw Error('Argument should be a buffer object.');
                        }
                        
                        // second argument
                        var next = arguments[0];
                        if (typeof next == 'string' || next instanceof String || is_buffer(next)) {
                            return f.apply(target, arguments);
                        }
                        throw new Error('Second argument must be a string or a buffer.');
                    };
                };
                
                buffertools.clear = unaryAction(function () {
                    for (var i = 0; i < this.length; i++) {
                        this[i] = 0;
                    }
                    return this;
                });
                
                buffertools.fill = unaryAction(function (data) {
                    var step = typeof data.length === 'undefined' ? 1 : data.length;
                    for (var i = 0; i < this.length; i += step) {
                        for (var k = 0; k < step; k++) {
                            this[i + k] = typeof data.length === 'undefined' ? data :
        (typeof data[k] === 'string' ? data[k].charCodeAt(0) : data[k]);
                        }
                    }
                    return this;
                });
                
                buffertools.indexOf = unaryAction(function (data, startFrom) {
                    startFrom = startFrom || 0;
                    if (data.length === 0) return -1;
                    for (var i = startFrom; i < this.length - data.length + 1; i += 1) {
                        var found = true;
                        for (var j = 0; j < data.length; j++) {
                            var a = this[i + j];
                            var b = data[j];
                            if (typeof b === 'string') b = b.charCodeAt(0);
                            if (a !== b) {
                                found = false;
                                break;
                            }
                        }
                        if (found) return i;
                    }
                    return -1;
                });
                
                buffertools.equals = binaryAction(function (data) {
                    return buffertools.compare(this, data) === 0;
                });
                
                buffertools.compare = binaryAction(function (data) {
                    var buffer = this;
                    var l1 = buffer.length;
                    var l2 = data.length;
                    if (l1 !== l2) {
                        return l1 > l2 ? 1 : -1;
                    }
                    for (var i = 0; i < l1; i++) {
                        var a = buffer[i];
                        var b = data[i];
                        if (typeof b === 'string') b = b.charCodeAt(0);
                        if (a === b) continue;
                        return a > b ? 1 : -1;
                    }
                    return 0;
                });
                buffertools.concat = function () {
                    var len = 0;
                    for (var i = 0; i < arguments.length; i++) {
                        if (arguments[i].length === undefined) throw Error('all arguments must be strings or Buffers');
                        len += arguments[i].length;
                    }
                    var ret = new Buffer(len);
                    var k = 0;
                    for (var i = 0; i < arguments.length; i++) {
                        for (var j = 0; j < arguments[i].length; j++) {
                            ret[k++] = typeof arguments[i][j] === 'string' ?
        arguments[i][j].charCodeAt(0) : arguments[i][j];
                        }
                    }
                    return ret;
                };
                buffertools.reverse = unaryAction(function () {
                    var ret = new Buffer(this.length);
                    for (var i = 0; i < this.length; i++) {
                        ret[i] = this[this.length - i - 1];
                    }
                    return ret;
                });
                
                buffertools.toHex = unaryAction(function () {
                    var s = '';
                    for (var i = 0; i < this.length; i++) {
                        var h = this[i].toString(16);
                        if (h.length == 1) h = '0' + h;
                        if (h.length > 2) console.log('strange h =' + h);
                        s += h;
                    }
                    return s;
                });
                buffertools.fromHex = unaryAction(function () {
                    var l = this.length;
                    if (l % 2 !== 0) throw new Error('Invalid hex string length');
                    var ret = new Buffer(l / 2);
                    for (var i = 0; i < ret.length; i++) {
                        var c1 = String.fromCharCode(this[2 * i]);
                        var c2 = String.fromCharCode(this[2 * i + 1]);
                        ret[i] = parseInt(c1 + c2, 16);
                    }
                    return ret;
                });
                
                exports.extend = function () {
                    var receivers;
                    if (arguments.length > 0) {
                        receivers = Array.prototype.slice.call(arguments);
                    } else if (typeof Uint8Array === 'function') {
                        receivers = [Buffer.prototype, Uint8Array.prototype];
                    } else {
                        receivers = [Buffer.prototype];
                    }
                    for (var i = 0, n = receivers.length; i < n; i += 1) {
                        var receiver = receivers[i];
                        for (var key in buffertools) {
                            receiver[key] = buffertools[key];
                        }
                        if (receiver !== exports) {
                            receiver.concat = function () {
                                var args = [this].concat(Array.prototype.slice.call(arguments));
                                return buffertools.concat.apply(buffertools, args);
                            };
                        }
                    }
                };
                exports.extend(exports);
                
                //
                // WritableBufferStream
                //
                // - never emits 'error'
                // - never emits 'drain'
                //
                function WritableBufferStream() {
                    this.writable = true;
                    this.buffer = null;
                }
                
                util.inherits(WritableBufferStream, events.EventEmitter);
                
                WritableBufferStream.prototype._append = function (buffer, encoding) {
                    if (!this.writable) {
                        throw new Error('Stream is not writable.');
                    }
                    
                    if (Buffer.isBuffer(buffer)) {
    // no action required
                    } else if (typeof buffer == 'string') {
                        // TODO optimize
                        buffer = new Buffer(buffer, encoding || 'utf8');
                    } else {
                        throw new Error('Argument should be either a buffer or a string.');
                    }
                    
                    // FIXME optimize!
                    if (this.buffer) {
                        this.buffer = buffertools.concat(this.buffer, buffer);
                    } else {
                        this.buffer = new Buffer(buffer.length);
                        buffer.copy(this.buffer);
                    }
                };
                
                WritableBufferStream.prototype.write = function (buffer, encoding) {
                    this._append(buffer, encoding);
                    
                    // signal that it's safe to immediately write again
                    return true;
                };
                
                WritableBufferStream.prototype.end = function (buffer, encoding) {
                    if (buffer) {
                        this._append(buffer, encoding);
                    }
                    
                    this.emit('close');
                    
                    this.writable = false;
                };
                
                WritableBufferStream.prototype.getBuffer = function () {
                    if (this.buffer) {
                        return this.buffer;
                    }
                    return new Buffer(0);
                };
                
                WritableBufferStream.prototype.toString = function () {
                    return this.getBuffer().toString();
                };
                
                exports.WritableBufferStream = WritableBufferStream;

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172, "events": 317, "util": 342 }], 59: [function (require, module, exports) {
            (function (Buffer) {
                module.exports = Level
                
                var IDB = require('idb-wrapper')
                var AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
                var util = require('util')
                var Iterator = require('./iterator')
                var isBuffer = require('isbuffer')
                var xtend = require('xtend')
                var toBuffer = require('typedarray-to-buffer')
                
                function Level(location) {
                    if (!(this instanceof Level)) return new Level(location)
                    if (!location) throw new Error("constructor requires at least a location argument")
                    this.IDBOptions = {}
                    this.location = location
                }
                
                util.inherits(Level, AbstractLevelDOWN)
                
                Level.prototype._open = function (options, callback) {
                    var self = this
                    
                    var idbOpts = {
                        storeName: this.location,
                        autoIncrement: false,
                        keyPath: null,
                        onStoreReady: function () {
                            callback && callback(null, self.idb)
                        }, 
                        onError: function (err) {
                            callback && callback(err)
                        }
                    }
                    
                    xtend(idbOpts, options)
                    this.IDBOptions = idbOpts
                    this.idb = new IDB(idbOpts)
                }
                
                Level.prototype._get = function (key, options, callback) {
                    this.idb.get(key, function (value) {
                        if (value === undefined) {
                            // 'NotFound' error, consistent with LevelDOWN API
                            return callback(new Error('NotFound'))
                        }
                        // by default return buffers, unless explicitly told not to
                        var asBuffer = true
                        if (options.asBuffer === false) asBuffer = false
                        if (options.raw) asBuffer = false
                        if (asBuffer) {
                            if (value instanceof Uint8Array) value = toBuffer(value)
                            else value = new Buffer(String(value))
                        }
                        return callback(null, value, key)
                    }, callback)
                }
                
                Level.prototype._del = function (id, options, callback) {
                    this.idb.remove(id, callback, callback)
                }
                
                Level.prototype._put = function (key, value, options, callback) {
                    if (value instanceof ArrayBuffer) {
                        value = toBuffer(new Uint8Array(value))
                    }
                    var obj = this.convertEncoding(key, value, options)
                    if (Buffer.isBuffer(obj.value)) {
                        obj.value = new Uint8Array(value.toArrayBuffer())
                    }
                    this.idb.put(obj.key, obj.value, function () { callback() }, callback)
                }
                
                Level.prototype.convertEncoding = function (key, value, options) {
                    if (options.raw) return { key: key, value: value }
                    if (value) {
                        var stringed = value.toString()
                        if (stringed === 'NaN') value = 'NaN'
                    }
                    var valEnc = options.valueEncoding
                    var obj = { key: key, value: value }
                    if (value && (!valEnc || valEnc !== 'binary')) {
                        if (typeof obj.value !== 'object') {
                            obj.value = stringed
                        }
                    }
                    return obj
                }
                
                Level.prototype.iterator = function (options) {
                    if (typeof options !== 'object') options = {}
                    return new Iterator(this.idb, options)
                }
                
                Level.prototype._batch = function (array, options, callback) {
                    var op
                    var i
                    var k
                    var copiedOp
                    var currentOp
                    var modified = []
                    
                    if (array.length === 0) return setTimeout(callback, 0)
                    
                    for (i = 0; i < array.length; i++) {
                        copiedOp = {}
                        currentOp = array[i]
                        modified[i] = copiedOp
                        
                        var converted = this.convertEncoding(currentOp.key, currentOp.value, options)
                        currentOp.key = converted.key
                        currentOp.value = converted.value
                        
                        for (k in currentOp) {
                            if (k === 'type' && currentOp[k] == 'del') {
                                copiedOp[k] = 'remove'
                            } else {
                                copiedOp[k] = currentOp[k]
                            }
                        }
                    }
                    
                    return this.idb.batch(modified, function () { callback() }, callback)
                }
                
                Level.prototype._close = function (callback) {
                    this.idb.db.close()
                    callback()
                }
                
                Level.prototype._approximateSize = function (start, end, callback) {
                    var err = new Error('Not implemented')
                    if (callback)
                        return callback(err)
                    
                    throw err
                }
                
                Level.prototype._isBuffer = function (obj) {
                    return Buffer.isBuffer(obj)
                }
                
                Level.destroy = function (db, callback) {
                    if (typeof db === 'object') {
                        var prefix = db.IDBOptions.storePrefix || 'IDBWrapper-'
                        var dbname = db.location
                    } else {
                        var prefix = 'IDBWrapper-'
                        var dbname = db
                    }
                    var request = indexedDB.deleteDatabase(prefix + dbname)
                    request.onsuccess = function () {
                        callback()
                    }
                    request.onerror = function (err) {
                        callback(err)
                    }
                }
                
                var checkKeyValue = Level.prototype._checkKeyValue = function (obj, type) {
                    if (obj === null || obj === undefined)
                        return new Error(type + ' cannot be `null` or `undefined`')
                    if (obj === null || obj === undefined)
                        return new Error(type + ' cannot be `null` or `undefined`')
                    if (isBuffer(obj) && obj.byteLength === 0)
                        return new Error(type + ' cannot be an empty ArrayBuffer')
                    if (String(obj) === '')
                        return new Error(type + ' cannot be an empty String')
                    if (obj.length === 0)
                        return new Error(type + ' cannot be an empty Array')
                }

            }).call(this, require("buffer").Buffer)
        }, { "./iterator": 60, "abstract-leveldown": 63, "buffer": 172, "idb-wrapper": 65, "isbuffer": 66, "typedarray-to-buffer": 68, "util": 342, "xtend": 70 }], 60: [function (require, module, exports) {
            var util = require('util')
            var AbstractIterator = require('abstract-leveldown').AbstractIterator
            var ltgt = require('ltgt')
            
            module.exports = Iterator
            
            function Iterator(db, options) {
                if (!options) options = {}
                this.options = options
                AbstractIterator.call(this, db)
                this._order = options.reverse ? 'DESC': 'ASC'
                this._limit = options.limit
                this._count = 0
                this._done = false
                var lower = ltgt.lowerBound(options)
                var upper = ltgt.upperBound(options)
                this._keyRange = lower || upper ? this.db.makeKeyRange({
                    lower: lower,
                    upper: upper,
                    excludeLower: ltgt.lowerBoundExclusive(options),
                    excludeUpper: ltgt.upperBoundExclusive(options)
                }) : null
                this.callback = null
            }
            
            util.inherits(Iterator, AbstractIterator)
            
            Iterator.prototype.createIterator = function () {
                var self = this
                
                self.iterator = self.db.iterate(function () {
                    self.onItem.apply(self, arguments)
                }, {
                    keyRange: self._keyRange,
                    autoContinue: false,
                    order: self._order,
                    onError: function (err) { console.log('horrible error', err) },
                })
            }
            
            // TODO the limit implementation here just ignores all reads after limit has been reached
            // it should cancel the iterator instead but I don't know how
            Iterator.prototype.onItem = function (value, cursor, cursorTransaction) {
                if (!cursor && this.callback) {
                    this.callback()
                    this.callback = false
                    return
                }
                var shouldCall = true
                
                if (!!this._limit && this._limit > 0 && this._count++ >= this._limit)
                    shouldCall = false
                
                if (shouldCall) this.callback(false, cursor.key, cursor.value)
                if (cursor) cursor['continue']()
            }
            
            Iterator.prototype._next = function (callback) {
                if (!callback) return new Error('next() requires a callback argument')
                if (!this._started) {
                    this.createIterator()
                    this._started = true
                }
                this.callback = callback
            }

        }, { "abstract-leveldown": 63, "ltgt": 67, "util": 342 }], 61: [function (require, module, exports) {
            (function (process) {
                /* Copyright (c) 2013 Rod Vagg, MIT License */
                
                function AbstractChainedBatch(db) {
                    this._db = db
                    this._operations = []
                    this._written = false
                }
                
                AbstractChainedBatch.prototype._checkWritten = function () {
                    if (this._written)
                        throw new Error('write() already called on this batch')
                }
                
                AbstractChainedBatch.prototype.put = function (key, value) {
                    this._checkWritten()
                    
                    var err = this._db._checkKeyValue(key, 'key', this._db._isBuffer)
                    if (err) throw err
                    err = this._db._checkKeyValue(value, 'value', this._db._isBuffer)
                    if (err) throw err
                    
                    if (!this._db._isBuffer(key)) key = String(key)
                    if (!this._db._isBuffer(value)) value = String(value)
                    
                    if (typeof this._put == 'function')
                        this._put(key, value)
                    else
                        this._operations.push({ type: 'put', key: key, value: value })
                    
                    return this
                }
                
                AbstractChainedBatch.prototype.del = function (key) {
                    this._checkWritten()
                    
                    var err = this._db._checkKeyValue(key, 'key', this._db._isBuffer)
                    if (err) throw err
                    
                    if (!this._db._isBuffer(key)) key = String(key)
                    
                    if (typeof this._del == 'function')
                        this._del(key)
                    else
                        this._operations.push({ type: 'del', key: key })
                    
                    return this
                }
                
                AbstractChainedBatch.prototype.clear = function () {
                    this._checkWritten()
                    
                    this._operations = []
                    
                    if (typeof this._clear == 'function')
                        this._clear()
                    
                    return this
                }
                
                AbstractChainedBatch.prototype.write = function (options, callback) {
                    this._checkWritten()
                    
                    if (typeof options == 'function')
                        callback = options
                    if (typeof callback != 'function')
                        throw new Error('write() requires a callback argument')
                    if (typeof options != 'object')
                        options = {}
                    
                    this._written = true
                    
                    if (typeof this._write == 'function')
                        return this._write(callback)
                    
                    if (typeof this._db._batch == 'function')
                        return this._db._batch(this._operations, options, callback)
                    
                    process.nextTick(callback)
                }
                
                module.exports = AbstractChainedBatch
            }).call(this, require('_process'))
        }, { "_process": 322 }], 62: [function (require, module, exports) {
            (function (process) {
                /* Copyright (c) 2013 Rod Vagg, MIT License */
                
                function AbstractIterator(db) {
                    this.db = db
                    this._ended = false
                    this._nexting = false
                }
                
                AbstractIterator.prototype.next = function (callback) {
                    var self = this
                    
                    if (typeof callback != 'function')
                        throw new Error('next() requires a callback argument')
                    
                    if (self._ended)
                        return callback(new Error('cannot call next() after end()'))
                    if (self._nexting)
                        return callback(new Error('cannot call next() before previous next() has completed'))
                    
                    self._nexting = true
                    if (typeof self._next == 'function') {
                        return self._next(function () {
                            self._nexting = false
                            callback.apply(null, arguments)
                        })
                    }
                    
                    process.nextTick(function () {
                        self._nexting = false
                        callback()
                    })
                }
                
                AbstractIterator.prototype.end = function (callback) {
                    if (typeof callback != 'function')
                        throw new Error('end() requires a callback argument')
                    
                    if (this._ended)
                        return callback(new Error('end() already called on iterator'))
                    
                    this._ended = true
                    
                    if (typeof this._end == 'function')
                        return this._end(callback)
                    
                    process.nextTick(callback)
                }
                
                module.exports = AbstractIterator

            }).call(this, require('_process'))
        }, { "_process": 322 }], 63: [function (require, module, exports) {
            (function (process, Buffer) {
                /* Copyright (c) 2013 Rod Vagg, MIT License */
                
                var xtend = require('xtend')
  , AbstractIterator = require('./abstract-iterator')
  , AbstractChainedBatch = require('./abstract-chained-batch')
                
                function AbstractLevelDOWN(location) {
                    if (!arguments.length || location === undefined)
                        throw new Error('constructor requires at least a location argument')
                    
                    if (typeof location != 'string')
                        throw new Error('constructor requires a location string argument')
                    
                    this.location = location
                }
                
                AbstractLevelDOWN.prototype.open = function (options, callback) {
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('open() requires a callback argument')
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    if (typeof this._open == 'function')
                        return this._open(options, callback)
                    
                    process.nextTick(callback)
                }
                
                AbstractLevelDOWN.prototype.close = function (callback) {
                    if (typeof callback != 'function')
                        throw new Error('close() requires a callback argument')
                    
                    if (typeof this._close == 'function')
                        return this._close(callback)
                    
                    process.nextTick(callback)
                }
                
                AbstractLevelDOWN.prototype.get = function (key, options, callback) {
                    var err
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('get() requires a callback argument')
                    
                    if (err = this._checkKeyValue(key, 'key', this._isBuffer))
                        return callback(err)
                    
                    if (!this._isBuffer(key))
                        key = String(key)
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    if (typeof this._get == 'function')
                        return this._get(key, options, callback)
                    
                    process.nextTick(function () { callback(new Error('NotFound')) })
                }
                
                AbstractLevelDOWN.prototype.put = function (key, value, options, callback) {
                    var err
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('put() requires a callback argument')
                    
                    if (err = this._checkKeyValue(key, 'key', this._isBuffer))
                        return callback(err)
                    
                    if (err = this._checkKeyValue(value, 'value', this._isBuffer))
                        return callback(err)
                    
                    if (!this._isBuffer(key))
                        key = String(key)
                    
                    // coerce value to string in node, don't touch it in browser
                    // (indexeddb can store any JS type)
                    if (!this._isBuffer(value) && !process.browser)
                        value = String(value)
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    if (typeof this._put == 'function')
                        return this._put(key, value, options, callback)
                    
                    process.nextTick(callback)
                }
                
                AbstractLevelDOWN.prototype.del = function (key, options, callback) {
                    var err
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('del() requires a callback argument')
                    
                    if (err = this._checkKeyValue(key, 'key', this._isBuffer))
                        return callback(err)
                    
                    if (!this._isBuffer(key))
                        key = String(key)
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    if (typeof this._del == 'function')
                        return this._del(key, options, callback)
                    
                    process.nextTick(callback)
                }
                
                AbstractLevelDOWN.prototype.batch = function (array, options, callback) {
                    if (!arguments.length)
                        return this._chainedBatch()
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('batch(array) requires a callback argument')
                    
                    if (!Array.isArray(array))
                        return callback(new Error('batch(array) requires an array argument'))
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    var i = 0
    , l = array.length
    , e
    , err
                    
                    for (; i < l; i++) {
                        e = array[i]
                        if (typeof e != 'object')
                            continue
                        
                        if (err = this._checkKeyValue(e.type, 'type', this._isBuffer))
                            return callback(err)
                        
                        if (err = this._checkKeyValue(e.key, 'key', this._isBuffer))
                            return callback(err)
                        
                        if (e.type == 'put') {
                            if (err = this._checkKeyValue(e.value, 'value', this._isBuffer))
                                return callback(err)
                        }
                    }
                    
                    if (typeof this._batch == 'function')
                        return this._batch(array, options, callback)
                    
                    process.nextTick(callback)
                }
                
                //TODO: remove from here, not a necessary primitive
                AbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {
                    if (start == null 
      || end == null 
      || typeof start == 'function' 
      || typeof end == 'function') {
                        throw new Error('approximateSize() requires valid `start`, `end` and `callback` arguments')
                    }
                    
                    if (typeof callback != 'function')
                        throw new Error('approximateSize() requires a callback argument')
                    
                    if (!this._isBuffer(start))
                        start = String(start)
                    
                    if (!this._isBuffer(end))
                        end = String(end)
                    
                    if (typeof this._approximateSize == 'function')
                        return this._approximateSize(start, end, callback)
                    
                    process.nextTick(function () {
                        callback(null, 0)
                    })
                }
                
                AbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {
                    var self = this
                    
                    options = xtend(options)

                    ; ['start', 'end', 'gt', 'gte', 'lt', 'lte'].forEach(function (o) {
                        if (options[o] && self._isBuffer(options[o]) && options[o].length === 0)
                            delete options[o]
                    })
                    
                    options.reverse = !!options.reverse
                    
                    // fix `start` so it takes into account gt, gte, lt, lte as appropriate
                    if (options.reverse && options.lt)
                        options.start = options.lt
                    if (options.reverse && options.lte)
                        options.start = options.lte
                    if (!options.reverse && options.gt)
                        options.start = options.gt
                    if (!options.reverse && options.gte)
                        options.start = options.gte
                    
                    if ((options.reverse && options.lt && !options.lte) 
                        || (!options.reverse && options.gt && !options.gte))
                        options.exclusiveStart = true // start should *not* include matching key
                    
                    return options
                }
                
                AbstractLevelDOWN.prototype.iterator = function (options) {
                    if (typeof options != 'object')
                        options = {}
                    
                    options = this._setupIteratorOptions(options)
                    
                    if (typeof this._iterator == 'function')
                        return this._iterator(options)
                    
                    return new AbstractIterator(this)
                }
                
                AbstractLevelDOWN.prototype._chainedBatch = function () {
                    return new AbstractChainedBatch(this)
                }
                
                AbstractLevelDOWN.prototype._isBuffer = function (obj) {
                    return Buffer.isBuffer(obj)
                }
                
                AbstractLevelDOWN.prototype._checkKeyValue = function (obj, type) {
                    
                    if (obj === null || obj === undefined)
                        return new Error(type + ' cannot be `null` or `undefined`')
                    
                    if (this._isBuffer(obj)) {
                        if (obj.length === 0)
                            return new Error(type + ' cannot be an empty Buffer')
                    } else if (String(obj) === '')
                        return new Error(type + ' cannot be an empty String')
                }
                
                module.exports.AbstractLevelDOWN = AbstractLevelDOWN
                module.exports.AbstractIterator = AbstractIterator
                module.exports.AbstractChainedBatch = AbstractChainedBatch

            }).call(this, require('_process'), require("buffer").Buffer)
        }, { "./abstract-chained-batch": 61, "./abstract-iterator": 62, "_process": 322, "buffer": 172, "xtend": 64 }], 64: [function (require, module, exports) {
            module.exports = extend
            
            function extend() {
                var target = {}
                
                for (var i = 0; i < arguments.length; i++) {
                    var source = arguments[i]
                    
                    for (var key in source) {
                        if (source.hasOwnProperty(key)) {
                            target[key] = source[key]
                        }
                    }
                }
                
                return target
            }

        }, {}], 65: [function (require, module, exports) {
            /*global window:false, self:false, define:false, module:false */
            
            /**
 * @license IDBWrapper - A cross-browser wrapper for IndexedDB
 * Copyright (c) 2011 - 2013 Jens Arps
 * http://jensarps.de/
 *
 * Licensed under the MIT (X11) license
 */

(function (name, definition, global) {
                if (typeof define === 'function') {
                    define(definition);
                } else if (typeof module !== 'undefined' && module.exports) {
                    module.exports = definition();
                } else {
                    global[name] = definition();
                }
            })('IDBStore', function () {
                
                'use strict';
                
                var defaultErrorHandler = function (error) {
                    throw error;
                };
                
                var defaults = {
                    storeName: 'Store',
                    storePrefix: 'IDBWrapper-',
                    dbVersion: 1,
                    keyPath: 'id',
                    autoIncrement: true,
                    onStoreReady: function () {
                    },
                    onError: defaultErrorHandler,
                    indexes: []
                };
                
                /**
   *
   * The IDBStore constructor
   *
   * @constructor
   * @name IDBStore
   * @version 1.4.1
   *
   * @param {Object} [kwArgs] An options object used to configure the store and
   *  set callbacks
   * @param {String} [kwArgs.storeName='Store'] The name of the store
   * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is
   *  internally used to construct the name of the database, which will be
   *  kwArgs.storePrefix + kwArgs.storeName
   * @param {Number} [kwArgs.dbVersion=1] The version of the store
   * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to
   *  setup IDBWrapper to work with out-of-line keys, you need to set this to
   *  `null`
   * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will
   *  automatically make sure a unique keyPath value is present on each object
   *  that is stored.
   * @param {Function} [kwArgs.onStoreReady] A callback to be called when the
   *  store is ready to be used.
   * @param {Function} [kwArgs.onError=throw] A callback to be called when an
   *  error occurred during instantiation of the store.
   * @param {Array} [kwArgs.indexes=[]] An array of indexData objects
   *  defining the indexes to use with the store. For every index to be used
   *  one indexData object needs to be passed in the array.
   *  An indexData object is defined as follows:
   * @param {Object} [kwArgs.indexes.indexData] An object defining the index to
   *  use
   * @param {String} kwArgs.indexes.indexData.name The name of the index
   * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index
   * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique
   * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry
   * @param {Function} [onStoreReady] A callback to be called when the store
   * is ready to be used.
   * @example
      // create a store for customers with an additional index over the
      // `lastname` property.
      var myCustomerStore = new IDBStore({
        dbVersion: 1,
        storeName: 'customer-index',
        keyPath: 'customerid',
        autoIncrement: true,
        onStoreReady: populateTable,
        indexes: [
          { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }
        ]
      });
   * @example
      // create a generic store
      var myCustomerStore = new IDBStore({
        storeName: 'my-data-store',
        onStoreReady: function(){
          // start working with the store.
        }
      });
   */
  var IDBStore = function (kwArgs, onStoreReady) {
                    
                    if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {
                        onStoreReady = kwArgs;
                    }
                    if (Object.prototype.toString.call(kwArgs) != '[object Object]') {
                        kwArgs = {};
                    }
                    
                    for (var key in defaults) {
                        this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];
                    }
                    
                    this.dbName = this.storePrefix + this.storeName;
                    this.dbVersion = parseInt(this.dbVersion, 10) || 1;
                    
                    onStoreReady && (this.onStoreReady = onStoreReady);
                    
                    var env = typeof window == 'object' ? window : self;
                    this.idb = env.indexedDB || env.webkitIndexedDB || env.mozIndexedDB;
                    this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;
                    
                    this.features = {
                        hasAutoIncrement: !env.mozIndexedDB
                    };
                    
                    this.consts = {
                        'READ_ONLY': 'readonly',
                        'READ_WRITE': 'readwrite',
                        'VERSION_CHANGE': 'versionchange',
                        'NEXT': 'next',
                        'NEXT_NO_DUPLICATE': 'nextunique',
                        'PREV': 'prev',
                        'PREV_NO_DUPLICATE': 'prevunique'
                    };
                    
                    this.openDB();
                };
                
                IDBStore.prototype = /** @lends IDBStore */ {
                    
                    /**
     * A pointer to the IDBStore ctor
     *
     * @type IDBStore
     */
    constructor: IDBStore,
                    
                    /**
     * The version of IDBStore
     *
     * @type String
     */
    version: '1.4.1',
                    
                    /**
     * A reference to the IndexedDB object
     *
     * @type Object
     */
    db: null,
                    
                    /**
     * The full name of the IndexedDB used by IDBStore, composed of
     * this.storePrefix + this.storeName
     *
     * @type String
     */
    dbName: null,
                    
                    /**
     * The version of the IndexedDB used by IDBStore
     *
     * @type Number
     */
    dbVersion: null,
                    
                    /**
     * A reference to the objectStore used by IDBStore
     *
     * @type Object
     */
    store: null,
                    
                    /**
     * The store name
     *
     * @type String
     */
    storeName: null,
                    
                    /**
     * The key path
     *
     * @type String
     */
    keyPath: null,
                    
                    /**
     * Whether IDBStore uses autoIncrement
     *
     * @type Boolean
     */
    autoIncrement: null,
                    
                    /**
     * The indexes used by IDBStore
     *
     * @type Array
     */
    indexes: null,
                    
                    /**
     * A hashmap of features of the used IDB implementation
     *
     * @type Object
     * @proprty {Boolean} autoIncrement If the implementation supports
     *  native auto increment
     */
    features: null,
                    
                    /**
     * The callback to be called when the store is ready to be used
     *
     * @type Function
     */
    onStoreReady: null,
                    
                    /**
     * The callback to be called if an error occurred during instantiation
     * of the store
     *
     * @type Function
     */
    onError: null,
                    
                    /**
     * The internal insertID counter
     *
     * @type Number
     * @private
     */
    _insertIdCount: 0,
                    
                    /**
     * Opens an IndexedDB; called by the constructor.
     *
     * Will check if versions match and compare provided index configuration
     * with existing ones, and update indexes if necessary.
     *
     * Will call this.onStoreReady() if everything went well and the store
     * is ready to use, and this.onError() is something went wrong.
     *
     * @private
     *
     */
    openDB: function () {
                        
                        var openRequest = this.idb.open(this.dbName, this.dbVersion);
                        var preventSuccessCallback = false;
                        
                        openRequest.onerror = function (error) {
                            
                            var gotVersionErr = false;
                            if ('error' in error.target) {
                                gotVersionErr = error.target.error.name == 'VersionError';
                            } else if ('errorCode' in error.target) {
                                gotVersionErr = error.target.errorCode == 12;
                            }
                            
                            if (gotVersionErr) {
                                this.onError(new Error('The version number provided is lower than the existing one.'));
                            } else {
                                this.onError(error);
                            }
                        }.bind(this);
                        
                        openRequest.onsuccess = function (event) {
                            
                            if (preventSuccessCallback) {
                                return;
                            }
                            
                            if (this.db) {
                                this.onStoreReady();
                                return;
                            }
                            
                            this.db = event.target.result;
                            
                            if (typeof this.db.version == 'string') {
                                this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));
                                return;
                            }
                            
                            if (!this.db.objectStoreNames.contains(this.storeName)) {
                                // We should never ever get here.
                                // Lets notify the user anyway.
                                this.onError(new Error('Something is wrong with the IndexedDB implementation in this browser. Please upgrade your browser.'));
                                return;
                            }
                            
                            var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
                            this.store = emptyTransaction.objectStore(this.storeName);
                            
                            // check indexes
                            var existingIndexes = Array.prototype.slice.call(this.getIndexList());
                            this.indexes.forEach(function (indexData) {
                                var indexName = indexData.name;
                                
                                if (!indexName) {
                                    preventSuccessCallback = true;
                                    this.onError(new Error('Cannot create index: No index name given.'));
                                    return;
                                }
                                
                                this.normalizeIndexData(indexData);
                                
                                if (this.hasIndex(indexName)) {
                                    // check if it complies
                                    var actualIndex = this.store.index(indexName);
                                    var complies = this.indexComplies(actualIndex, indexData);
                                    if (!complies) {
                                        preventSuccessCallback = true;
                                        this.onError(new Error('Cannot modify index "' + indexName + '" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));
                                    }
                                    
                                    existingIndexes.splice(existingIndexes.indexOf(indexName), 1);
                                } else {
                                    preventSuccessCallback = true;
                                    this.onError(new Error('Cannot create new index "' + indexName + '" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));
                                }

                            }, this);
                            
                            if (existingIndexes.length) {
                                preventSuccessCallback = true;
                                this.onError(new Error('Cannot delete index(es) "' + existingIndexes.toString() + '" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));
                            }
                            
                            preventSuccessCallback || this.onStoreReady();
                        }.bind(this);
                        
                        openRequest.onupgradeneeded = function (/* IDBVersionChangeEvent */ event) {
                            
                            this.db = event.target.result;
                            
                            if (this.db.objectStoreNames.contains(this.storeName)) {
                                this.store = event.target.transaction.objectStore(this.storeName);
                            } else {
                                var optionalParameters = { autoIncrement: this.autoIncrement };
                                if (this.keyPath !== null) {
                                    optionalParameters.keyPath = this.keyPath;
                                }
                                this.store = this.db.createObjectStore(this.storeName, optionalParameters);
                            }
                            
                            var existingIndexes = Array.prototype.slice.call(this.getIndexList());
                            this.indexes.forEach(function (indexData) {
                                var indexName = indexData.name;
                                
                                if (!indexName) {
                                    preventSuccessCallback = true;
                                    this.onError(new Error('Cannot create index: No index name given.'));
                                }
                                
                                this.normalizeIndexData(indexData);
                                
                                if (this.hasIndex(indexName)) {
                                    // check if it complies
                                    var actualIndex = this.store.index(indexName);
                                    var complies = this.indexComplies(actualIndex, indexData);
                                    if (!complies) {
                                        // index differs, need to delete and re-create
                                        this.store.deleteIndex(indexName);
                                        this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });
                                    }
                                    
                                    existingIndexes.splice(existingIndexes.indexOf(indexName), 1);
                                } else {
                                    this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });
                                }

                            }, this);
                            
                            if (existingIndexes.length) {
                                existingIndexes.forEach(function (_indexName) {
                                    this.store.deleteIndex(_indexName);
                                }, this);
                            }

                        }.bind(this);
                    },
                    
                    /**
     * Deletes the database used for this store if the IDB implementations
     * provides that functionality.
     */
    deleteDatabase: function () {
                        if (this.idb.deleteDatabase) {
                            this.idb.deleteDatabase(this.dbName);
                        }
                    },
                    
                    /*********************
     * data manipulation *
     *********************/

    /**
     * Puts an object into the store. If an entry with the given id exists,
     * it will be overwritten. This method has a different signature for inline
     * keys and out-of-line keys; please see the examples below.
     *
     * @param {*} [key] The key to store. This is only needed if IDBWrapper
     *  is set to use out-of-line keys. For inline keys - the default scenario -
     *  this can be omitted.
     * @param {Object} value The data object to store.
     * @param {Function} [onSuccess] A callback that is called if insertion
     *  was successful.
     * @param {Function} [onError] A callback that is called if insertion
     *  failed.
     * @returns {IDBTransaction} The transaction used for this operation.
     * @example
        // Storing an object, using inline keys (the default scenario):
        var myCustomer = {
          customerid: 2346223,
          lastname: 'Doe',
          firstname: 'John'
        };
        myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);
        // Note that passing success- and error-handlers is optional.
     * @example
        // Storing an object, using out-of-line keys:
       var myCustomer = {
         lastname: 'Doe',
         firstname: 'John'
       };
       myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);
      // Note that passing success- and error-handlers is optional.
     */
    put: function (key, value, onSuccess, onError) {
                        if (this.keyPath !== null) {
                            onError = onSuccess;
                            onSuccess = value;
                            value = key;
                        }
                        onError || (onError = defaultErrorHandler);
                        onSuccess || (onSuccess = noop);
                        
                        var hasSuccess = false,
                            result = null,
                            putRequest;
                        
                        var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);
                        putTransaction.oncomplete = function () {
                            var callback = hasSuccess ? onSuccess : onError;
                            callback(result);
                        };
                        putTransaction.onabort = onError;
                        putTransaction.onerror = onError;
                        
                        if (this.keyPath !== null) { // in-line keys
                            this._addIdPropertyIfNeeded(value);
                            putRequest = putTransaction.objectStore(this.storeName).put(value);
                        } else { // out-of-line keys
                            putRequest = putTransaction.objectStore(this.storeName).put(value, key);
                        }
                        putRequest.onsuccess = function (event) {
                            hasSuccess = true;
                            result = event.target.result;
                        };
                        putRequest.onerror = onError;
                        
                        return putTransaction;
                    },
                    
                    /**
     * Retrieves an object from the store. If no entry exists with the given id,
     * the success handler will be called with null as first and only argument.
     *
     * @param {*} key The id of the object to fetch.
     * @param {Function} [onSuccess] A callback that is called if fetching
     *  was successful. Will receive the object as only argument.
     * @param {Function} [onError] A callback that will be called if an error
     *  occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    get: function (key, onSuccess, onError) {
                        onError || (onError = defaultErrorHandler);
                        onSuccess || (onSuccess = noop);
                        
                        var hasSuccess = false,
                            result = null;
                        
                        var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
                        getTransaction.oncomplete = function () {
                            var callback = hasSuccess ? onSuccess : onError;
                            callback(result);
                        };
                        getTransaction.onabort = onError;
                        getTransaction.onerror = onError;
                        var getRequest = getTransaction.objectStore(this.storeName).get(key);
                        getRequest.onsuccess = function (event) {
                            hasSuccess = true;
                            result = event.target.result;
                        };
                        getRequest.onerror = onError;
                        
                        return getTransaction;
                    },
                    
                    /**
     * Removes an object from the store.
     *
     * @param {*} key The id of the object to remove.
     * @param {Function} [onSuccess] A callback that is called if the removal
     *  was successful.
     * @param {Function} [onError] A callback that will be called if an error
     *  occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    remove: function (key, onSuccess, onError) {
                        onError || (onError = defaultErrorHandler);
                        onSuccess || (onSuccess = noop);
                        
                        var hasSuccess = false,
                            result = null;
                        
                        var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);
                        removeTransaction.oncomplete = function () {
                            var callback = hasSuccess ? onSuccess : onError;
                            callback(result);
                        };
                        removeTransaction.onabort = onError;
                        removeTransaction.onerror = onError;
                        
                        var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);
                        deleteRequest.onsuccess = function (event) {
                            hasSuccess = true;
                            result = event.target.result;
                        };
                        deleteRequest.onerror = onError;
                        
                        return removeTransaction;
                    },
                    
                    /**
     * Runs a batch of put and/or remove operations on the store.
     *
     * @param {Array} dataArray An array of objects containing the operation to run
     *  and the data object (for put operations).
     * @param {Function} [onSuccess] A callback that is called if all operations
     *  were successful.
     * @param {Function} [onError] A callback that is called if an error
     *  occurred during one of the operations.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    batch: function (dataArray, onSuccess, onError) {
                        onError || (onError = defaultErrorHandler);
                        onSuccess || (onSuccess = noop);
                        
                        if (Object.prototype.toString.call(dataArray) != '[object Array]') {
                            onError(new Error('dataArray argument must be of type Array.'));
                        }
                        var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_WRITE);
                        batchTransaction.oncomplete = function () {
                            var callback = hasSuccess ? onSuccess : onError;
                            callback(hasSuccess);
                        };
                        batchTransaction.onabort = onError;
                        batchTransaction.onerror = onError;
                        
                        var count = dataArray.length;
                        var called = false;
                        var hasSuccess = false;
                        
                        var onItemSuccess = function () {
                            count--;
                            if (count === 0 && !called) {
                                called = true;
                                hasSuccess = true;
                            }
                        };
                        
                        dataArray.forEach(function (operation) {
                            var type = operation.type;
                            var key = operation.key;
                            var value = operation.value;
                            
                            var onItemError = function (err) {
                                batchTransaction.abort();
                                if (!called) {
                                    called = true;
                                    onError(err, type, key);
                                }
                            };
                            
                            if (type == 'remove') {
                                var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);
                                deleteRequest.onsuccess = onItemSuccess;
                                deleteRequest.onerror = onItemError;
                            } else if (type == 'put') {
                                var putRequest;
                                if (this.keyPath !== null) { // in-line keys
                                    this._addIdPropertyIfNeeded(value);
                                    putRequest = batchTransaction.objectStore(this.storeName).put(value);
                                } else { // out-of-line keys
                                    putRequest = batchTransaction.objectStore(this.storeName).put(value, key);
                                }
                                putRequest.onsuccess = onItemSuccess;
                                putRequest.onerror = onItemError;
                            }
                        }, this);
                        
                        return batchTransaction;
                    },
                    
                    /**
     * Takes an array of objects and stores them in a single transaction.
     *
     * @param {Array} dataArray An array of objects to store
     * @param {Function} [onSuccess] A callback that is called if all operations
     *  were successful.
     * @param {Function} [onError] A callback that is called if an error
     *  occurred during one of the operations.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    putBatch: function (dataArray, onSuccess, onError) {
                        var batchData = dataArray.map(function (item) {
                            return { type: 'put', value: item };
                        });
                        
                        return this.batch(batchData, onSuccess, onError);
                    },
                    
                    /**
     * Takes an array of keys and removes matching objects in a single
     * transaction.
     *
     * @param {Array} keyArray An array of keys to remove
     * @param {Function} [onSuccess] A callback that is called if all operations
     *  were successful.
     * @param {Function} [onError] A callback that is called if an error
     *  occurred during one of the operations.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    removeBatch: function (keyArray, onSuccess, onError) {
                        var batchData = keyArray.map(function (key) {
                            return { type: 'remove', key: key };
                        });
                        
                        return this.batch(batchData, onSuccess, onError);
                    },
                    
                    /**
     * Takes an array of keys and fetches matching objects
     *
     * @param {Array} keyArray An array of keys identifying the objects to fetch
     * @param {Function} [onSuccess] A callback that is called if all operations
     *  were successful.
     * @param {Function} [onError] A callback that is called if an error
     *  occurred during one of the operations.
     * @param {String} [arrayType='sparse'] The type of array to pass to the
     *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to
     *  'sparse'. This parameter specifies how to handle the situation if a get
     *  operation did not throw an error, but there was no matching object in
     *  the database. In most cases, 'sparse' provides the most desired
     *  behavior. See the examples for details.
     * @returns {IDBTransaction} The transaction used for this operation.
     * @example
     // given that there are two objects in the database with the keypath
     // values 1 and 2, and the call looks like this:
     myStore.getBatch([1, 5, 2], onError, function (data) { â€¦ }, arrayType);

     // this is what the `data` array will be like:

     // arrayType == 'sparse':
     // data is a sparse array containing two entries and having a length of 3:
       [Object, 2: Object]
         0: Object
         2: Object
         length: 3
         __proto__: Array[0]
     // calling forEach on data will result in the callback being called two
     // times, with the index parameter matching the index of the key in the
     // keyArray.

     // arrayType == 'dense':
     // data is a dense array containing three entries and having a length of 3,
     // where data[1] is of type undefined:
       [Object, undefined, Object]
         0: Object
         1: undefined
         2: Object
         length: 3
         __proto__: Array[0]
     // calling forEach on data will result in the callback being called three
     // times, with the index parameter matching the index of the key in the
     // keyArray, but the second call will have undefined as first argument.

     // arrayType == 'skip':
     // data is a dense array containing two entries and having a length of 2:
       [Object, Object]
         0: Object
         1: Object
         length: 2
         __proto__: Array[0]
     // calling forEach on data will result in the callback being called two
     // times, with the index parameter not matching the index of the key in the
     // keyArray.
     */
    getBatch: function (keyArray, onSuccess, onError, arrayType) {
                        onError || (onError = defaultErrorHandler);
                        onSuccess || (onSuccess = noop);
                        arrayType || (arrayType = 'sparse');
                        
                        if (Object.prototype.toString.call(keyArray) != '[object Array]') {
                            onError(new Error('keyArray argument must be of type Array.'));
                        }
                        var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_ONLY);
                        batchTransaction.oncomplete = function () {
                            var callback = hasSuccess ? onSuccess : onError;
                            callback(result);
                        };
                        batchTransaction.onabort = onError;
                        batchTransaction.onerror = onError;
                        
                        var data = [];
                        var count = keyArray.length;
                        var called = false;
                        var hasSuccess = false;
                        var result = null;
                        
                        var onItemSuccess = function (event) {
                            if (event.target.result || arrayType == 'dense') {
                                data.push(event.target.result);
                            } else if (arrayType == 'sparse') {
                                data.length++;
                            }
                            count--;
                            if (count === 0) {
                                called = true;
                                hasSuccess = true;
                                result = data;
                            }
                        };
                        
                        keyArray.forEach(function (key) {
                            
                            var onItemError = function (err) {
                                called = true;
                                result = err;
                                onError(err);
                                batchTransaction.abort();
                            };
                            
                            var getRequest = batchTransaction.objectStore(this.storeName).get(key);
                            getRequest.onsuccess = onItemSuccess;
                            getRequest.onerror = onItemError;

                        }, this);
                        
                        return batchTransaction;
                    },
                    
                    /**
     * Fetches all entries in the store.
     *
     * @param {Function} [onSuccess] A callback that is called if the operation
     *  was successful. Will receive an array of objects.
     * @param {Function} [onError] A callback that will be called if an error
     *  occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    getAll: function (onSuccess, onError) {
                        onError || (onError = defaultErrorHandler);
                        onSuccess || (onSuccess = noop);
                        var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
                        var store = getAllTransaction.objectStore(this.storeName);
                        if (store.getAll) {
                            this._getAllNative(getAllTransaction, store, onSuccess, onError);
                        } else {
                            this._getAllCursor(getAllTransaction, store, onSuccess, onError);
                        }
                        
                        return getAllTransaction;
                    },
                    
                    /**
     * Implements getAll for IDB implementations that have a non-standard
     * getAll() method.
     *
     * @param {Object} getAllTransaction An open READ transaction.
     * @param {Object} store A reference to the store.
     * @param {Function} onSuccess A callback that will be called if the
     *  operation was successful.
     * @param {Function} onError A callback that will be called if an
     *  error occurred during the operation.
     * @private
     */
    _getAllNative: function (getAllTransaction, store, onSuccess, onError) {
                        var hasSuccess = false,
                            result = null;
                        
                        getAllTransaction.oncomplete = function () {
                            var callback = hasSuccess ? onSuccess : onError;
                            callback(result);
                        };
                        getAllTransaction.onabort = onError;
                        getAllTransaction.onerror = onError;
                        
                        var getAllRequest = store.getAll();
                        getAllRequest.onsuccess = function (event) {
                            hasSuccess = true;
                            result = event.target.result;
                        };
                        getAllRequest.onerror = onError;
                    },
                    
                    /**
     * Implements getAll for IDB implementations that do not have a getAll()
     * method.
     *
     * @param {Object} getAllTransaction An open READ transaction.
     * @param {Object} store A reference to the store.
     * @param {Function} onSuccess A callback that will be called if the
     *  operation was successful.
     * @param {Function} onError A callback that will be called if an
     *  error occurred during the operation.
     * @private
     */
    _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {
                        var all = [],
                            hasSuccess = false,
                            result = null;
                        
                        getAllTransaction.oncomplete = function () {
                            var callback = hasSuccess ? onSuccess : onError;
                            callback(result);
                        };
                        getAllTransaction.onabort = onError;
                        getAllTransaction.onerror = onError;
                        
                        var cursorRequest = store.openCursor();
                        cursorRequest.onsuccess = function (event) {
                            var cursor = event.target.result;
                            if (cursor) {
                                all.push(cursor.value);
                                cursor['continue']();
                            }
                            else {
                                hasSuccess = true;
                                result = all;
                            }
                        };
                        cursorRequest.onError = onError;
                    },
                    
                    /**
     * Clears the store, i.e. deletes all entries in the store.
     *
     * @param {Function} [onSuccess] A callback that will be called if the
     *  operation was successful.
     * @param {Function} [onError] A callback that will be called if an
     *  error occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    clear: function (onSuccess, onError) {
                        onError || (onError = defaultErrorHandler);
                        onSuccess || (onSuccess = noop);
                        
                        var hasSuccess = false,
                            result = null;
                        
                        var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);
                        clearTransaction.oncomplete = function () {
                            var callback = hasSuccess ? onSuccess : onError;
                            callback(result);
                        };
                        clearTransaction.onabort = onError;
                        clearTransaction.onerror = onError;
                        
                        var clearRequest = clearTransaction.objectStore(this.storeName).clear();
                        clearRequest.onsuccess = function (event) {
                            hasSuccess = true;
                            result = event.target.result;
                        };
                        clearRequest.onerror = onError;
                        
                        return clearTransaction;
                    },
                    
                    /**
     * Checks if an id property needs to present on a object and adds one if
     * necessary.
     *
     * @param {Object} dataObj The data object that is about to be stored
     * @private
     */
    _addIdPropertyIfNeeded: function (dataObj) {
                        if (!this.features.hasAutoIncrement && typeof dataObj[this.keyPath] == 'undefined') {
                            dataObj[this.keyPath] = this._insertIdCount++ + Date.now();
                        }
                    },
                    
                    /************
     * indexing *
     ************/

    /**
     * Returns a DOMStringList of index names of the store.
     *
     * @return {DOMStringList} The list of index names
     */
    getIndexList: function () {
                        return this.store.indexNames;
                    },
                    
                    /**
     * Checks if an index with the given name exists in the store.
     *
     * @param {String} indexName The name of the index to look for
     * @return {Boolean} Whether the store contains an index with the given name
     */
    hasIndex: function (indexName) {
                        return this.store.indexNames.contains(indexName);
                    },
                    
                    /**
     * Normalizes an object containing index data and assures that all
     * properties are set.
     *
     * @param {Object} indexData The index data object to normalize
     * @param {String} indexData.name The name of the index
     * @param {String} [indexData.keyPath] The key path of the index
     * @param {Boolean} [indexData.unique] Whether the index is unique
     * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry
     */
    normalizeIndexData: function (indexData) {
                        indexData.keyPath = indexData.keyPath || indexData.name;
                        indexData.unique = !!indexData.unique;
                        indexData.multiEntry = !!indexData.multiEntry;
                    },
                    
                    /**
     * Checks if an actual index complies with an expected index.
     *
     * @param {Object} actual The actual index found in the store
     * @param {Object} expected An Object describing an expected index
     * @return {Boolean} Whether both index definitions are identical
     */
    indexComplies: function (actual, expected) {
                        var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {
                            // IE10 returns undefined for no multiEntry
                            if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {
                                return true;
                            }
                            // Compound keys
                            if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {
                                var exp = expected.keyPath;
                                var act = actual.keyPath;
                                
                                // IE10 can't handle keyPath sequences and stores them as a string.
                                // The index will be unusable there, but let's still return true if
                                // the keyPath sequence matches.
                                if (typeof act == 'string') {
                                    return exp.toString() == act;
                                }
                                
                                // Chrome/Opera stores keyPath squences as DOMStringList, Firefox
                                // as Array
                                if (!(typeof act.contains == 'function' || typeof act.indexOf == 'function')) {
                                    return false;
                                }
                                
                                if (act.length !== exp.length) {
                                    return false;
                                }
                                
                                for (var i = 0, m = exp.length; i < m; i++) {
                                    if (!((act.contains && act.contains(exp[i])) || act.indexOf(exp[i] !== -1))) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                            return expected[key] == actual[key];
                        });
                        return complies;
                    },
                    
                    /**********
     * cursor *
     **********/

    /**
     * Iterates over the store using the given options and calling onItem
     * for each entry matching the options.
     *
     * @param {Function} onItem A callback to be called for each match
     * @param {Object} [options] An object defining specific options
     * @param {Object} [options.index=null] An IDBIndex to operate on
     * @param {String} [options.order=ASC] The order in which to provide the
     *  results, can be 'DESC' or 'ASC'
     * @param {Boolean} [options.autoContinue=true] Whether to automatically
     *  iterate the cursor to the next result
     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude
     *  duplicate matches
     * @param {Object} [options.keyRange=null] An IDBKeyRange to use
     * @param {Boolean} [options.writeAccess=false] Whether grant write access
     *  to the store in the onItem callback
     * @param {Function} [options.onEnd=null] A callback to be called after
     *  iteration has ended
     * @param {Function} [options.onError=throw] A callback to be called
     *  if an error occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    iterate: function (onItem, options) {
                        options = mixin({
                            index: null,
                            order: 'ASC',
                            autoContinue: true,
                            filterDuplicates: false,
                            keyRange: null,
                            writeAccess: false,
                            onEnd: null,
                            onError: defaultErrorHandler
                        }, options || {});
                        
                        var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';
                        if (options.filterDuplicates) {
                            directionType += '_NO_DUPLICATE';
                        }
                        
                        var hasSuccess = false;
                        var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);
                        var cursorTarget = cursorTransaction.objectStore(this.storeName);
                        if (options.index) {
                            cursorTarget = cursorTarget.index(options.index);
                        }
                        
                        cursorTransaction.oncomplete = function () {
                            if (!hasSuccess) {
                                options.onError(null);
                                return;
                            }
                            if (options.onEnd) {
                                options.onEnd();
                            } else {
                                onItem(null);
                            }
                        };
                        cursorTransaction.onabort = options.onError;
                        cursorTransaction.onerror = options.onError;
                        
                        var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);
                        cursorRequest.onerror = options.onError;
                        cursorRequest.onsuccess = function (event) {
                            var cursor = event.target.result;
                            if (cursor) {
                                onItem(cursor.value, cursor, cursorTransaction);
                                if (options.autoContinue) {
                                    cursor['continue']();
                                }
                            } else {
                                hasSuccess = true;
                            }
                        };
                        
                        return cursorTransaction;
                    },
                    
                    /**
     * Runs a query against the store and passes an array containing matched
     * objects to the success handler.
     *
     * @param {Function} onSuccess A callback to be called when the operation
     *  was successful.
     * @param {Object} [options] An object defining specific query options
     * @param {Object} [options.index=null] An IDBIndex to operate on
     * @param {String} [options.order=ASC] The order in which to provide the
     *  results, can be 'DESC' or 'ASC'
     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude
     *  duplicate matches
     * @param {Object} [options.keyRange=null] An IDBKeyRange to use
     * @param {Function} [options.onError=throw] A callback to be called if an error
     *  occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    query: function (onSuccess, options) {
                        var result = [];
                        options = options || {};
                        options.onEnd = function () {
                            onSuccess(result);
                        };
                        return this.iterate(function (item) {
                            result.push(item);
                        }, options);
                    },
                    
                    /**
     *
     * Runs a query against the store, but only returns the number of matches
     * instead of the matches itself.
     *
     * @param {Function} onSuccess A callback to be called if the opration
     *  was successful.
     * @param {Object} [options] An object defining specific options
     * @param {Object} [options.index=null] An IDBIndex to operate on
     * @param {Object} [options.keyRange=null] An IDBKeyRange to use
     * @param {Function} [options.onError=throw] A callback to be called if an error
     *  occurred during the operation.
     * @returns {IDBTransaction} The transaction used for this operation.
     */
    count: function (onSuccess, options) {
                        
                        options = mixin({
                            index: null,
                            keyRange: null
                        }, options || {});
                        
                        var onError = options.onError || defaultErrorHandler;
                        
                        var hasSuccess = false,
                            result = null;
                        
                        var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
                        cursorTransaction.oncomplete = function () {
                            var callback = hasSuccess ? onSuccess : onError;
                            callback(result);
                        };
                        cursorTransaction.onabort = onError;
                        cursorTransaction.onerror = onError;
                        
                        var cursorTarget = cursorTransaction.objectStore(this.storeName);
                        if (options.index) {
                            cursorTarget = cursorTarget.index(options.index);
                        }
                        var countRequest = cursorTarget.count(options.keyRange);
                        countRequest.onsuccess = function (evt) {
                            hasSuccess = true;
                            result = evt.target.result;
                        };
                        countRequest.onError = onError;
                        
                        return cursorTransaction;
                    },
                    
                    /**************/
                    /* key ranges */
                    /**************/
                    
                    /**
     * Creates a key range using specified options. This key range can be
     * handed over to the count() and iterate() methods.
     *
     * Note: You must provide at least one or both of "lower" or "upper" value.
     *
     * @param {Object} options The options for the key range to create
     * @param {*} [options.lower] The lower bound
     * @param {Boolean} [options.excludeLower] Whether to exclude the lower
     *  bound passed in options.lower from the key range
     * @param {*} [options.upper] The upper bound
     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper
     *  bound passed in options.upper from the key range
     * @param {*} [options.only] A single key value. Use this if you need a key
     *  range that only includes one value for a key. Providing this
     *  property invalidates all other properties.
     * @return {Object} The IDBKeyRange representing the specified options
     */
    makeKeyRange: function (options) {
                        /*jshint onecase:true */
                        var keyRange,
                            hasLower = typeof options.lower != 'undefined',
                            hasUpper = typeof options.upper != 'undefined',
                            isOnly = typeof options.only != 'undefined';
                        
                        switch (true) {
                            case isOnly:
                                keyRange = this.keyRange.only(options.only);
                                break;
                            case hasLower && hasUpper:
                                keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);
                                break;
                            case hasLower:
                                keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);
                                break;
                            case hasUpper:
                                keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);
                                break;
                            default:
                                throw new Error('Cannot create KeyRange. Provide one or both of "lower" or "upper" value, or an "only" value.');
                        }
                        
                        return keyRange;

                    }

                };
                
                /** helpers **/
                
                var noop = function () {
                };
                var empty = {};
                var mixin = function (target, source) {
                    var name, s;
                    for (name in source) {
                        s = source[name];
                        if (s !== empty[name] && s !== target[name]) {
                            target[name] = s;
                        }
                    }
                    return target;
                };
                
                IDBStore.version = IDBStore.prototype.version;
                
                return IDBStore;

            }, this);

        }, {}], 66: [function (require, module, exports) {
            var Buffer = require('buffer').Buffer;
            
            module.exports = isBuffer;
            
            function isBuffer(o) {
                return Buffer.isBuffer(o) 
    || /\[object (.+Array|Array.+)\]/.test(Object.prototype.toString.call(o));
            }

        }, { "buffer": 172 }], 67: [function (require, module, exports) {
            (function (Buffer) {
                
                exports.compare = function (a, b) {
                    
                    if (Buffer.isBuffer(a)) {
                        var l = Math.min(a.length, b.length)
                        for (var i = 0; i < l; i++) {
                            var cmp = a[i] - b[i]
                            if (cmp) return cmp
                        }
                        return a.length - b.length
                    }
                    
                    return a < b ? -1 : a > b ? 1 : 0
                }
                
                function has(obj, key) {
                    return Object.hasOwnProperty.call(obj, key)
                }
                
                // to be compatible with the current abstract-leveldown tests
                // nullish or empty strings.
                // I could use !!val but I want to permit numbers and booleans,
                // if possible.
                
                function isDef(val) {
                    return val !== undefined && val !== ''
                }
                
                function has(range, name) {
                    return Object.hasOwnProperty.call(range, name)
                }
                
                function hasKey(range, name) {
                    return Object.hasOwnProperty.call(range, name) && name
                }
                
                var lowerBoundKey = exports.lowerBoundKey = function (range) {
                    return (
       hasKey(range, 'gt') 
    || hasKey(range, 'gte') 
    || hasKey(range, 'min') 
    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start')) 
    || undefined
)
                }
                
                var lowerBound = exports.lowerBound = function (range) {
                    var k = lowerBoundKey(range)
                    return k && range[k]
                    return (
      has(range, 'gt')                      ? range.gt
    : has(range, 'gte')                     ? range.gte
    : has(range, 'min')                     ? range.min
    : has(range, 'start') && !range.reverse ? range.start
    : has(range, 'end') && range.reverse  ? range.end
    :                                         undefined
)
                }
                
                exports.lowerBoundInclusive = function (range) {
                    return has(range, 'gt') ? false : true
                }
                
                exports.upperBoundInclusive =
  function (range) {
                    return has(range, 'lt') || !range.minEx ? false : true
                }
                
                var lowerBoundExclusive = exports.lowerBoundExclusive =
  function (range) {
                    return has(range, 'gt') || range.minEx ? true : false
                }
                
                var upperBoundExclusive = exports.upperBoundExclusive =
  function (range) {
                    return has(range, 'lt') ? true : false
                }
                
                var upperBoundKey = exports.upperBoundKey = function (range) {
                    return (
       hasKey(range, 'lt') 
    || hasKey(range, 'lte') 
    || hasKey(range, 'max') 
    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end')) 
    || undefined
)
                }
                
                var upperBound = exports.upperBound = function (range) {
                    var k = upperBoundKey(range)
                    return k && range[k]
                }
                
                function id(e) { return e }
                
                exports.toLtgt = function (range, _range, map, lower, upper) {
                    _range = _range || {}
                    map = map || id
                    var defaults = arguments.length > 3
                    var lb = exports.lowerBoundKey(range)
                    var ub = exports.upperBoundKey(range)
                    if (lb) {
                        if (lb === 'gt') _range.gt = map(range.gt)
                        else _range.gte = map(range[lb])
                    }
                    else if (defaults)
                        _range.gte = lower
                    
                    if (ub) {
                        if (ub === 'lt') _range.lt = map(range.lt)
                        else _range.lte = map(range[ub])
                    }
                    else if (defaults)
                        _range.lte = upper
                    
                    _range.reverse = !!range.reverse
                    
                    return _range
                }
                
                exports.contains = function (range, key, compare) {
                    compare = compare || exports.compare
                    
                    var lb = lowerBound(range)
                    if (isDef(lb)) {
                        var cmp = compare(key, lb)
                        if (cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))
                            return false
                    }
                    
                    var ub = upperBound(range)
                    if (isDef(ub)) {
                        var cmp = compare(key, ub)
                        if (cmp > 0 || (cmp === 0) && upperBoundExclusive(range))
                            return false
                    }
                    
                    return true
                }
                
                exports.filter = function (range, compare) {
                    return function (key) {
                        return exports.contains(range, key, compare)
                    }
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 68: [function (require, module, exports) {
            (function (Buffer) {
                /**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

module.exports = function (arr) {
                    if (typeof Buffer._augment === 'function' && Buffer.TYPED_ARRAY_SUPPORT) {
                        // If `Buffer` is from the `buffer` module and this browser supports typed arrays,
                        // then augment it with all the `Buffer` methods.
                        return Buffer._augment(arr)
                    } else {
                        // Otherwise, fallback to creating a `Buffer` with a copy.
                        return new Buffer(arr)
                    }
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 69: [function (require, module, exports) {
            module.exports = hasKeys
            
            function hasKeys(source) {
                return source !== null &&
        (typeof source === "object" ||
        typeof source === "function")
            }

        }, {}], 70: [function (require, module, exports) {
            var Keys = require("object-keys")
            var hasKeys = require("./has-keys")
            
            module.exports = extend
            
            function extend() {
                var target = {}
                
                for (var i = 0; i < arguments.length; i++) {
                    var source = arguments[i]
                    
                    if (!hasKeys(source)) {
                        continue
                    }
                    
                    var keys = Keys(source)
                    
                    for (var j = 0; j < keys.length; j++) {
                        var name = keys[j]
                        target[name] = source[name]
                    }
                }
                
                return target
            }

        }, { "./has-keys": 69, "object-keys": 72 }], 71: [function (require, module, exports) {
            var hasOwn = Object.prototype.hasOwnProperty;
            var toString = Object.prototype.toString;
            
            var isFunction = function (fn) {
                var isFunc = (typeof fn === 'function' && !(fn instanceof RegExp)) || toString.call(fn) === '[object Function]';
                if (!isFunc && typeof window !== 'undefined') {
                    isFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;
                }
                return isFunc;
            };
            
            module.exports = function forEach(obj, fn) {
                if (!isFunction(fn)) {
                    throw new TypeError('iterator must be a function');
                }
                var i, k,
                    isString = typeof obj === 'string',
                    l = obj.length,
                    context = arguments.length > 2 ? arguments[2] : null;
                if (l === +l) {
                    for (i = 0; i < l; i++) {
                        if (context === null) {
                            fn(isString ? obj.charAt(i) : obj[i], i, obj);
                        } else {
                            fn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);
                        }
                    }
                } else {
                    for (k in obj) {
                        if (hasOwn.call(obj, k)) {
                            if (context === null) {
                                fn(obj[k], k, obj);
                            } else {
                                fn.call(context, obj[k], k, obj);
                            }
                        }
                    }
                }
            };


        }, {}], 72: [function (require, module, exports) {
            module.exports = Object.keys || require('./shim');


        }, { "./shim": 74 }], 73: [function (require, module, exports) {
            var toString = Object.prototype.toString;
            
            module.exports = function isArguments(value) {
                var str = toString.call(value);
                var isArguments = str === '[object Arguments]';
                if (!isArguments) {
                    isArguments = str !== '[object Array]' 
			&& value !== null 
			&& typeof value === 'object' 
			&& typeof value.length === 'number' 
			&& value.length >= 0 
			&& toString.call(value.callee) === '[object Function]';
                }
                return isArguments;
            };


        }, {}], 74: [function (require, module, exports) {
            (function () {
                "use strict";
                
                // modified from https://github.com/kriskowal/es5-shim
                var has = Object.prototype.hasOwnProperty,
                    toString = Object.prototype.toString,
                    forEach = require('./foreach'),
                    isArgs = require('./isArguments'),
                    hasDontEnumBug = !({ 'toString': null }).propertyIsEnumerable('toString'),
                    hasProtoEnumBug = (function () { }).propertyIsEnumerable('prototype'),
                    dontEnums = [
                        "toString",
                        "toLocaleString",
                        "valueOf",
                        "hasOwnProperty",
                        "isPrototypeOf",
                        "propertyIsEnumerable",
                        "constructor"
                    ],
                    keysShim;
                
                keysShim = function keys(object) {
                    var isObject = object !== null && typeof object === 'object',
                        isFunction = toString.call(object) === '[object Function]',
                        isArguments = isArgs(object),
                        theKeys = [];
                    
                    if (!isObject && !isFunction && !isArguments) {
                        throw new TypeError("Object.keys called on a non-object");
                    }
                    
                    if (isArguments) {
                        forEach(object, function (value) {
                            theKeys.push(value);
                        });
                    } else {
                        var name,
                            skipProto = hasProtoEnumBug && isFunction;
                        
                        for (name in object) {
                            if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                                theKeys.push(name);
                            }
                        }
                    }
                    
                    if (hasDontEnumBug) {
                        var ctor = object.constructor,
                            skipConstructor = ctor && ctor.prototype === object;
                        
                        forEach(dontEnums, function (dontEnum) {
                            if (!(skipConstructor && dontEnum === 'constructor') && has.call(object, dontEnum)) {
                                theKeys.push(dontEnum);
                            }
                        });
                    }
                    return theKeys;
                };
                
                module.exports = keysShim;
            }());


        }, { "./foreach": 71, "./isArguments": 73 }], 75: [function (require, module, exports) {
            const util                 = require('util')
    , AbstractChainedBatch = require('abstract-leveldown').AbstractChainedBatch
            
            
            function ChainedBatch(db) {
                AbstractChainedBatch.call(this, db)
                this.binding = db.binding.batch()
            }
            
            
            ChainedBatch.prototype._put = function (key, value) {
                this.binding.put(key, value)
            }
            
            
            ChainedBatch.prototype._del = function (key) {
                this.binding.del(key)
            }
            
            
            ChainedBatch.prototype._clear = function (key) {
                this.binding.clear(key)
            }
            
            
            ChainedBatch.prototype._write = function (options, callback) {
                this.binding.write(options, callback)
            }
            
            util.inherits(ChainedBatch, AbstractChainedBatch)
            
            
            module.exports = ChainedBatch
        }, { "abstract-leveldown": 81, "util": 342 }], 76: [function (require, module, exports) {
            const util             = require('util')
    , AbstractIterator = require('abstract-leveldown').AbstractIterator
            
            
            function Iterator(db, options) {
                AbstractIterator.call(this, db)
                
                this.binding = db.binding.iterator(options)
                this.cache = null
                this.finished = false
                this.fastFuture = require('fast-future')()
            }
            
            util.inherits(Iterator, AbstractIterator)
            
            Iterator.prototype.seek = function (key) {
                if (typeof key !== 'string')
                    throw new Error('seek requires a string key')
                this.cache = null
                this.binding.seek(key)
            }
            
            Iterator.prototype._next = function (callback) {
                var that = this
    , key
    , value
                
                if (this.cache && this.cache.length) {
                    key = this.cache.pop()
                    value = this.cache.pop()
                    
                    this.fastFuture(function () {
                        callback(null, key, value)
                    })

                } else if (this.finished) {
                    this.fastFuture(function () {
                        callback()
                    })
                } else {
                    this.binding.next(function (err, array, finished) {
                        if (err) return callback(err)
                        
                        that.cache = array
                        that.finished = finished
                        that._next(callback)
                    })
                }
                
                return this
            }
            
            
            Iterator.prototype._end = function (callback) {
                delete this.cache
                this.binding.end(callback)
            }
            
            
            module.exports = Iterator

        }, { "abstract-leveldown": 81, "fast-future": 84, "util": 342 }], 77: [function (require, module, exports) {
            const util              = require('util')
    , AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN

    , binding           = require('./prebuilt')

    , ChainedBatch      = require('./chained-batch')
    , Iterator          = require('./iterator')
            
            
            function LevelDOWN(location) {
                if (!(this instanceof LevelDOWN))
                    return new LevelDOWN(location)
                
                AbstractLevelDOWN.call(this, location)
                this.binding = binding(location)
            }
            
            util.inherits(LevelDOWN, AbstractLevelDOWN)
            
            
            LevelDOWN.prototype._open = function (options, callback) {
                this.binding.open(options, callback)
            }
            
            
            LevelDOWN.prototype._close = function (callback) {
                this.binding.close(callback)
            }
            
            
            LevelDOWN.prototype._put = function (key, value, options, callback) {
                this.binding.put(key, value, options, callback)
            }
            
            
            LevelDOWN.prototype._get = function (key, options, callback) {
                this.binding.get(key, options, callback)
            }
            
            
            LevelDOWN.prototype._del = function (key, options, callback) {
                this.binding.del(key, options, callback)
            }
            
            
            LevelDOWN.prototype._chainedBatch = function () {
                return new ChainedBatch(this)
            }
            
            
            LevelDOWN.prototype._batch = function (operations, options, callback) {
                return this.binding.batch(operations, options, callback)
            }
            
            
            LevelDOWN.prototype._approximateSize = function (start, end, callback) {
                this.binding.approximateSize(start, end, callback)
            }
            
            
            LevelDOWN.prototype.getProperty = function (property) {
                if (typeof property != 'string')
                    throw new Error('getProperty() requires a valid `property` argument')
                
                return this.binding.getProperty(property)
            }
            
            
            LevelDOWN.prototype._iterator = function (options) {
                return new Iterator(this, options)
            }
            
            
            LevelDOWN.destroy = function (location, callback) {
                if (arguments.length < 2)
                    throw new Error('destroy() requires `location` and `callback` arguments')
                
                if (typeof location != 'string')
                    throw new Error('destroy() requires a location string argument')
                
                if (typeof callback != 'function')
                    throw new Error('destroy() requires a callback function argument')
                
                binding.destroy(location, callback)
            }
            
            
            LevelDOWN.repair = function (location, callback) {
                if (arguments.length < 2)
                    throw new Error('repair() requires `location` and `callback` arguments')
                
                if (typeof location != 'string')
                    throw new Error('repair() requires a location string argument')
                
                if (typeof callback != 'function')
                    throw new Error('repair() requires a callback function argument')
                
                binding.repair(location, callback)
            }
            
            
            module.exports = LevelDOWN
        }, { "./chained-batch": 75, "./iterator": 76, "./prebuilt": 122, "abstract-leveldown": 81, "util": 342 }], 78: [function (require, module, exports) {
            (function (process) {
                /* Copyright (c) 2013 Rod Vagg, MIT License */
                
                function AbstractChainedBatch(db) {
                    this._db = db
                    this._operations = []
                    this._written = false
                }
                
                AbstractChainedBatch.prototype._checkWritten = function () {
                    if (this._written)
                        throw new Error('write() already called on this batch')
                }
                
                AbstractChainedBatch.prototype.put = function (key, value) {
                    this._checkWritten()
                    
                    var err = this._db._checkKey(key, 'key', this._db._isBuffer)
                    if (err)
                        throw err
                    
                    if (!this._db._isBuffer(key)) key = String(key)
                    if (!this._db._isBuffer(value)) value = String(value)
                    
                    if (typeof this._put == 'function')
                        this._put(key, value)
                    else
                        this._operations.push({ type: 'put', key: key, value: value })
                    
                    return this
                }
                
                AbstractChainedBatch.prototype.del = function (key) {
                    this._checkWritten()
                    
                    var err = this._db._checkKey(key, 'key', this._db._isBuffer)
                    if (err) throw err
                    
                    if (!this._db._isBuffer(key)) key = String(key)
                    
                    if (typeof this._del == 'function')
                        this._del(key)
                    else
                        this._operations.push({ type: 'del', key: key })
                    
                    return this
                }
                
                AbstractChainedBatch.prototype.clear = function () {
                    this._checkWritten()
                    
                    this._operations = []
                    
                    if (typeof this._clear == 'function')
                        this._clear()
                    
                    return this
                }
                
                AbstractChainedBatch.prototype.write = function (options, callback) {
                    this._checkWritten()
                    
                    if (typeof options == 'function')
                        callback = options
                    if (typeof callback != 'function')
                        throw new Error('write() requires a callback argument')
                    if (typeof options != 'object')
                        options = {}
                    
                    this._written = true
                    
                    if (typeof this._write == 'function')
                        return this._write(callback)
                    
                    if (typeof this._db._batch == 'function')
                        return this._db._batch(this._operations, options, callback)
                    
                    process.nextTick(callback)
                }
                
                module.exports = AbstractChainedBatch
            }).call(this, require('_process'))
        }, { "_process": 322 }], 79: [function (require, module, exports) {
            arguments[4][62][0].apply(exports, arguments)
        }, { "_process": 322, "dup": 62 }], 80: [function (require, module, exports) {
            (function (process, Buffer) {
                /* Copyright (c) 2013 Rod Vagg, MIT License */
                
                var xtend = require('xtend')
  , AbstractIterator = require('./abstract-iterator')
  , AbstractChainedBatch = require('./abstract-chained-batch')
                
                function AbstractLevelDOWN(location) {
                    if (!arguments.length || location === undefined)
                        throw new Error('constructor requires at least a location argument')
                    
                    if (typeof location != 'string')
                        throw new Error('constructor requires a location string argument')
                    
                    this.location = location
                    this.status = 'new'
                }
                
                AbstractLevelDOWN.prototype.open = function (options, callback) {
                    var self = this
    , oldStatus = this.status
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('open() requires a callback argument')
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    options.createIfMissing = options.createIfMissing != false
                    options.errorIfExists = !!options.errorIfExists
                    
                    if (typeof this._open == 'function') {
                        this.status = 'opening'
                        this._open(options, function (err) {
                            if (err) {
                                self.status = oldStatus
                                return callback(err)
                            }
                            self.status = 'open'
                            callback()
                        })
                    } else {
                        this.status = 'open'
                        process.nextTick(callback)
                    }
                }
                
                AbstractLevelDOWN.prototype.close = function (callback) {
                    var self = this
    , oldStatus = this.status
                    
                    if (typeof callback != 'function')
                        throw new Error('close() requires a callback argument')
                    
                    if (typeof this._close == 'function') {
                        this.status = 'closing'
                        this._close(function (err) {
                            if (err) {
                                self.status = oldStatus
                                return callback(err)
                            }
                            self.status = 'closed'
                            callback()
                        })
                    } else {
                        this.status = 'closed'
                        process.nextTick(callback)
                    }
                }
                
                AbstractLevelDOWN.prototype.get = function (key, options, callback) {
                    var err
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('get() requires a callback argument')
                    
                    if (err = this._checkKey(key, 'key', this._isBuffer))
                        return callback(err)
                    
                    if (!this._isBuffer(key))
                        key = String(key)
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    options.asBuffer = options.asBuffer != false
                    
                    if (typeof this._get == 'function')
                        return this._get(key, options, callback)
                    
                    process.nextTick(function () { callback(new Error('NotFound')) })
                }
                
                AbstractLevelDOWN.prototype.put = function (key, value, options, callback) {
                    var err
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('put() requires a callback argument')
                    
                    if (err = this._checkKey(key, 'key', this._isBuffer))
                        return callback(err)
                    
                    if (!this._isBuffer(key))
                        key = String(key)
                    
                    // coerce value to string in node, don't touch it in browser
                    // (indexeddb can store any JS type)
                    if (value != null && !this._isBuffer(value) && !process.browser)
                        value = String(value)
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    if (typeof this._put == 'function')
                        return this._put(key, value, options, callback)
                    
                    process.nextTick(callback)
                }
                
                AbstractLevelDOWN.prototype.del = function (key, options, callback) {
                    var err
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('del() requires a callback argument')
                    
                    if (err = this._checkKey(key, 'key', this._isBuffer))
                        return callback(err)
                    
                    if (!this._isBuffer(key))
                        key = String(key)
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    if (typeof this._del == 'function')
                        return this._del(key, options, callback)
                    
                    process.nextTick(callback)
                }
                
                AbstractLevelDOWN.prototype.batch = function (array, options, callback) {
                    if (!arguments.length)
                        return this._chainedBatch()
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof array == 'function')
                        callback = array
                    
                    if (typeof callback != 'function')
                        throw new Error('batch(array) requires a callback argument')
                    
                    if (!Array.isArray(array))
                        return callback(new Error('batch(array) requires an array argument'))
                    
                    if (!options || typeof options != 'object')
                        options = {}
                    
                    var i = 0
    , l = array.length
    , e
    , err
                    
                    for (; i < l; i++) {
                        e = array[i]
                        if (typeof e != 'object')
                            continue
                        
                        if (err = this._checkKey(e.type, 'type', this._isBuffer))
                            return callback(err)
                        
                        if (err = this._checkKey(e.key, 'key', this._isBuffer))
                            return callback(err)
                    }
                    
                    if (typeof this._batch == 'function')
                        return this._batch(array, options, callback)
                    
                    process.nextTick(callback)
                }
                
                //TODO: remove from here, not a necessary primitive
                AbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {
                    if (start == null 
      || end == null 
      || typeof start == 'function' 
      || typeof end == 'function') {
                        throw new Error('approximateSize() requires valid `start`, `end` and `callback` arguments')
                    }
                    
                    if (typeof callback != 'function')
                        throw new Error('approximateSize() requires a callback argument')
                    
                    if (!this._isBuffer(start))
                        start = String(start)
                    
                    if (!this._isBuffer(end))
                        end = String(end)
                    
                    if (typeof this._approximateSize == 'function')
                        return this._approximateSize(start, end, callback)
                    
                    process.nextTick(function () {
                        callback(null, 0)
                    })
                }
                
                AbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {
                    var self = this
                    
                    options = xtend(options)

                    ; ['start', 'end', 'gt', 'gte', 'lt', 'lte'].forEach(function (o) {
                        if (options[o] && self._isBuffer(options[o]) && options[o].length === 0)
                            delete options[o]
                    })
                    
                    options.reverse = !!options.reverse
                    options.keys = options.keys != false
                    options.values = options.values != false
                    options.limit = 'limit' in options ? options.limit : -1
                    options.keyAsBuffer = options.keyAsBuffer != false
                    options.valueAsBuffer = options.valueAsBuffer != false
                    
                    return options
                }
                
                AbstractLevelDOWN.prototype.iterator = function (options) {
                    if (typeof options != 'object')
                        options = {}
                    
                    options = this._setupIteratorOptions(options)
                    
                    if (typeof this._iterator == 'function')
                        return this._iterator(options)
                    
                    return new AbstractIterator(this)
                }
                
                AbstractLevelDOWN.prototype._chainedBatch = function () {
                    return new AbstractChainedBatch(this)
                }
                
                AbstractLevelDOWN.prototype._isBuffer = function (obj) {
                    return Buffer.isBuffer(obj)
                }
                
                AbstractLevelDOWN.prototype._checkKey = function (obj, type) {
                    
                    if (obj === null || obj === undefined)
                        return new Error(type + ' cannot be `null` or `undefined`')
                    
                    if (this._isBuffer(obj)) {
                        if (obj.length === 0)
                            return new Error(type + ' cannot be an empty Buffer')
                    } else if (String(obj) === '')
                        return new Error(type + ' cannot be an empty String')
                }
                
                module.exports = AbstractLevelDOWN

            }).call(this, require('_process'), require("buffer").Buffer)
        }, { "./abstract-chained-batch": 78, "./abstract-iterator": 79, "_process": 322, "buffer": 172, "xtend": 83 }], 81: [function (require, module, exports) {
            exports.AbstractLevelDOWN = require('./abstract-leveldown')
            exports.AbstractIterator = require('./abstract-iterator')
            exports.AbstractChainedBatch = require('./abstract-chained-batch')
            exports.isLevelDOWN = require('./is-leveldown')

        }, { "./abstract-chained-batch": 78, "./abstract-iterator": 79, "./abstract-leveldown": 80, "./is-leveldown": 82 }], 82: [function (require, module, exports) {
            const AbstractLevelDOWN = require('./abstract-leveldown')
            
            function isLevelDOWN(db) {
                if (!db || typeof db !== 'object')
                    return false
                return Object.keys(AbstractLevelDOWN.prototype).filter(function (name) {
                    // TODO remove approximateSize check when method is gone
                    return name[0] != '_' && name != 'approximateSize'
                }).every(function (name) {
                    return typeof db[name] == 'function'
                })
            }
            
            module.exports = isLevelDOWN

        }, { "./abstract-leveldown": 80 }], 83: [function (require, module, exports) {
            arguments[4][64][0].apply(exports, arguments)
        }, { "dup": 64 }], 84: [function (require, module, exports) {
            (function (process, global) {
                var LIMIT = process.maxTickDepth / 2
  , factory = function () {
                        var count = 0
                        return function (callback) {
                            if (count >= LIMIT) {
                                global.setImmediate(callback)
                                count = 0
                            } else
                                process.nextTick(callback)
                            count++
                        }
                    }
                
                module.exports = global.setImmediate ? factory : function () { return process.nextTick }
            }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, { "_process": 322 }], 85: [function (require, module, exports) {
            (function (process, __dirname) {
                "use strict";
                
                /**
 * Module exports.
 */

module.exports = exports;
                
                /**
 * Module dependencies.
 */

var path = require('path');
                var nopt = require('nopt');
                var log = require('npmlog');
                var EE = require('events').EventEmitter;
                var inherits = require('util').inherits;
                var commands = [
                    'clean',
                    'install',
                    'reinstall',
                    'build',
                    'rebuild',
                    'package',
                    'testpackage',
                    'publish',
                    'unpublish',
                    'info',
                    'testbinary',
                    'reveal',
                    'configure'
                ];
                var aliases = {};
                
                // differentiate node-pre-gyp's logs from npm's
                log.heading = 'node-pre-gyp';
                
                exports.find = require('./pre-binding').find;
                
                function Run() {
                    var self = this;
                    
                    this.commands = {};
                    
                    commands.forEach(function (command) {
                        self.commands[command] = function (argv, callback) {
                            log.verbose('command', command, argv);
                            return require('./' + command)(self, argv, callback);
                        };
                    });
                }
                inherits(Run, EE);
                exports.Run = Run;
                var proto = Run.prototype;
                
                /**
 * Export the contents of the package.json.
 */

proto.package = require('../package');
                
                /**
 * nopt configuration definitions
 */

proto.configDefs = {
                    help: Boolean,     // everywhere
                    arch: String,      // 'configure'
                    debug: Boolean,    // 'build'
                    directory: String, // bin
                    proxy: String,     // 'install'
                    loglevel: String,  // everywhere
                };
                
                /**
 * nopt shorthands
 */

proto.shorthands = {
                    release: '--no-debug',
                    C: '--directory',
                    debug: '--debug',
                    j: '--jobs',
                    silent: '--loglevel=silent',
                    silly: '--loglevel=silly',
                    verbose: '--loglevel=verbose',
                };
                
                /**
 * expose the command aliases for the bin file to use.
 */

proto.aliases = aliases;
                
                /**
 * Parses the given argv array and sets the 'opts',
 * 'argv' and 'command' properties.
 */

proto.parseArgv = function parseOpts(argv) {
                    this.opts = nopt(this.configDefs, this.shorthands, argv);
                    this.argv = this.opts.argv.remain.slice();
                    var commands = this.todo = [];
                    
                    // create a copy of the argv array with aliases mapped
                    argv = this.argv.map(function (arg) {
                        // is this an alias?
                        if (arg in this.aliases) {
                            arg = this.aliases[arg];
                        }
                        return arg;
                    }, this);
                    
                    // process the mapped args into "command" objects ("name" and "args" props)
                    argv.slice().forEach(function (arg) {
                        if (arg in this.commands) {
                            var args = argv.splice(0, argv.indexOf(arg));
                            argv.shift();
                            if (commands.length > 0) {
                                commands[commands.length - 1].args = args;
                            }
                            commands.push({ name: arg, args: [] });
                        }
                    }, this);
                    if (commands.length > 0) {
                        commands[commands.length - 1].args = argv.splice(0);
                    }
                    
                    // support for inheriting config env variables from npm
                    var npm_config_prefix = 'npm_config_';
                    Object.keys(process.env).forEach(function (name) {
                        if (name.indexOf(npm_config_prefix) !== 0) return;
                        var val = process.env[name];
                        if (name === npm_config_prefix + 'loglevel') {
                            log.level = val;
                        } else {
                            // add the user-defined options to the config
                            name = name.substring(npm_config_prefix.length);
                            // avoid npm argv clobber already present args
                            // which avoids problem of 'npm test' calling
                            // script that runs unique npm install commands
                            if (name === 'argv') {
                                if (this.opts.argv &&
             this.opts.argv.remain &&
             this.opts.argv.remain.length) {
            // do nothing
                                } else {
                                    this.opts[name] = val;
                                }
                            } else {
                                this.opts[name] = val;
                            }
                        }
                    }, this);
                    
                    if (this.opts.loglevel) {
                        log.level = this.opts.loglevel;
                    }
                    log.resume();
                };
                
                /**
 * Returns the usage instructions for node-pre-gyp.
 */

proto.usage = function usage() {
                    var str = [
                        '',
                        '  Usage: node-pre-gyp <command> [options]',
                        '',
                        '  where <command> is one of:',
                        commands.map(function (c) {
                            return '    - ' + c + ' - ' + require('./' + c).usage;
                        }).join('\n'),
                        '',
                        'node-pre-gyp@' + this.version + '  ' + path.resolve(__dirname, '..'),
                        'node@' + process.versions.node
                    ].join('\n');
                    return str;
                };
                
                /**
 * Version number getter.
 */

Object.defineProperty(proto, 'version', {
                    get: function () {
                        return this.package.version;
                    },
                    enumerable: true
                });


            }).call(this, require('_process'), "/../node_modules/leveldown/node_modules/node-pre-gyp/lib")
        }, { "../package": 121, "./pre-binding": 86, "_process": 322, "events": 317, "nopt": 89, "npmlog": 91, "path": 321, "util": 342 }], 86: [function (require, module, exports) {
            "use strict";
            
            var versioning = require('../lib/util/versioning.js');
            var existsSync = require('fs').existsSync || require('path').existsSync;
            var path = require('path');
            
            module.exports = exports;
            
            exports.usage = 'Finds the require path for the node-pre-gyp installed module';
            
            exports.validate = function (package_json) {
                versioning.validate_config(package_json);
            };
            
            exports.find = function (package_json_path, opts) {
                if (!existsSync(package_json_path)) {
                    throw new Error("package.json does not exist at " + package_json_path);
                }
                var package_json = require(package_json_path);
                versioning.validate_config(package_json);
                opts = opts || {};
                if (!opts.module_root) opts.module_root = path.dirname(package_json_path);
                var meta = versioning.evaluate(package_json, opts);
                return meta.module;
            };

        }, { "../lib/util/versioning.js": 88, "fs": 169, "path": 321 }], 87: [function (require, module, exports) {
            module.exports = {
                "0.8.0": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.1": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.2": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.3": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.4": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.5": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.6": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.7": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.8": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.9": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.10": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.11": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.12": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.13": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.14": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.15": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.16": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.17": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.18": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.19": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.20": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.21": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.22": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.23": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.24": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.25": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.26": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.27": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.8.28": {
                    "node_abi": 1,
                    "v8": "3.11"
                },
                "0.10.0": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.1": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.2": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.3": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.4": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.5": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.6": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.7": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.8": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.9": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.10": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.11": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.12": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.13": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.14": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.15": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.16": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.17": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.18": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.19": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.20": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.21": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.22": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.23": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.24": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.25": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.26": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.27": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.28": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.29": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.30": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.31": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.32": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.33": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.34": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.35": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.36": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.37": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.10.38": {
                    "node_abi": 11,
                    "v8": "3.14"
                },
                "0.11.0": {
                    "node_abi": 12,
                    "v8": "3.17"
                },
                "0.11.1": {
                    "node_abi": 12,
                    "v8": "3.18"
                },
                "0.11.2": {
                    "node_abi": 12,
                    "v8": "3.19"
                },
                "0.11.3": {
                    "node_abi": 12,
                    "v8": "3.19"
                },
                "0.11.4": {
                    "node_abi": 12,
                    "v8": "3.20"
                },
                "0.11.5": {
                    "node_abi": 12,
                    "v8": "3.20"
                },
                "0.11.6": {
                    "node_abi": 12,
                    "v8": "3.20"
                },
                "0.11.7": {
                    "node_abi": 12,
                    "v8": "3.20"
                },
                "0.11.8": {
                    "node_abi": 13,
                    "v8": "3.21"
                },
                "0.11.9": {
                    "node_abi": 13,
                    "v8": "3.22"
                },
                "0.11.10": {
                    "node_abi": 13,
                    "v8": "3.22"
                },
                "0.11.11": {
                    "node_abi": 14,
                    "v8": "3.22"
                },
                "0.11.12": {
                    "node_abi": 14,
                    "v8": "3.22"
                },
                "0.11.13": {
                    "node_abi": 14,
                    "v8": "3.25"
                },
                "0.11.14": {
                    "node_abi": 14,
                    "v8": "3.26"
                },
                "0.11.15": {
                    "node_abi": 14,
                    "v8": "3.28"
                },
                "0.11.16": {
                    "node_abi": 14,
                    "v8": "3.28"
                },
                "0.12.0": {
                    "node_abi": 14,
                    "v8": "3.28"
                },
                "0.12.1": {
                    "node_abi": 14,
                    "v8": "3.28"
                },
                "0.12.2": {
                    "node_abi": 14,
                    "v8": "3.28"
                },
                "1.0.0": {
                    "node_abi": 42,
                    "v8": "3.31"
                },
                "1.0.1": {
                    "node_abi": 42,
                    "v8": "3.31"
                },
                "1.0.2": {
                    "node_abi": 42,
                    "v8": "3.31"
                },
                "1.0.3": {
                    "node_abi": 42,
                    "v8": "4.1"
                },
                "1.0.4": {
                    "node_abi": 42,
                    "v8": "4.1"
                },
                "1.1.0": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.2.0": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.3.0": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.4.1": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.4.2": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.4.3": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.5.0": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.5.1": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.6.0": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.6.1": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.6.2": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.6.3": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.6.4": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.7.1": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "1.8.1": {
                    "node_abi": 43,
                    "v8": "4.1"
                },
                "2.0.0": {
                    "node_abi": 44,
                    "v8": "4.2"
                }
            }
        }, {}], 88: [function (require, module, exports) {
            (function (process) {
                "use strict";
                
                module.exports = exports;
                
                var path = require('path');
                var semver = require('semver');
                var url = require('url');
                
                var abi_crosswalk;
                
                // This is used for unit testing to provide a fake
                // ABI crosswalk that emulates one that is not updated
                // for the current version
                if (process.env.NODE_PRE_GYP_ABI_CROSSWALK) {
                    abi_crosswalk = require(process.env.NODE_PRE_GYP_ABI_CROSSWALK);
                } else {
                    abi_crosswalk = require('./abi_crosswalk.json');
                }
                
                function get_node_webkit_abi(runtime, target_version) {
                    if (!runtime) {
                        throw new Error("get_node_webkit_abi requires valid runtime arg");
                    }
                    if (typeof target_version === 'undefined') {
                        // erroneous CLI call
                        throw new Error("Empty target version is not supported if node-webkit is the target.");
                    }
                    return runtime + '-v' + target_version;
                }
                module.exports.get_node_webkit_abi = get_node_webkit_abi;
                
                function get_node_abi(runtime, versions) {
                    if (!runtime) {
                        throw new Error("get_node_abi requires valid runtime arg");
                    }
                    if (!versions) {
                        throw new Error("get_node_abi requires valid process.versions object");
                    }
                    var sem_ver = semver.parse(versions.node);
                    if (sem_ver.major === 0 && sem_ver.minor % 2) { // odd series
                        // https://github.com/mapbox/node-pre-gyp/issues/124
                        return runtime + '-v' + versions.node;
                    } else {
                        // process.versions.modules added in >= v0.10.4 and v0.11.7
                        // https://github.com/joyent/node/commit/ccabd4a6fa8a6eb79d29bc3bbe9fe2b6531c2d8e
                        return versions.modules ? runtime + '-v' + (+versions.modules) :
            'v8-' + versions.v8.split('.').slice(0, 2).join('.');
                    }
                }
                module.exports.get_node_abi = get_node_abi;
                
                function get_runtime_abi(runtime, target_version) {
                    if (!runtime) {
                        throw new Error("get_runtime_abi requires valid runtime arg");
                    }
                    if (runtime === 'node-webkit') {
                        return get_node_webkit_abi(runtime, target_version || process.versions['node-webkit']);
                    } else {
                        if (runtime != 'node') {
                            throw new Error("Unknown Runtime: '" + runtime + "'");
                        }
                        if (!target_version) {
                            return get_node_abi(runtime, process.versions);
                        } else {
                            var cross_obj;
                            // abi_crosswalk generated with ./scripts/abi_crosswalk.js
                            if (abi_crosswalk[target_version]) {
                                cross_obj = abi_crosswalk[target_version];
                            } else {
                                var target_parts = target_version.split('.').map(function (i) { return +i; });
                                if (target_parts.length != 3) { // parse failed
                                    throw new Error("Unknown target version: " + target_version);
                                }
                                /*
                    The below code tries to infer the last known ABI compatible version
                    that we have recorded in the abi_crosswalk.json when an exact match
                    is not possible. The reasons for this to exist are complicated:

                       - We support passing --target to be able to allow developers to package binaries for versions of node
                         that are not the same one as they are running. This might also be used in combination with the
                         --target_arch or --target_platform flags to also package binaries for alternative platforms
                       - When --target is passed we can't therefore determine the ABI (process.versions.modules) from the node
                         version that is running in memory
                       - So, therefore node-pre-gyp keeps an "ABI crosswalk" (lib/util/abi_crosswalk.json) to be able to look
                         this info up for all versions
                       - But we cannot easily predict what the future ABI will be for released versions
                       - And node-pre-gyp needs to be a `bundledDependency` in apps that depend on it in order to work correctly
                         by being fully available at install time.
                       - So, the speed of node releases and the bundled nature of node-pre-gyp mean that a new node-pre-gyp release
                         need to happen for every node.js/io.js/node-webkit/nw.js/atom-shell/etc release that might come online if
                         you want the `--target` flag to keep working for the latest version
                       - Which is impractical ^^
                       - Hence the below code guesses about future ABI to make the need to update node-pre-gyp less demanding.

                    In practice then you can have a dependency of your app like `node-sqlite3` that bundles a `node-pre-gyp` that
                    only knows about node v0.10.33 in the `abi_crosswalk.json` but target node v0.10.34 (which is assumed to be
                    ABI compatible with v0.10.33).

                    TODO: use semver module instead of custom version parsing
                */
                var major = target_parts[0];
                                var minor = target_parts[1];
                                var patch = target_parts[2];
                                // io.js: yeah if node.js ever releases 1.x this will break
                                // but that is unlikely to happen: https://github.com/iojs/io.js/pull/253#issuecomment-69432616
                                if (major === 1) {
                                    // look for last release that is the same major version
                                    // e.g. we assume io.js 1.x is ABI compatible with >= 1.0.0
                                    while (true) {
                                        if (minor > 0) --minor;
                                        if (patch > 0) --patch;
                                        var new_iojs_target = '' + major + '.' + minor + '.' + patch;
                                        if (abi_crosswalk[new_iojs_target]) {
                                            cross_obj = abi_crosswalk[new_iojs_target];
                                            console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);
                                            console.log('Warning: but node-pre-gyp successfully choose ' + new_iojs_target + ' as ABI compatible target');
                                            break;
                                        }
                                        if (minor === 0 && patch === 0) {
                                            break;
                                        }
                                    }
                                } else if (major === 0) { // node.js
                                    if (target_parts[1] % 2 === 0) { // for stable/even node.js series
                                        // look for the last release that is the same minor release
                                        // e.g. we assume node 0.10.x is ABI compatible with >= 0.10.0
                                        while (--patch > 0) {
                                            var new_node_target = '' + major + '.' + minor + '.' + patch;
                                            if (abi_crosswalk[new_node_target]) {
                                                cross_obj = abi_crosswalk[new_node_target];
                                                console.log('Warning: node-pre-gyp could not find exact match for ' + target_version);
                                                console.log('Warning: but node-pre-gyp successfully choose ' + new_node_target + ' as ABI compatible target');
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            if (!cross_obj) {
                                throw new Error("Unsupported target version: " + target_version);
                            }
                            // emulate process.versions
                            var versions_obj = {
                                node: target_version,
                                v8: cross_obj.v8 + '.0',
                                // abi_crosswalk uses 1 for node versions lacking process.versions.modules
                                // process.versions.modules added in >= v0.10.4 and v0.11.7
                                modules: cross_obj.node_abi > 1 ? cross_obj.node_abi : undefined
                            };
                            return get_node_abi(runtime, versions_obj);
                        }
                    }
                }
                module.exports.get_runtime_abi = get_runtime_abi;
                
                var required_parameters = [
                    'module_name',
                    'module_path',
                    'host'
                ];
                
                function validate_config(package_json) {
                    var msg = package_json.name + ' package.json is not node-pre-gyp ready:\n';
                    var missing = [];
                    if (!package_json.main) {
                        missing.push('main');
                    }
                    if (!package_json.version) {
                        missing.push('version');
                    }
                    if (!package_json.name) {
                        missing.push('name');
                    }
                    if (!package_json.binary) {
                        missing.push('binary');
                    }
                    var o = package_json.binary;
                    required_parameters.forEach(function (p) {
                        if (missing.indexOf('binary') > -1) {
                            missing.pop('binary');
                        }
                        if (!o || o[p] === undefined) {
                            missing.push('binary.' + p);
                        }
                    });
                    if (missing.length >= 1) {
                        throw new Error(msg + "package.json must declare these properties: \n" + missing.join('\n'));
                    }
                    if (o) {
                        // enforce https over http
                        var protocol = url.parse(o.host).protocol;
                        if (protocol === 'http:') {
                            throw new Error("'host' protocol (" + protocol + ") is invalid - only 'https:' is accepted");
                        }
                    }
                }
                
                module.exports.validate_config = validate_config;
                
                function eval_template(template, opts) {
                    Object.keys(opts).forEach(function (key) {
                        var pattern = '{' + key + '}';
                        while (template.indexOf(pattern) > -1) {
                            template = template.replace(pattern, opts[key]);
                        }
                    });
                    return template;
                }
                
                // url.resolve needs single trailing slash
                // to behave correctly, otherwise a double slash
                // may end up in the url which breaks requests
                // and a lacking slash may not lead to proper joining
                function fix_slashes(pathname) {
                    if (pathname.slice(-1) != '/') {
                        return pathname + '/';
                    }
                    return pathname;
                }
                
                // remove double slashes
                // note: path.normalize will not work because
                // it will convert forward to back slashes
                function drop_double_slashes(pathname) {
                    return pathname.replace(/\/\//g, '/');
                }
                
                var default_package_name = '{module_name}-v{version}-{node_abi}-{platform}-{arch}.tar.gz';
                var default_remote_path = '';
                
                module.exports.evaluate = function (package_json, options) {
                    options = options || {};
                    validate_config(package_json);
                    var v = package_json.version;
                    var module_version = semver.parse(v);
                    var runtime = options.runtime || (process.versions['node-webkit'] ? 'node-webkit' : 'node');
                    var opts = {
                        name: package_json.name,
                        configuration: Boolean(options.debug) ? 'Debug' : 'Release',
                        debug: options.debug,
                        module_name: package_json.binary.module_name,
                        version: module_version.version,
                        prerelease: module_version.prerelease.length ? module_version.prerelease.join('.') : '',
                        build: module_version.build.length ? module_version.build.join('.') : '',
                        major: module_version.major,
                        minor: module_version.minor,
                        patch: module_version.patch,
                        runtime: runtime,
                        node_abi: get_runtime_abi(runtime, options.target),
                        target: options.target || '',
                        platform: options.target_platform || process.platform,
                        target_platform: options.target_platform || process.platform,
                        arch: options.target_arch || process.arch,
                        target_arch: options.target_arch || process.arch,
                        module_main: package_json.main,
                        toolset : options.toolset || '' // address https://github.com/mapbox/node-pre-gyp/issues/119
                    };
                    opts.host = fix_slashes(eval_template(package_json.binary.host, opts));
                    opts.module_path = eval_template(package_json.binary.module_path, opts);
                    // now we resolve the module_path to ensure it is absolute so that binding.gyp variables work predictably
                    if (options.module_root) {
                        // resolve relative to known module root: works for pre-binding require
                        opts.module_path = path.join(options.module_root, opts.module_path);
                    } else {
                        // resolve relative to current working directory: works for node-pre-gyp commands
                        opts.module_path = path.resolve(opts.module_path);
                    }
                    opts.module = path.join(opts.module_path, opts.module_name + '.node');
                    opts.remote_path = package_json.binary.remote_path ? drop_double_slashes(fix_slashes(eval_template(package_json.binary.remote_path, opts))) : default_remote_path;
                    var package_name = package_json.binary.package_name ? package_json.binary.package_name : default_package_name;
                    opts.package_name = eval_template(package_name, opts);
                    opts.staged_tarball = path.join('build/stage', opts.remote_path, opts.package_name);
                    opts.hosted_path = url.resolve(opts.host, opts.remote_path);
                    opts.hosted_tarball = url.resolve(opts.hosted_path, opts.package_name);
                    return opts;
                };

            }).call(this, require('_process'))
        }, { "./abi_crosswalk.json": 87, "_process": 322, "path": 321, "semver": 120, "url": 340 }], 89: [function (require, module, exports) {
            (function (process) {
                // info about each config option.
                
                var debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG
  ? function () { console.error.apply(console, arguments) }
  : function () { }
                
                var url = require("url")
  , path = require("path")
  , Stream = require("stream").Stream
  , abbrev = require("abbrev")
                
                module.exports = exports = nopt
                exports.clean = clean
                
                exports.typeDefs =
  {
                    String  : { type: String, validate: validateString }
                    , Boolean : { type: Boolean, validate: validateBoolean }
                    , url     : { type: url, validate: validateUrl }
                    , Number  : { type: Number, validate: validateNumber }
                    , path    : { type: path, validate: validatePath }
                    , Stream  : { type: Stream, validate: validateStream }
                    , Date    : { type: Date, validate: validateDate }
                }
                
                function nopt(types, shorthands, args, slice) {
                    args = args || process.argv
                    types = types || {}
                    shorthands = shorthands || {}
                    if (typeof slice !== "number") slice = 2
                    
                    debug(types, shorthands, args, slice)
                    
                    args = args.slice(slice)
                    var data = {}
    , key
    , remain = []
    , cooked = args
    , original = args.slice(0)
                    
                    parse(args, data, remain, types, shorthands)
                    // now data is full
                    clean(data, types, exports.typeDefs)
                    data.argv = { remain: remain, cooked: cooked, original: original }
                    Object.defineProperty(data.argv, 'toString', {
                        value: function () {
                            return this.original.map(JSON.stringify).join(" ")
                        }, enumerable: false
                    })
                    return data
                }
                
                function clean(data, types, typeDefs) {
                    typeDefs = typeDefs || exports.typeDefs
                    var remove = {}
    , typeDefault = [false, true, null, String, Array]
                    
                    Object.keys(data).forEach(function (k) {
                        if (k === "argv") return
                        var val = data[k]
      , isArray = Array.isArray(val)
      , type = types[k]
                        if (!isArray) val = [val]
                        if (!type) type = typeDefault
                        if (type === Array) type = typeDefault.concat(Array)
                        if (!Array.isArray(type)) type = [type]
                        
                        debug("val=%j", val)
                        debug("types=", type)
                        val = val.map(function (val) {
                            // if it's an unknown value, then parse false/true/null/numbers/dates
                            if (typeof val === "string") {
                                debug("string %j", val)
                                val = val.trim()
                                if ((val === "null" && ~type.indexOf(null)) 
            || (val === "true" &&
               (~type.indexOf(true) || ~type.indexOf(Boolean))) 
            || (val === "false" &&
               (~type.indexOf(false) || ~type.indexOf(Boolean)))) {
                                    val = JSON.parse(val)
                                    debug("jsonable %j", val)
                                } else if (~type.indexOf(Number) && !isNaN(val)) {
                                    debug("convert to number", val)
                                    val = +val
                                } else if (~type.indexOf(Date) && !isNaN(Date.parse(val))) {
                                    debug("convert to date", val)
                                    val = new Date(val)
                                }
                            }
                            
                            if (!types.hasOwnProperty(k)) {
                                return val
                            }
                            
                            // allow `--no-blah` to set 'blah' to null if null is allowed
                            if (val === false && ~type.indexOf(null) &&
          !(~type.indexOf(false) || ~type.indexOf(Boolean))) {
                                val = null
                            }
                            
                            var d = {}
                            d[k] = val
                            debug("prevalidated val", d, val, types[k])
                            if (!validate(d, k, val, types[k], typeDefs)) {
                                if (exports.invalidHandler) {
                                    exports.invalidHandler(k, val, types[k], data)
                                } else if (exports.invalidHandler !== false) {
                                    debug("invalid: " + k + "=" + val, types[k])
                                }
                                return remove
                            }
                            debug("validated val", d, val, types[k])
                            return d[k]
                        }).filter(function (val) { return val !== remove })
                        
                        if (!val.length) delete data[k]
                        else if (isArray) {
                            debug(isArray, data[k], val)
                            data[k] = val
                        } else data[k] = val[0]
                        
                        debug("k=%s val=%j", k, val, data[k])
                    })
                }
                
                function validateString(data, k, val) {
                    data[k] = String(val)
                }
                
                function validatePath(data, k, val) {
                    if (val === true) return false
                    if (val === null) return true
                    
                    val = String(val)
                    var homePattern = process.platform === 'win32' ? /^~(\/|\\)/ : /^~\//
                    if (val.match(homePattern) && process.env.HOME) {
                        val = path.resolve(process.env.HOME, val.substr(2))
                    }
                    data[k] = path.resolve(String(val))
                    return true
                }
                
                function validateNumber(data, k, val) {
                    debug("validate Number %j %j %j", k, val, isNaN(val))
                    if (isNaN(val)) return false
                    data[k] = +val
                }
                
                function validateDate(data, k, val) {
                    debug("validate Date %j %j %j", k, val, Date.parse(val))
                    var s = Date.parse(val)
                    if (isNaN(s)) return false
                    data[k] = new Date(val)
                }
                
                function validateBoolean(data, k, val) {
                    if (val instanceof Boolean) val = val.valueOf()
                    else if (typeof val === "string") {
                        if (!isNaN(val)) val = !!(+val)
                        else if (val === "null" || val === "false") val = false
                        else val = true
                    } else val = !!val
                    data[k] = val
                }
                
                function validateUrl(data, k, val) {
                    val = url.parse(String(val))
                    if (!val.host) return false
                    data[k] = val.href
                }
                
                function validateStream(data, k, val) {
                    if (!(val instanceof Stream)) return false
                    data[k] = val
                }
                
                function validate(data, k, val, type, typeDefs) {
                    // arrays are lists of types.
                    if (Array.isArray(type)) {
                        for (var i = 0, l = type.length; i < l; i++) {
                            if (type[i] === Array) continue
                            if (validate(data, k, val, type[i], typeDefs)) return true
                        }
                        delete data[k]
                        return false
                    }
                    
                    // an array of anything?
                    if (type === Array) return true
                    
                    // NaN is poisonous.  Means that something is not allowed.
                    if (type !== type) {
                        debug("Poison NaN", k, val, type)
                        delete data[k]
                        return false
                    }
                    
                    // explicit list of values
                    if (val === type) {
                        debug("Explicitly allowed %j", val)
                        // if (isArray) (data[k] = data[k] || []).push(val)
                        // else data[k] = val
                        data[k] = val
                        return true
                    }
                    
                    // now go through the list of typeDefs, validate against each one.
                    var ok = false
    , types = Object.keys(typeDefs)
                    for (var i = 0, l = types.length; i < l; i++) {
                        debug("test type %j %j %j", k, val, types[i])
                        var t = typeDefs[types[i]]
                        if (t && type === t.type) {
                            var d = {}
                            ok = false !== t.validate(d, k, val)
                            val = d[k]
                            if (ok) {
                                // if (isArray) (data[k] = data[k] || []).push(val)
                                // else data[k] = val
                                data[k] = val
                                break
                            }
                        }
                    }
                    debug("OK? %j (%j %j %j)", ok, k, val, types[i])
                    
                    if (!ok) delete data[k]
                    return ok
                }
                
                function parse(args, data, remain, types, shorthands) {
                    debug("parse", args, data, remain)
                    
                    var key = null
    , abbrevs = abbrev(Object.keys(types))
    , shortAbbr = abbrev(Object.keys(shorthands))
                    
                    for (var i = 0; i < args.length; i++) {
                        var arg = args[i]
                        debug("arg", arg)
                        
                        if (arg.match(/^-{2,}$/)) {
                            // done with keys.
                            // the rest are args.
                            remain.push.apply(remain, args.slice(i + 1))
                            args[i] = "--"
                            break
                        }
                        var hadEq = false
                        if (arg.charAt(0) === "-" && arg.length > 1) {
                            if (arg.indexOf("=") !== -1) {
                                hadEq = true
                                var v = arg.split("=")
                                arg = v.shift()
                                v = v.join("=")
                                args.splice.apply(args, [i, 1].concat([arg, v]))
                            }
                            
                            // see if it's a shorthand
                            // if so, splice and back up to re-parse it.
                            var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs)
                            debug("arg=%j shRes=%j", arg, shRes)
                            if (shRes) {
                                debug(arg, shRes)
                                args.splice.apply(args, [i, 1].concat(shRes))
                                if (arg !== shRes[0]) {
                                    i--
                                    continue
                                }
                            }
                            arg = arg.replace(/^-+/, "")
                            var no = null
                            while (arg.toLowerCase().indexOf("no-") === 0) {
                                no = !no
                                arg = arg.substr(3)
                            }
                            
                            if (abbrevs[arg]) arg = abbrevs[arg]
                            
                            var isArray = types[arg] === Array ||
        Array.isArray(types[arg]) && types[arg].indexOf(Array) !== -1
                            
                            // allow unknown things to be arrays if specified multiple times.
                            if (!types.hasOwnProperty(arg) && data.hasOwnProperty(arg)) {
                                if (!Array.isArray(data[arg]))
                                    data[arg] = [data[arg]]
                                isArray = true
                            }
                            
                            var val
        , la = args[i + 1]
                            
                            var isBool = typeof no === 'boolean' ||
        types[arg] === Boolean ||
        Array.isArray(types[arg]) && types[arg].indexOf(Boolean) !== -1 ||
        (typeof types[arg] === 'undefined' && !hadEq) ||
        (la === "false" &&
         (types[arg] === null ||
          Array.isArray(types[arg]) && ~types[arg].indexOf(null)))
                            
                            if (isBool) {
                                // just set and move along
                                val = !no
                                // however, also support --bool true or --bool false
                                if (la === "true" || la === "false") {
                                    val = JSON.parse(la)
                                    la = null
                                    if (no) val = !val
                                    i++
                                }
                                
                                // also support "foo":[Boolean, "bar"] and "--foo bar"
                                if (Array.isArray(types[arg]) && la) {
                                    if (~types[arg].indexOf(la)) {
                                        // an explicit type
                                        val = la
                                        i++
                                    } else if (la === "null" && ~types[arg].indexOf(null)) {
                                        // null allowed
                                        val = null
                                        i++
                                    } else if (!la.match(/^-{2,}[^-]/) &&
                      !isNaN(la) &&
                      ~types[arg].indexOf(Number)) {
                                        // number
                                        val = +la
                                        i++
                                    } else if (!la.match(/^-[^-]/) && ~types[arg].indexOf(String)) {
                                        // string
                                        val = la
                                        i++
                                    }
                                }
                                
                                if (isArray) (data[arg] = data[arg] || []).push(val)
                                else data[arg] = val
                                
                                continue
                            }
                            
                            if (types[arg] === String && la === undefined)
                                la = ""
                            
                            if (la && la.match(/^-{2,}$/)) {
                                la = undefined
                                i--
                            }
                            
                            val = la === undefined ? true : la
                            if (isArray) (data[arg] = data[arg] || []).push(val)
                            else data[arg] = val
                            
                            i++
                            continue
                        }
                        remain.push(arg)
                    }
                }
                
                function resolveShort(arg, shorthands, shortAbbr, abbrevs) {
                    // handle single-char shorthands glommed together, like
                    // npm ls -glp, but only if there is one dash, and only if
                    // all of the chars are single-char shorthands, and it's
                    // not a match to some other abbrev.
                    arg = arg.replace(/^-+/, '')
                    
                    // if it's an exact known option, then don't go any further
                    if (abbrevs[arg] === arg)
                        return null
                    
                    // if it's an exact known shortopt, same deal
                    if (shorthands[arg]) {
                        // make it an array, if it's a list of words
                        if (shorthands[arg] && !Array.isArray(shorthands[arg]))
                            shorthands[arg] = shorthands[arg].split(/\s+/)
                        
                        return shorthands[arg]
                    }
                    
                    // first check to see if this arg is a set of single-char shorthands
                    var singles = shorthands.___singles
                    if (!singles) {
                        singles = Object.keys(shorthands).filter(function (s) {
                            return s.length === 1
                        }).reduce(function (l, r) {
                            l[r] = true
                            return l
                        }, {})
                        shorthands.___singles = singles
                        debug('shorthand singles', singles)
                    }
                    
                    var chrs = arg.split("").filter(function (c) {
                        return singles[c]
                    })
                    
                    if (chrs.join("") === arg) return chrs.map(function (c) {
                        return shorthands[c]
                    }).reduce(function (l, r) {
                        return l.concat(r)
                    }, [])
                    
                    
                    // if it's an arg abbrev, and not a literal shorthand, then prefer the arg
                    if (abbrevs[arg] && !shorthands[arg])
                        return null
                    
                    // if it's an abbr for a shorthand, then use that
                    if (shortAbbr[arg])
                        arg = shortAbbr[arg]
                    
                    // make it an array, if it's a list of words
                    if (shorthands[arg] && !Array.isArray(shorthands[arg]))
                        shorthands[arg] = shorthands[arg].split(/\s+/)
                    
                    return shorthands[arg]
                }

            }).call(this, require('_process'))
        }, { "_process": 322, "abbrev": 90, "path": 321, "stream": 338, "url": 340 }], 90: [function (require, module, exports) {
            
            module.exports = exports = abbrev.abbrev = abbrev
            
            abbrev.monkeyPatch = monkeyPatch
            
            function monkeyPatch() {
                Object.defineProperty(Array.prototype, 'abbrev', {
                    value: function () { return abbrev(this) },
                    enumerable: false, configurable: true, writable: true
                })
                
                Object.defineProperty(Object.prototype, 'abbrev', {
                    value: function () { return abbrev(Object.keys(this)) },
                    enumerable: false, configurable: true, writable: true
                })
            }
            
            function abbrev(list) {
                if (arguments.length !== 1 || !Array.isArray(list)) {
                    list = Array.prototype.slice.call(arguments, 0)
                }
                for (var i = 0, l = list.length, args = []; i < l ; i++) {
                    args[i] = typeof list[i] === "string" ? list[i] : String(list[i])
                }
                
                // sort them lexicographically, so that they're next to their nearest kin
                args = args.sort(lexSort)
                
                // walk through each, seeing how much it has in common with the next and previous
                var abbrevs = {}
    , prev = ""
                for (var i = 0, l = args.length; i < l ; i++) {
                    var current = args[i]
      , next = args[i + 1] || ""
      , nextMatches = true
      , prevMatches = true
                    if (current === next) continue
                    for (var j = 0, cl = current.length; j < cl ; j++) {
                        var curChar = current.charAt(j)
                        nextMatches = nextMatches && curChar === next.charAt(j)
                        prevMatches = prevMatches && curChar === prev.charAt(j)
                        if (!nextMatches && !prevMatches) {
                            j++
                            break
                        }
                    }
                    prev = current
                    if (j === cl) {
                        abbrevs[current] = current
                        continue
                    }
                    for (var a = current.substr(0, j); j <= cl ; j++) {
                        abbrevs[a] = current
                        a += current.charAt(j)
                    }
                }
                return abbrevs
            }
            
            function lexSort(a, b) {
                return a === b ? 0 : a > b ? 1 : -1
            }

        }, {}], 91: [function (require, module, exports) {
            (function (process) {
                'use strict'
                var Progress = require('are-we-there-yet')
                var Gauge = require('gauge')
                var EE = require('events').EventEmitter
                var log = exports = module.exports = new EE
                var util = require('util')
                
                var ansi = require('ansi')
                log.cursor = ansi(process.stderr)
                log.stream = process.stderr
                
                // by default, let ansi decide based on tty-ness.
                var colorEnabled = undefined
                log.enableColor = function () {
                    colorEnabled = true
                    this.cursor.enabled = true
                }
                log.disableColor = function () {
                    colorEnabled = false
                    this.cursor.enabled = false
                }
                
                // default level
                log.level = 'info'
                
                log.gauge = new Gauge(log.cursor)
                log.tracker = new Progress.TrackerGroup()
                
                // no progress bars unless asked
                log.progressEnabled = false
                
                var gaugeTheme = undefined
                
                log.enableUnicode = function () {
                    gaugeTheme = gauge.unicode
                    log.gauge.setTheme(gaugeTheme)
                }
                
                log.disableUnicode = function () {
                    gaugeTheme = gauge.ascii
                    log.gauge.setTheme(gaugeTheme)
                }
                
                var gaugeTemplate = undefined
                log.setGaugeTemplate = function (template) {
                    gaugeTemplate = template
                    log.gauge.setTemplate(gaugeTemplate)
                }
                
                log.enableProgress = function () {
                    if (this.progressEnabled) return
                    this.progressEnabled = true
                    if (this._pause) return
                    this.tracker.on('change', this.showProgress)
                    this.gauge.enable()
                    this.showProgress()
                }
                
                log.disableProgress = function () {
                    if (!this.progressEnabled) return
                    this.clearProgress()
                    this.progressEnabled = false
                    this.tracker.removeListener('change', this.showProgress)
                    this.gauge.disable()
                }
                
                var trackerConstructors = ['newGroup', 'newItem', 'newStream']
                
                var mixinLog = function (tracker) {
                    // mixin the public methods from log into the tracker
                    // (except: conflicts and one's we handle specially)
                    Object.keys(log).forEach(function (P) {
                        if (P[0] === '_') return
                        if (trackerConstructors.filter(function (C) { return C === P }).length) return
                        if (tracker[P]) return
                        if (typeof log[P] !== 'function') return
                        var func = log[P]
                        tracker[P] = function () {
                            return func.apply(log, arguments)
                        }
                    })
                    // if the new tracker is a group, make sure any subtrackers get
                    // mixed in too
                    if (tracker instanceof Progress.TrackerGroup) {
                        trackerConstructors.forEach(function (C) {
                            var func = tracker[C]
                            tracker[C] = function () { return mixinLog(func.apply(tracker, arguments)) }
                        })
                    }
                    return tracker
                }
                
                // Add tracker constructors to the top level log object
                trackerConstructors.forEach(function (C) {
                    log[C] = function () { return mixinLog(this.tracker[C].apply(this.tracker, arguments)) }
                })
                
                log.clearProgress = function () {
                    if (!this.progressEnabled) return
                    this.gauge.hide()
                }
                
                log.showProgress = function (name) {
                    if (!this.progressEnabled) return
                    this.gauge.show(name, this.tracker.completed())
                }.bind(log) // bind for use in tracker's on-change listener
                
                // temporarily stop emitting, but don't drop
                log.pause = function () {
                    this._paused = true
                }
                
                log.resume = function () {
                    if (!this._paused) return
                    this._paused = false
                    
                    var b = this._buffer
                    this._buffer = []
                    b.forEach(function (m) {
                        this.emitLog(m)
                    }, this)
                    if (this.progressEnabled) this.enableProgress()
                }
                
                log._buffer = []
                
                var id = 0
                log.record = []
                log.maxRecordSize = 10000
                log.log = function (lvl, prefix, message) {
                    var l = this.levels[lvl]
                    if (l === undefined) {
                        return this.emit('error', new Error(util.format(
                            'Undefined log level: %j', lvl)))
                    }
                    
                    var a = new Array(arguments.length - 2)
                    var stack = null
                    for (var i = 2; i < arguments.length; i++) {
                        var arg = a[i - 2] = arguments[i]
                        
                        // resolve stack traces to a plain string.
                        if (typeof arg === 'object' && arg &&
        (arg instanceof Error) && arg.stack) {
                            arg.stack = stack = arg.stack + ''
                        }
                    }
                    if (stack) a.unshift(stack + '\n')
                    message = util.format.apply(util, a)
                    
                    var m = {
                        id: id++,
                        level: lvl,
                        prefix: String(prefix || ''),
                        message: message,
                        messageRaw: a
                    }
                    
                    this.emit('log', m)
                    this.emit('log.' + lvl, m)
                    if (m.prefix) this.emit(m.prefix, m)
                    
                    this.record.push(m)
                    var mrs = this.maxRecordSize
                    var n = this.record.length - mrs
                    if (n > mrs / 10) {
                        var newSize = Math.floor(mrs * 0.9)
                        this.record = this.record.slice(-1 * newSize)
                    }
                    
                    this.emitLog(m)
                }.bind(log)
                
                log.emitLog = function (m) {
                    if (this._paused) {
                        this._buffer.push(m)
                        return
                    }
                    if (this.progressEnabled) this.gauge.pulse(m.prefix)
                    var l = this.levels[m.level]
                    if (l === undefined) return
                    if (l < this.levels[this.level]) return
                    if (l > 0 && !isFinite(l)) return
                    
                    var style = log.style[m.level]
                    var disp = log.disp[m.level] || m.level
                    this.clearProgress()
                    m.message.split(/\r?\n/).forEach(function (line) {
                        if (this.heading) {
                            this.write(this.heading, this.headingStyle)
                            this.write(' ')
                        }
                        this.write(disp, log.style[m.level])
                        var p = m.prefix || ''
                        if (p) this.write(' ')
                        this.write(p, this.prefixStyle)
                        this.write(' ' + line + '\n')
                    }, this)
                    this.showProgress()
                }
                
                log.write = function (msg, style) {
                    if (!this.cursor) return
                    if (this.stream !== this.cursor.stream) {
                        this.cursor = ansi(this.stream, { enabled: colorEnabled })
                        var options = {}
                        if (gaugeTheme != null) options.theme = gaugeTheme
                        if (gaugeTemplate != null) options.template = gaugeTemplate
                        this.gauge = new Gauge(options, this.cursor)
                    }
                    
                    style = style || {}
                    if (style.fg) this.cursor.fg[style.fg]()
                    if (style.bg) this.cursor.bg[style.bg]()
                    if (style.bold) this.cursor.bold()
                    if (style.underline) this.cursor.underline()
                    if (style.inverse) this.cursor.inverse()
                    if (style.beep) this.cursor.beep()
                    this.cursor.write(msg).reset()
                }
                
                log.addLevel = function (lvl, n, style, disp) {
                    if (!disp) disp = lvl
                    this.levels[lvl] = n
                    this.style[lvl] = style
                    if (!this[lvl]) this[lvl] = function () {
                        var a = new Array(arguments.length + 1)
                        a[0] = lvl
                        for (var i = 0; i < arguments.length; i++) {
                            a[i + 1] = arguments[i]
                        }
                        return this.log.apply(this, a)
                    }.bind(this)
                    this.disp[lvl] = disp
                }
                
                log.prefixStyle = { fg: 'magenta' }
                log.headingStyle = { fg: 'white', bg: 'black' }
                
                log.style = {}
                log.levels = {}
                log.disp = {}
                log.addLevel('silly', -Infinity, { inverse: true }, 'sill')
                log.addLevel('verbose', 1000, { fg: 'blue', bg: 'black' }, 'verb')
                log.addLevel('info', 2000, { fg: 'green' })
                log.addLevel('http', 3000, { fg: 'green', bg: 'black' })
                log.addLevel('warn', 4000, { fg: 'black', bg: 'yellow' }, 'WARN')
                log.addLevel('error', 5000, { fg: 'red', bg: 'black' }, 'ERR!')
                log.addLevel('silent', Infinity)

            }).call(this, require('_process'))
        }, { "_process": 322, "ansi": 92, "are-we-there-yet": 94, "events": 317, "gauge": 119, "util": 342 }], 92: [function (require, module, exports) {
            
            /**
 * References:
 *
 *   - http://en.wikipedia.org/wiki/ANSI_escape_code
 *   - http://www.termsys.demon.co.uk/vtansi.htm
 *
 */

/**
 * Module dependencies.
 */

var emitNewlineEvents = require('./newlines')
  , prefix = '\x1b['// For all escape codes
  , suffix = 'm'// Only for color codes
            
            /**
 * The ANSI escape sequences.
 */

var codes = {
                up: 'A'
                , down: 'B'
                , forward: 'C'
                , back: 'D'
                , nextLine: 'E'
                , previousLine: 'F'
                , horizontalAbsolute: 'G'
                , eraseData: 'J'
                , eraseLine: 'K'
                , scrollUp: 'S'
                , scrollDown: 'T'
                , savePosition: 's'
                , restorePosition: 'u'
                , queryPosition: '6n'
                , hide: '?25l'
                , show: '?25h'
            }
            
            /**
 * Rendering ANSI codes.
 */

var styles = {
                bold: 1
                , italic: 3
                , underline: 4
                , inverse: 7
            }
            
            /**
 * The negating ANSI code for the rendering modes.
 */

var reset = {
                bold: 22
                , italic: 23
                , underline: 24
                , inverse: 27
            }
            
            /**
 * The standard, styleable ANSI colors.
 */

var colors = {
                white: 37
                , black: 30
                , blue: 34
                , cyan: 36
                , green: 32
                , magenta: 35
                , red: 31
                , yellow: 33
                , grey: 90
                , brightBlack: 90
                , brightRed: 91
                , brightGreen: 92
                , brightYellow: 93
                , brightBlue: 94
                , brightMagenta: 95
                , brightCyan: 96
                , brightWhite: 97
            }
            
            
            /**
 * Creates a Cursor instance based off the given `writable stream` instance.
 */

function ansi(stream, options) {
                if (stream._ansicursor) {
                    return stream._ansicursor
                } else {
                    return stream._ansicursor = new Cursor(stream, options)
                }
            }
            module.exports = exports = ansi
            
            /**
 * The `Cursor` class.
 */

function Cursor(stream, options) {
                if (!(this instanceof Cursor)) {
                    return new Cursor(stream, options)
                }
                if (typeof stream != 'object' || typeof stream.write != 'function') {
                    throw new Error('a valid Stream instance must be passed in')
                }
                
                // the stream to use
                this.stream = stream
                
                // when 'enabled' is false then all the functions are no-ops except for write()
                this.enabled = options && options.enabled
                if (typeof this.enabled === 'undefined') {
                    this.enabled = stream.isTTY
                }
                this.enabled = !!this.enabled
                
                // then `buffering` is true, then `write()` calls are buffered in
                // memory until `flush()` is invoked
                this.buffering = !!(options && options.buffering)
                this._buffer = []
                
                // controls the foreground and background colors
                this.fg = this.foreground = new Colorer(this, 0)
                this.bg = this.background = new Colorer(this, 10)
                
                // defaults
                this.Bold = false
                this.Italic = false
                this.Underline = false
                this.Inverse = false
                
                // keep track of the number of "newlines" that get encountered
                this.newlines = 0
                emitNewlineEvents(stream)
                stream.on('newline', function () {
                    this.newlines++
                }.bind(this))
            }
            exports.Cursor = Cursor
            
            /**
 * Helper function that calls `write()` on the underlying Stream.
 * Returns `this` instead of the write() return value to keep
 * the chaining going.
 */

Cursor.prototype.write = function (data) {
                if (this.buffering) {
                    this._buffer.push(arguments)
                } else {
                    this.stream.write.apply(this.stream, arguments)
                }
                return this
            }
            
            /**
 * Buffer `write()` calls into memory.
 *
 * @api public
 */

Cursor.prototype.buffer = function () {
                this.buffering = true
                return this
            }
            
            /**
 * Write out the in-memory buffer.
 *
 * @api public
 */

Cursor.prototype.flush = function () {
                this.buffering = false
                var str = this._buffer.map(function (args) {
                    if (args.length != 1) throw new Error('unexpected args length! ' + args.length);
                    return args[0];
                }).join('');
                this._buffer.splice(0); // empty
                this.write(str);
                return this
            }
            
            
            /**
 * The `Colorer` class manages both the background and foreground colors.
 */

function Colorer(cursor, base) {
                this.current = null
                this.cursor = cursor
                this.base = base
            }
            exports.Colorer = Colorer
            
            /**
 * Write an ANSI color code, ensuring that the same code doesn't get rewritten.
 */

Colorer.prototype._setColorCode = function setColorCode(code) {
                var c = String(code)
                if (this.current === c) return
                this.cursor.enabled && this.cursor.write(prefix + c + suffix)
                this.current = c
                return this
            }
            
            
            /**
 * Set up the positional ANSI codes.
 */

Object.keys(codes).forEach(function (name) {
                var code = String(codes[name])
                Cursor.prototype[name] = function () {
                    var c = code
                    if (arguments.length > 0) {
                        c = toArray(arguments).map(Math.round).join(';') + code
                    }
                    this.enabled && this.write(prefix + c)
                    return this
                }
            })
            
            /**
 * Set up the functions for the rendering ANSI codes.
 */

Object.keys(styles).forEach(function (style) {
                var name = style[0].toUpperCase() + style.substring(1)
    , c = styles[style]
    , r = reset[style]
                
                Cursor.prototype[style] = function () {
                    if (this[name]) return
                    this.enabled && this.write(prefix + c + suffix)
                    this[name] = true
                    return this
                }
                
                Cursor.prototype['reset' + name] = function () {
                    if (!this[name]) return
                    this.enabled && this.write(prefix + r + suffix)
                    this[name] = false
                    return this
                }
            })
            
            /**
 * Setup the functions for the standard colors.
 */

Object.keys(colors).forEach(function (color) {
                var code = colors[color]
                
                Colorer.prototype[color] = function () {
                    this._setColorCode(this.base + code)
                    return this.cursor
                }
                
                Cursor.prototype[color] = function () {
                    return this.foreground[color]()
                }
            })
            
            /**
 * Makes a beep sound!
 */

Cursor.prototype.beep = function () {
                this.enabled && this.write('\x07')
                return this
            }
            
            /**
 * Moves cursor to specific position
 */

Cursor.prototype.goto = function (x, y) {
                x = x | 0
                y = y | 0
                this.enabled && this.write(prefix + y + ';' + x + 'H')
                return this
            }
            
            /**
 * Resets the color.
 */

Colorer.prototype.reset = function () {
                this._setColorCode(this.base + 39)
                return this.cursor
            }
            
            /**
 * Resets all ANSI formatting on the stream.
 */

Cursor.prototype.reset = function () {
                this.enabled && this.write(prefix + '0' + suffix)
                this.Bold = false
                this.Italic = false
                this.Underline = false
                this.Inverse = false
                this.foreground.current = null
                this.background.current = null
                return this
            }
            
            /**
 * Sets the foreground color with the given RGB values.
 * The closest match out of the 216 colors is picked.
 */

Colorer.prototype.rgb = function (r, g, b) {
                var base = this.base + 38
    , code = rgb(r, g, b)
                this._setColorCode(base + ';5;' + code)
                return this.cursor
            }
            
            /**
 * Same as `cursor.fg.rgb(r, g, b)`.
 */

Cursor.prototype.rgb = function (r, g, b) {
                return this.foreground.rgb(r, g, b)
            }
            
            /**
 * Accepts CSS color codes for use with ANSI escape codes.
 * For example: `#FF000` would be bright red.
 */

Colorer.prototype.hex = function (color) {
                return this.rgb.apply(this, hex(color))
            }
            
            /**
 * Same as `cursor.fg.hex(color)`.
 */

Cursor.prototype.hex = function (color) {
                return this.foreground.hex(color)
            }
            
            
            // UTIL FUNCTIONS //
            
            /**
 * Translates a 255 RGB value to a 0-5 ANSI RGV value,
 * then returns the single ANSI color code to use.
 */

function rgb(r, g, b) {
                var red = r / 255 * 5
    , green = g / 255 * 5
    , blue = b / 255 * 5
                return rgb5(red, green, blue)
            }
            
            /**
 * Turns rgb 0-5 values into a single ANSI color code to use.
 */

function rgb5(r, g, b) {
                var red = Math.round(r)
    , green = Math.round(g)
    , blue = Math.round(b)
                return 16 + (red * 36) + (green * 6) + blue
            }
            
            /**
 * Accepts a hex CSS color code string (# is optional) and
 * translates it into an Array of 3 RGB 0-255 values, which
 * can then be used with rgb().
 */

function hex(color) {
                var c = color[0] === '#' ? color.substring(1) : color
    , r = c.substring(0, 2)
    , g = c.substring(2, 4)
    , b = c.substring(4, 6)
                return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)]
            }
            
            /**
 * Turns an array-like object into a real array.
 */

function toArray(a) {
                var i = 0
    , l = a.length
    , rtn = []
                for (; i < l; i++) {
                    rtn.push(a[i])
                }
                return rtn
            }

        }, { "./newlines": 93 }], 93: [function (require, module, exports) {
            
            /**
 * Accepts any node Stream instance and hijacks its "write()" function,
 * so that it can count any newlines that get written to the output.
 *
 * When a '\n' byte is encountered, then a "newline" event will be emitted
 * on the stream, with no arguments. It is up to the listeners to determine
 * any necessary deltas required for their use-case.
 *
 * Ex:
 *
 *   var cursor = ansi(process.stdout)
 *     , ln = 0
 *   process.stdout.on('newline', function () {
 *    ln++
 *   })
 */

/**
 * Module dependencies.
 */

var assert = require('assert')
            var NEWLINE = '\n'.charCodeAt(0)
            
            function emitNewlineEvents(stream) {
                if (stream._emittingNewlines) {
                    // already emitting newline events
                    return
                }
                
                var write = stream.write
                
                stream.write = function (data) {
                    // first write the data
                    var rtn = write.apply(stream, arguments)
                    
                    if (stream.listeners('newline').length > 0) {
                        var len = data.length
        , i = 0
                        // now try to calculate any deltas
                        if (typeof data == 'string') {
                            for (; i < len; i++) {
                                processByte(stream, data.charCodeAt(i))
                            }
                        } else {
                            // buffer
                            for (; i < len; i++) {
                                processByte(stream, data[i])
                            }
                        }
                    }
                    
                    return rtn
                }
                
                stream._emittingNewlines = true
            }
            module.exports = emitNewlineEvents
            
            
            /**
 * Processes an individual byte being written to a stream
 */

function processByte(stream, b) {
                assert.equal(typeof b, 'number')
                if (b === NEWLINE) {
                    stream.emit('newline')
                }
            }

        }, { "assert": 170 }], 94: [function (require, module, exports) {
            "use strict"
            var stream = require("readable-stream");
            var EventEmitter = require("events").EventEmitter
            var util = require("util")
            var delegate = require("delegates")
            
            var TrackerGroup = exports.TrackerGroup = function (name) {
                EventEmitter.call(this)
                this.name = name
                this.trackGroup = []
                var self = this
                this.totalWeight = 0
                var noteChange = this.noteChange = function (name) {
                    self.emit("change", name || this.name)
                }.bind(this)
                this.trackGroup.forEach(function (unit) {
                    unit.on("change", noteChange)
                })
            }
            util.inherits(TrackerGroup, EventEmitter)
            
            TrackerGroup.prototype.completed = function () {
                if (this.trackGroup.length == 0) return 0
                var valPerWeight = 1 / this.totalWeight
                var completed = 0
                this.trackGroup.forEach(function (T) {
                    completed += valPerWeight * T.weight * T.completed()
                })
                return completed
            }
            
            TrackerGroup.prototype.addUnit = function (unit, weight, noChange) {
                unit.weight = weight || 1
                this.totalWeight += unit.weight
                this.trackGroup.push(unit)
                unit.on("change", this.noteChange)
                if (!noChange) this.emit("change", this.name)
                return unit
            }
            
            TrackerGroup.prototype.newGroup = function (name, weight) {
                return this.addUnit(new TrackerGroup(name), weight)
            }
            
            TrackerGroup.prototype.newItem = function (name, todo, weight) {
                return this.addUnit(new Tracker(name, todo), weight)
            }
            
            TrackerGroup.prototype.newStream = function (name, todo, weight) {
                return this.addUnit(new TrackerStream(name, todo), weight)
            }
            
            TrackerGroup.prototype.finish = function () {
                if (!this.trackGroup.length) { this.addUnit(new Tracker(), 1, true) }
                var self = this
                this.trackGroup.forEach(function (T) {
                    T.removeListener("change", self.noteChange)
                    T.finish()
                })
                this.emit("change", this.name)
            }
            
            var buffer = "                                  "
            TrackerGroup.prototype.debug = function (depth) {
                depth = depth || 0
                var indent = depth ? buffer.substr(0, depth) : ""
                var output = indent + (this.name || "top") + ": " + this.completed() + "\n"
                this.trackGroup.forEach(function (T) {
                    if (T instanceof TrackerGroup) {
                        output += T.debug(depth + 1)
                    }
                    else {
                        output += indent + " " + T.name + ": " + T.completed() + "\n"
                    }
                })
                return output
            }
            
            var Tracker = exports.Tracker = function (name, todo) {
                EventEmitter.call(this)
                this.name = name
                this.workDone = 0
                this.workTodo = todo || 0
            }
            util.inherits(Tracker, EventEmitter)
            
            Tracker.prototype.completed = function () {
                return this.workTodo == 0 ? 0 : this.workDone / this.workTodo
            }
            
            Tracker.prototype.addWork = function (work) {
                this.workTodo += work
                this.emit("change", this.name)
            }
            
            Tracker.prototype.completeWork = function (work) {
                this.workDone += work
                if (this.workDone > this.workTodo) this.workDone = this.workTodo
                this.emit("change", this.name)
            }
            
            Tracker.prototype.finish = function () {
                this.workTodo = this.workDone = 1
                this.emit("change", this.name)
            }
            
            
            var TrackerStream = exports.TrackerStream = function (name, size, options) {
                stream.Transform.call(this, options)
                this.tracker = new Tracker(name, size)
                this.name = name
                var self = this
                this.tracker.on("change", function (name) { self.emit("change", name) })
            }
            util.inherits(TrackerStream, stream.Transform)
            
            TrackerStream.prototype._transform = function (data, encoding, cb) {
                this.tracker.completeWork(data.length ? data.length : 1)
                this.push(data)
                cb()
            }
            
            TrackerStream.prototype._flush = function (cb) {
                this.tracker.finish()
                cb()
            }
            
            delegate(TrackerStream.prototype, "tracker")
  .method("completed")
  .method("addWork")

        }, { "delegates": 95, "events": 317, "readable-stream": 105, "util": 342 }], 95: [function (require, module, exports) {
            
            /**
 * Expose `Delegator`.
 */

module.exports = Delegator;
            
            /**
 * Initialize a delegator.
 *
 * @param {Object} proto
 * @param {String} target
 * @api public
 */

function Delegator(proto, target) {
                if (!(this instanceof Delegator)) return new Delegator(proto, target);
                this.proto = proto;
                this.target = target;
                this.methods = [];
                this.getters = [];
                this.setters = [];
                this.fluents = [];
            }
            
            /**
 * Delegate method `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.method = function (name) {
                var proto = this.proto;
                var target = this.target;
                this.methods.push(name);
                
                proto[name] = function () {
                    return this[target][name].apply(this[target], arguments);
                };
                
                return this;
            };
            
            /**
 * Delegator accessor `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.access = function (name) {
                return this.getter(name).setter(name);
            };
            
            /**
 * Delegator getter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.getter = function (name) {
                var proto = this.proto;
                var target = this.target;
                this.getters.push(name);
                
                proto.__defineGetter__(name, function () {
                    return this[target][name];
                });
                
                return this;
            };
            
            /**
 * Delegator setter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.setter = function (name) {
                var proto = this.proto;
                var target = this.target;
                this.setters.push(name);
                
                proto.__defineSetter__(name, function (val) {
                    return this[target][name] = val;
                });
                
                return this;
            };
            
            /**
 * Delegator fluent accessor
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.fluent = function (name) {
                var proto = this.proto;
                var target = this.target;
                this.fluents.push(name);
                
                proto[name] = function (val) {
                    if ('undefined' != typeof val) {
                        this[target][name] = val;
                        return this;
                    } else {
                        return this[target][name];
                    }
                };
                
                return this;
            };

        }, {}], 96: [function (require, module, exports) {
            (function (process) {
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                
                // a duplex stream is just a stream that is both readable and writable.
                // Since JS doesn't have multiple prototypal inheritance, this class
                // prototypally inherits from Readable, and then parasitically from
                // Writable.
                
                module.exports = Duplex;
                
                /*<replacement>*/
                var objectKeys = Object.keys || function (obj) {
                    var keys = [];
                    for (var key in obj) keys.push(key);
                    return keys;
                }
                /*</replacement>*/
                
                
                /*<replacement>*/
                var util = require('core-util-is');
                util.inherits = require('inherits');
                /*</replacement>*/
                
                var Readable = require('./_stream_readable');
                var Writable = require('./_stream_writable');
                
                util.inherits(Duplex, Readable);
                
                forEach(objectKeys(Writable.prototype), function (method) {
                    if (!Duplex.prototype[method])
                        Duplex.prototype[method] = Writable.prototype[method];
                });
                
                function Duplex(options) {
                    if (!(this instanceof Duplex))
                        return new Duplex(options);
                    
                    Readable.call(this, options);
                    Writable.call(this, options);
                    
                    if (options && options.readable === false)
                        this.readable = false;
                    
                    if (options && options.writable === false)
                        this.writable = false;
                    
                    this.allowHalfOpen = true;
                    if (options && options.allowHalfOpen === false)
                        this.allowHalfOpen = false;
                    
                    this.once('end', onend);
                }
                
                // the no-half-open enforcer
                function onend() {
                    // if we allow half-open state, or if the writable side ended,
                    // then we're ok.
                    if (this.allowHalfOpen || this._writableState.ended)
                        return;
                    
                    // no more data can be written.
                    // But allow more writes to happen in this tick.
                    process.nextTick(this.end.bind(this));
                }
                
                function forEach(xs, f) {
                    for (var i = 0, l = xs.length; i < l; i++) {
                        f(xs[i], i);
                    }
                }

            }).call(this, require('_process'))
        }, { "./_stream_readable": 98, "./_stream_writable": 100, "_process": 322, "core-util-is": 101, "inherits": 102 }], 97: [function (require, module, exports) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            
            // a passthrough stream.
            // basically just the most minimal sort of Transform stream.
            // Every written chunk gets output as-is.
            
            module.exports = PassThrough;
            
            var Transform = require('./_stream_transform');
            
            /*<replacement>*/
            var util = require('core-util-is');
            util.inherits = require('inherits');
            /*</replacement>*/
            
            util.inherits(PassThrough, Transform);
            
            function PassThrough(options) {
                if (!(this instanceof PassThrough))
                    return new PassThrough(options);
                
                Transform.call(this, options);
            }
            
            PassThrough.prototype._transform = function (chunk, encoding, cb) {
                cb(null, chunk);
            };

        }, { "./_stream_transform": 99, "core-util-is": 101, "inherits": 102 }], 98: [function (require, module, exports) {
            (function (process) {
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                
                module.exports = Readable;
                
                /*<replacement>*/
                var isArray = require('isarray');
                /*</replacement>*/
                
                
                /*<replacement>*/
                var Buffer = require('buffer').Buffer;
                /*</replacement>*/
                
                Readable.ReadableState = ReadableState;
                
                var EE = require('events').EventEmitter;
                
                /*<replacement>*/
                if (!EE.listenerCount) EE.listenerCount = function (emitter, type) {
                    return emitter.listeners(type).length;
                };
                /*</replacement>*/
                
                var Stream = require('stream');
                
                /*<replacement>*/
                var util = require('core-util-is');
                util.inherits = require('inherits');
                /*</replacement>*/
                
                var StringDecoder;
                
                
                /*<replacement>*/
                var debug = require('util');
                if (debug && debug.debuglog) {
                    debug = debug.debuglog('stream');
                } else {
                    debug = function () { };
                }
                /*</replacement>*/
                
                
                util.inherits(Readable, Stream);
                
                function ReadableState(options, stream) {
                    var Duplex = require('./_stream_duplex');
                    
                    options = options || {};
                    
                    // the point at which it stops calling _read() to fill the buffer
                    // Note: 0 is a valid value, means "don't call _read preemptively ever"
                    var hwm = options.highWaterMark;
                    var defaultHwm = options.objectMode ? 16 : 16 * 1024;
                    this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
                    
                    // cast to ints.
                    this.highWaterMark = ~~this.highWaterMark;
                    
                    this.buffer = [];
                    this.length = 0;
                    this.pipes = null;
                    this.pipesCount = 0;
                    this.flowing = null;
                    this.ended = false;
                    this.endEmitted = false;
                    this.reading = false;
                    
                    // a flag to be able to tell if the onwrite cb is called immediately,
                    // or on a later tick.  We set this to true at first, because any
                    // actions that shouldn't happen until "later" should generally also
                    // not happen before the first write call.
                    this.sync = true;
                    
                    // whenever we return null, then we set a flag to say
                    // that we're awaiting a 'readable' event emission.
                    this.needReadable = false;
                    this.emittedReadable = false;
                    this.readableListening = false;
                    
                    
                    // object stream flag. Used to make read(n) ignore n and to
                    // make all the buffer merging and length checks go away
                    this.objectMode = !!options.objectMode;
                    
                    if (stream instanceof Duplex)
                        this.objectMode = this.objectMode || !!options.readableObjectMode;
                    
                    // Crypto is kind of old and crusty.  Historically, its default string
                    // encoding is 'binary' so we have to make this configurable.
                    // Everything else in the universe uses 'utf8', though.
                    this.defaultEncoding = options.defaultEncoding || 'utf8';
                    
                    // when piping, we only care about 'readable' events that happen
                    // after read()ing all the bytes and not getting any pushback.
                    this.ranOut = false;
                    
                    // the number of writers that are awaiting a drain event in .pipe()s
                    this.awaitDrain = 0;
                    
                    // if true, a maybeReadMore has been scheduled
                    this.readingMore = false;
                    
                    this.decoder = null;
                    this.encoding = null;
                    if (options.encoding) {
                        if (!StringDecoder)
                            StringDecoder = require('string_decoder/').StringDecoder;
                        this.decoder = new StringDecoder(options.encoding);
                        this.encoding = options.encoding;
                    }
                }
                
                function Readable(options) {
                    var Duplex = require('./_stream_duplex');
                    
                    if (!(this instanceof Readable))
                        return new Readable(options);
                    
                    this._readableState = new ReadableState(options, this);
                    
                    // legacy
                    this.readable = true;
                    
                    Stream.call(this);
                }
                
                // Manually shove something into the read() buffer.
                // This returns true if the highWaterMark has not been hit yet,
                // similar to how Writable.write() returns true if you should
                // write() some more.
                Readable.prototype.push = function (chunk, encoding) {
                    var state = this._readableState;
                    
                    if (util.isString(chunk) && !state.objectMode) {
                        encoding = encoding || state.defaultEncoding;
                        if (encoding !== state.encoding) {
                            chunk = new Buffer(chunk, encoding);
                            encoding = '';
                        }
                    }
                    
                    return readableAddChunk(this, state, chunk, encoding, false);
                };
                
                // Unshift should *always* be something directly out of read()
                Readable.prototype.unshift = function (chunk) {
                    var state = this._readableState;
                    return readableAddChunk(this, state, chunk, '', true);
                };
                
                function readableAddChunk(stream, state, chunk, encoding, addToFront) {
                    var er = chunkInvalid(state, chunk);
                    if (er) {
                        stream.emit('error', er);
                    } else if (util.isNullOrUndefined(chunk)) {
                        state.reading = false;
                        if (!state.ended)
                            onEofChunk(stream, state);
                    } else if (state.objectMode || chunk && chunk.length > 0) {
                        if (state.ended && !addToFront) {
                            var e = new Error('stream.push() after EOF');
                            stream.emit('error', e);
                        } else if (state.endEmitted && addToFront) {
                            var e = new Error('stream.unshift() after end event');
                            stream.emit('error', e);
                        } else {
                            if (state.decoder && !addToFront && !encoding)
                                chunk = state.decoder.write(chunk);
                            
                            if (!addToFront)
                                state.reading = false;
                            
                            // if we want the data now, just emit it.
                            if (state.flowing && state.length === 0 && !state.sync) {
                                stream.emit('data', chunk);
                                stream.read(0);
                            } else {
                                // update the buffer info.
                                state.length += state.objectMode ? 1 : chunk.length;
                                if (addToFront)
                                    state.buffer.unshift(chunk);
                                else
                                    state.buffer.push(chunk);
                                
                                if (state.needReadable)
                                    emitReadable(stream);
                            }
                            
                            maybeReadMore(stream, state);
                        }
                    } else if (!addToFront) {
                        state.reading = false;
                    }
                    
                    return needMoreData(state);
                }
                
                
                
                // if it's past the high water mark, we can push in some more.
                // Also, if we have no data yet, we can stand some
                // more bytes.  This is to work around cases where hwm=0,
                // such as the repl.  Also, if the push() triggered a
                // readable event, and the user called read(largeNumber) such that
                // needReadable was set, then we ought to push more, so that another
                // 'readable' event will be triggered.
                function needMoreData(state) {
                    return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
                }
                
                // backwards compatibility.
                Readable.prototype.setEncoding = function (enc) {
                    if (!StringDecoder)
                        StringDecoder = require('string_decoder/').StringDecoder;
                    this._readableState.decoder = new StringDecoder(enc);
                    this._readableState.encoding = enc;
                    return this;
                };
                
                // Don't raise the hwm > 128MB
                var MAX_HWM = 0x800000;
                function roundUpToNextPowerOf2(n) {
                    if (n >= MAX_HWM) {
                        n = MAX_HWM;
                    } else {
                        // Get the next highest power of 2
                        n--;
                        for (var p = 1; p < 32; p <<= 1) n |= n >> p;
                        n++;
                    }
                    return n;
                }
                
                function howMuchToRead(n, state) {
                    if (state.length === 0 && state.ended)
                        return 0;
                    
                    if (state.objectMode)
                        return n === 0 ? 0 : 1;
                    
                    if (isNaN(n) || util.isNull(n)) {
                        // only flow one buffer at a time
                        if (state.flowing && state.buffer.length)
                            return state.buffer[0].length;
                        else
                            return state.length;
                    }
                    
                    if (n <= 0)
                        return 0;
                    
                    // If we're asking for more than the target buffer level,
                    // then raise the water mark.  Bump up to the next highest
                    // power of 2, to prevent increasing it excessively in tiny
                    // amounts.
                    if (n > state.highWaterMark)
                        state.highWaterMark = roundUpToNextPowerOf2(n);
                    
                    // don't have that much.  return null, unless we've ended.
                    if (n > state.length) {
                        if (!state.ended) {
                            state.needReadable = true;
                            return 0;
                        } else
                            return state.length;
                    }
                    
                    return n;
                }
                
                // you can override either this method, or the async _read(n) below.
                Readable.prototype.read = function (n) {
                    debug('read', n);
                    var state = this._readableState;
                    var nOrig = n;
                    
                    if (!util.isNumber(n) || n > 0)
                        state.emittedReadable = false;
                    
                    // if we're doing read(0) to trigger a readable event, but we
                    // already have a bunch of data in the buffer, then just trigger
                    // the 'readable' event and move on.
                    if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
                        debug('read: emitReadable', state.length, state.ended);
                        if (state.length === 0 && state.ended)
                            endReadable(this);
                        else
                            emitReadable(this);
                        return null;
                    }
                    
                    n = howMuchToRead(n, state);
                    
                    // if we've ended, and we're now clear, then finish it up.
                    if (n === 0 && state.ended) {
                        if (state.length === 0)
                            endReadable(this);
                        return null;
                    }
                    
                    // All the actual chunk generation logic needs to be
                    // *below* the call to _read.  The reason is that in certain
                    // synthetic stream cases, such as passthrough streams, _read
                    // may be a completely synchronous operation which may change
                    // the state of the read buffer, providing enough data when
                    // before there was *not* enough.
                    //
                    // So, the steps are:
                    // 1. Figure out what the state of things will be after we do
                    // a read from the buffer.
                    //
                    // 2. If that resulting state will trigger a _read, then call _read.
                    // Note that this may be asynchronous, or synchronous.  Yes, it is
                    // deeply ugly to write APIs this way, but that still doesn't mean
                    // that the Readable class should behave improperly, as streams are
                    // designed to be sync/async agnostic.
                    // Take note if the _read call is sync or async (ie, if the read call
                    // has returned yet), so that we know whether or not it's safe to emit
                    // 'readable' etc.
                    //
                    // 3. Actually pull the requested chunks out of the buffer and return.
                    
                    // if we need a readable event, then we need to do some reading.
                    var doRead = state.needReadable;
                    debug('need readable', doRead);
                    
                    // if we currently have less than the highWaterMark, then also read some
                    if (state.length === 0 || state.length - n < state.highWaterMark) {
                        doRead = true;
                        debug('length less than watermark', doRead);
                    }
                    
                    // however, if we've ended, then there's no point, and if we're already
                    // reading, then it's unnecessary.
                    if (state.ended || state.reading) {
                        doRead = false;
                        debug('reading or ended', doRead);
                    }
                    
                    if (doRead) {
                        debug('do read');
                        state.reading = true;
                        state.sync = true;
                        // if the length is currently zero, then we *need* a readable event.
                        if (state.length === 0)
                            state.needReadable = true;
                        // call internal read method
                        this._read(state.highWaterMark);
                        state.sync = false;
                    }
                    
                    // If _read pushed data synchronously, then `reading` will be false,
                    // and we need to re-evaluate how much data we can return to the user.
                    if (doRead && !state.reading)
                        n = howMuchToRead(nOrig, state);
                    
                    var ret;
                    if (n > 0)
                        ret = fromList(n, state);
                    else
                        ret = null;
                    
                    if (util.isNull(ret)) {
                        state.needReadable = true;
                        n = 0;
                    }
                    
                    state.length -= n;
                    
                    // If we have nothing in the buffer, then we want to know
                    // as soon as we *do* get something into the buffer.
                    if (state.length === 0 && !state.ended)
                        state.needReadable = true;
                    
                    // If we tried to read() past the EOF, then emit end on the next tick.
                    if (nOrig !== n && state.ended && state.length === 0)
                        endReadable(this);
                    
                    if (!util.isNull(ret))
                        this.emit('data', ret);
                    
                    return ret;
                };
                
                function chunkInvalid(state, chunk) {
                    var er = null;
                    if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
                        er = new TypeError('Invalid non-string/buffer chunk');
                    }
                    return er;
                }
                
                
                function onEofChunk(stream, state) {
                    if (state.decoder && !state.ended) {
                        var chunk = state.decoder.end();
                        if (chunk && chunk.length) {
                            state.buffer.push(chunk);
                            state.length += state.objectMode ? 1 : chunk.length;
                        }
                    }
                    state.ended = true;
                    
                    // emit 'readable' now to make sure it gets picked up.
                    emitReadable(stream);
                }
                
                // Don't emit readable right away in sync mode, because this can trigger
                // another read() call => stack overflow.  This way, it might trigger
                // a nextTick recursion warning, but that's not so bad.
                function emitReadable(stream) {
                    var state = stream._readableState;
                    state.needReadable = false;
                    if (!state.emittedReadable) {
                        debug('emitReadable', state.flowing);
                        state.emittedReadable = true;
                        if (state.sync)
                            process.nextTick(function () {
                                emitReadable_(stream);
                            });
                        else
                            emitReadable_(stream);
                    }
                }
                
                function emitReadable_(stream) {
                    debug('emit readable');
                    stream.emit('readable');
                    flow(stream);
                }
                
                
                // at this point, the user has presumably seen the 'readable' event,
                // and called read() to consume some data.  that may have triggered
                // in turn another _read(n) call, in which case reading = true if
                // it's in progress.
                // However, if we're not ended, or reading, and the length < hwm,
                // then go ahead and try to read some more preemptively.
                function maybeReadMore(stream, state) {
                    if (!state.readingMore) {
                        state.readingMore = true;
                        process.nextTick(function () {
                            maybeReadMore_(stream, state);
                        });
                    }
                }
                
                function maybeReadMore_(stream, state) {
                    var len = state.length;
                    while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
                        debug('maybeReadMore read 0');
                        stream.read(0);
                        if (len === state.length)
                            // didn't get any data, stop spinning.
                            break;
                        else
                            len = state.length;
                    }
                    state.readingMore = false;
                }
                
                // abstract method.  to be overridden in specific implementation classes.
                // call cb(er, data) where data is <= n in length.
                // for virtual (non-string, non-buffer) streams, "length" is somewhat
                // arbitrary, and perhaps not very meaningful.
                Readable.prototype._read = function (n) {
                    this.emit('error', new Error('not implemented'));
                };
                
                Readable.prototype.pipe = function (dest, pipeOpts) {
                    var src = this;
                    var state = this._readableState;
                    
                    switch (state.pipesCount) {
                        case 0:
                            state.pipes = dest;
                            break;
                        case 1:
                            state.pipes = [state.pipes, dest];
                            break;
                        default:
                            state.pipes.push(dest);
                            break;
                    }
                    state.pipesCount += 1;
                    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
                    
                    var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;
                    
                    var endFn = doEnd ? onend : cleanup;
                    if (state.endEmitted)
                        process.nextTick(endFn);
                    else
                        src.once('end', endFn);
                    
                    dest.on('unpipe', onunpipe);
                    function onunpipe(readable) {
                        debug('onunpipe');
                        if (readable === src) {
                            cleanup();
                        }
                    }
                    
                    function onend() {
                        debug('onend');
                        dest.end();
                    }
                    
                    // when the dest drains, it reduces the awaitDrain counter
                    // on the source.  This would be more elegant with a .once()
                    // handler in flow(), but adding and removing repeatedly is
                    // too slow.
                    var ondrain = pipeOnDrain(src);
                    dest.on('drain', ondrain);
                    
                    function cleanup() {
                        debug('cleanup');
                        // cleanup event handlers once the pipe is broken
                        dest.removeListener('close', onclose);
                        dest.removeListener('finish', onfinish);
                        dest.removeListener('drain', ondrain);
                        dest.removeListener('error', onerror);
                        dest.removeListener('unpipe', onunpipe);
                        src.removeListener('end', onend);
                        src.removeListener('end', cleanup);
                        src.removeListener('data', ondata);
                        
                        // if the reader is waiting for a drain event from this
                        // specific writer, then it would cause it to never start
                        // flowing again.
                        // So, if this is awaiting a drain, then we just call it now.
                        // If we don't know, then assume that we are waiting for one.
                        if (state.awaitDrain &&
                            (!dest._writableState || dest._writableState.needDrain))
                            ondrain();
                    }
                    
                    src.on('data', ondata);
                    function ondata(chunk) {
                        debug('ondata');
                        var ret = dest.write(chunk);
                        if (false === ret) {
                            debug('false write response, pause',
            src._readableState.awaitDrain);
                            src._readableState.awaitDrain++;
                            src.pause();
                        }
                    }
                    
                    // if the dest has an error, then stop piping into it.
                    // however, don't suppress the throwing behavior for this.
                    function onerror(er) {
                        debug('onerror', er);
                        unpipe();
                        dest.removeListener('error', onerror);
                        if (EE.listenerCount(dest, 'error') === 0)
                            dest.emit('error', er);
                    }
                    // This is a brutally ugly hack to make sure that our error handler
                    // is attached before any userland ones.  NEVER DO THIS.
                    if (!dest._events || !dest._events.error)
                        dest.on('error', onerror);
                    else if (isArray(dest._events.error))
                        dest._events.error.unshift(onerror);
                    else
                        dest._events.error = [onerror, dest._events.error];
                    
                    
                    
                    // Both close and finish should trigger unpipe, but only once.
                    function onclose() {
                        dest.removeListener('finish', onfinish);
                        unpipe();
                    }
                    dest.once('close', onclose);
                    function onfinish() {
                        debug('onfinish');
                        dest.removeListener('close', onclose);
                        unpipe();
                    }
                    dest.once('finish', onfinish);
                    
                    function unpipe() {
                        debug('unpipe');
                        src.unpipe(dest);
                    }
                    
                    // tell the dest that it's being piped to
                    dest.emit('pipe', src);
                    
                    // start the flow if it hasn't been started already.
                    if (!state.flowing) {
                        debug('pipe resume');
                        src.resume();
                    }
                    
                    return dest;
                };
                
                function pipeOnDrain(src) {
                    return function () {
                        var state = src._readableState;
                        debug('pipeOnDrain', state.awaitDrain);
                        if (state.awaitDrain)
                            state.awaitDrain--;
                        if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
                            state.flowing = true;
                            flow(src);
                        }
                    };
                }
                
                
                Readable.prototype.unpipe = function (dest) {
                    var state = this._readableState;
                    
                    // if we're not piping anywhere, then do nothing.
                    if (state.pipesCount === 0)
                        return this;
                    
                    // just one destination.  most common case.
                    if (state.pipesCount === 1) {
                        // passed in one, but it's not the right one.
                        if (dest && dest !== state.pipes)
                            return this;
                        
                        if (!dest)
                            dest = state.pipes;
                        
                        // got a match.
                        state.pipes = null;
                        state.pipesCount = 0;
                        state.flowing = false;
                        if (dest)
                            dest.emit('unpipe', this);
                        return this;
                    }
                    
                    // slow case. multiple pipe destinations.
                    
                    if (!dest) {
                        // remove all.
                        var dests = state.pipes;
                        var len = state.pipesCount;
                        state.pipes = null;
                        state.pipesCount = 0;
                        state.flowing = false;
                        
                        for (var i = 0; i < len; i++)
                            dests[i].emit('unpipe', this);
                        return this;
                    }
                    
                    // try to find the right one.
                    var i = indexOf(state.pipes, dest);
                    if (i === -1)
                        return this;
                    
                    state.pipes.splice(i, 1);
                    state.pipesCount -= 1;
                    if (state.pipesCount === 1)
                        state.pipes = state.pipes[0];
                    
                    dest.emit('unpipe', this);
                    
                    return this;
                };
                
                // set up data events if they are asked for
                // Ensure readable listeners eventually get something
                Readable.prototype.on = function (ev, fn) {
                    var res = Stream.prototype.on.call(this, ev, fn);
                    
                    // If listening to data, and it has not explicitly been paused,
                    // then call resume to start the flow of data on the next tick.
                    if (ev === 'data' && false !== this._readableState.flowing) {
                        this.resume();
                    }
                    
                    if (ev === 'readable' && this.readable) {
                        var state = this._readableState;
                        if (!state.readableListening) {
                            state.readableListening = true;
                            state.emittedReadable = false;
                            state.needReadable = true;
                            if (!state.reading) {
                                var self = this;
                                process.nextTick(function () {
                                    debug('readable nexttick read 0');
                                    self.read(0);
                                });
                            } else if (state.length) {
                                emitReadable(this, state);
                            }
                        }
                    }
                    
                    return res;
                };
                Readable.prototype.addListener = Readable.prototype.on;
                
                // pause() and resume() are remnants of the legacy readable stream API
                // If the user uses them, then switch into old mode.
                Readable.prototype.resume = function () {
                    var state = this._readableState;
                    if (!state.flowing) {
                        debug('resume');
                        state.flowing = true;
                        if (!state.reading) {
                            debug('resume read 0');
                            this.read(0);
                        }
                        resume(this, state);
                    }
                    return this;
                };
                
                function resume(stream, state) {
                    if (!state.resumeScheduled) {
                        state.resumeScheduled = true;
                        process.nextTick(function () {
                            resume_(stream, state);
                        });
                    }
                }
                
                function resume_(stream, state) {
                    state.resumeScheduled = false;
                    stream.emit('resume');
                    flow(stream);
                    if (state.flowing && !state.reading)
                        stream.read(0);
                }
                
                Readable.prototype.pause = function () {
                    debug('call pause flowing=%j', this._readableState.flowing);
                    if (false !== this._readableState.flowing) {
                        debug('pause');
                        this._readableState.flowing = false;
                        this.emit('pause');
                    }
                    return this;
                };
                
                function flow(stream) {
                    var state = stream._readableState;
                    debug('flow', state.flowing);
                    if (state.flowing) {
                        do {
                            var chunk = stream.read();
                        } while (null !== chunk && state.flowing);
                    }
                }
                
                // wrap an old-style stream as the async data source.
                // This is *not* part of the readable stream interface.
                // It is an ugly unfortunate mess of history.
                Readable.prototype.wrap = function (stream) {
                    var state = this._readableState;
                    var paused = false;
                    
                    var self = this;
                    stream.on('end', function () {
                        debug('wrapped end');
                        if (state.decoder && !state.ended) {
                            var chunk = state.decoder.end();
                            if (chunk && chunk.length)
                                self.push(chunk);
                        }
                        
                        self.push(null);
                    });
                    
                    stream.on('data', function (chunk) {
                        debug('wrapped data');
                        if (state.decoder)
                            chunk = state.decoder.write(chunk);
                        if (!chunk || !state.objectMode && !chunk.length)
                            return;
                        
                        var ret = self.push(chunk);
                        if (!ret) {
                            paused = true;
                            stream.pause();
                        }
                    });
                    
                    // proxy all the other methods.
                    // important when wrapping filters and duplexes.
                    for (var i in stream) {
                        if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
                            this[i] = function (method) {
                                return function () {
                                    return stream[method].apply(stream, arguments);
                                }
                            }(i);
                        }
                    }
                    
                    // proxy certain important events.
                    var events = ['error', 'close', 'destroy', 'pause', 'resume'];
                    forEach(events, function (ev) {
                        stream.on(ev, self.emit.bind(self, ev));
                    });
                    
                    // when we try to consume some more bytes, simply unpause the
                    // underlying stream.
                    self._read = function (n) {
                        debug('wrapped _read', n);
                        if (paused) {
                            paused = false;
                            stream.resume();
                        }
                    };
                    
                    return self;
                };
                
                
                
                // exposed for testing purposes only.
                Readable._fromList = fromList;
                
                // Pluck off n bytes from an array of buffers.
                // Length is the combined lengths of all the buffers in the list.
                function fromList(n, state) {
                    var list = state.buffer;
                    var length = state.length;
                    var stringMode = !!state.decoder;
                    var objectMode = !!state.objectMode;
                    var ret;
                    
                    // nothing in the list, definitely empty.
                    if (list.length === 0)
                        return null;
                    
                    if (length === 0)
                        ret = null;
                    else if (objectMode)
                        ret = list.shift();
                    else if (!n || n >= length) {
                        // read it all, truncate the array.
                        if (stringMode)
                            ret = list.join('');
                        else
                            ret = Buffer.concat(list, length);
                        list.length = 0;
                    } else {
                        // read just some of it.
                        if (n < list[0].length) {
                            // just take a part of the first list item.
                            // slice is the same for buffers and strings.
                            var buf = list[0];
                            ret = buf.slice(0, n);
                            list[0] = buf.slice(n);
                        } else if (n === list[0].length) {
                            // first list is a perfect match
                            ret = list.shift();
                        } else {
                            // complex case.
                            // we have enough to cover it, but it spans past the first buffer.
                            if (stringMode)
                                ret = '';
                            else
                                ret = new Buffer(n);
                            
                            var c = 0;
                            for (var i = 0, l = list.length; i < l && c < n; i++) {
                                var buf = list[0];
                                var cpy = Math.min(n - c, buf.length);
                                
                                if (stringMode)
                                    ret += buf.slice(0, cpy);
                                else
                                    buf.copy(ret, c, 0, cpy);
                                
                                if (cpy < buf.length)
                                    list[0] = buf.slice(cpy);
                                else
                                    list.shift();
                                
                                c += cpy;
                            }
                        }
                    }
                    
                    return ret;
                }
                
                function endReadable(stream) {
                    var state = stream._readableState;
                    
                    // If we get here before consuming all the bytes, then that is a
                    // bug in node.  Should never happen.
                    if (state.length > 0)
                        throw new Error('endReadable called on non-empty stream');
                    
                    if (!state.endEmitted) {
                        state.ended = true;
                        process.nextTick(function () {
                            // Check that we didn't get one last unshift.
                            if (!state.endEmitted && state.length === 0) {
                                state.endEmitted = true;
                                stream.readable = false;
                                stream.emit('end');
                            }
                        });
                    }
                }
                
                function forEach(xs, f) {
                    for (var i = 0, l = xs.length; i < l; i++) {
                        f(xs[i], i);
                    }
                }
                
                function indexOf(xs, x) {
                    for (var i = 0, l = xs.length; i < l; i++) {
                        if (xs[i] === x) return i;
                    }
                    return -1;
                }

            }).call(this, require('_process'))
        }, { "./_stream_duplex": 96, "_process": 322, "buffer": 172, "core-util-is": 101, "events": 317, "inherits": 102, "isarray": 103, "stream": 338, "string_decoder/": 104, "util": 171 }], 99: [function (require, module, exports) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            
            
            // a transform stream is a readable/writable stream where you do
            // something with the data.  Sometimes it's called a "filter",
            // but that's not a great name for it, since that implies a thing where
            // some bits pass through, and others are simply ignored.  (That would
            // be a valid example of a transform, of course.)
            //
            // While the output is causally related to the input, it's not a
            // necessarily symmetric or synchronous transformation.  For example,
            // a zlib stream might take multiple plain-text writes(), and then
            // emit a single compressed chunk some time in the future.
            //
            // Here's how this works:
            //
            // The Transform stream has all the aspects of the readable and writable
            // stream classes.  When you write(chunk), that calls _write(chunk,cb)
            // internally, and returns false if there's a lot of pending writes
            // buffered up.  When you call read(), that calls _read(n) until
            // there's enough pending readable data buffered up.
            //
            // In a transform stream, the written data is placed in a buffer.  When
            // _read(n) is called, it transforms the queued up data, calling the
            // buffered _write cb's as it consumes chunks.  If consuming a single
            // written chunk would result in multiple output chunks, then the first
            // outputted bit calls the readcb, and subsequent chunks just go into
            // the read buffer, and will cause it to emit 'readable' if necessary.
            //
            // This way, back-pressure is actually determined by the reading side,
            // since _read has to be called to start processing a new chunk.  However,
            // a pathological inflate type of transform can cause excessive buffering
            // here.  For example, imagine a stream where every byte of input is
            // interpreted as an integer from 0-255, and then results in that many
            // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
            // 1kb of data being output.  In this case, you could write a very small
            // amount of input, and end up with a very large amount of output.  In
            // such a pathological inflating mechanism, there'd be no way to tell
            // the system to stop doing the transform.  A single 4MB write could
            // cause the system to run out of memory.
            //
            // However, even in such a pathological case, only a single written chunk
            // would be consumed, and then the rest would wait (un-transformed) until
            // the results of the previous transformed chunk were consumed.
            
            module.exports = Transform;
            
            var Duplex = require('./_stream_duplex');
            
            /*<replacement>*/
            var util = require('core-util-is');
            util.inherits = require('inherits');
            /*</replacement>*/
            
            util.inherits(Transform, Duplex);
            
            
            function TransformState(options, stream) {
                this.afterTransform = function (er, data) {
                    return afterTransform(stream, er, data);
                };
                
                this.needTransform = false;
                this.transforming = false;
                this.writecb = null;
                this.writechunk = null;
            }
            
            function afterTransform(stream, er, data) {
                var ts = stream._transformState;
                ts.transforming = false;
                
                var cb = ts.writecb;
                
                if (!cb)
                    return stream.emit('error', new Error('no writecb in Transform class'));
                
                ts.writechunk = null;
                ts.writecb = null;
                
                if (!util.isNullOrUndefined(data))
                    stream.push(data);
                
                if (cb)
                    cb(er);
                
                var rs = stream._readableState;
                rs.reading = false;
                if (rs.needReadable || rs.length < rs.highWaterMark) {
                    stream._read(rs.highWaterMark);
                }
            }
            
            
            function Transform(options) {
                if (!(this instanceof Transform))
                    return new Transform(options);
                
                Duplex.call(this, options);
                
                this._transformState = new TransformState(options, this);
                
                // when the writable side finishes, then flush out anything remaining.
                var stream = this;
                
                // start out asking for a readable event once data is transformed.
                this._readableState.needReadable = true;
                
                // we have implemented the _read method, and done the other things
                // that Readable wants before the first _read call, so unset the
                // sync guard flag.
                this._readableState.sync = false;
                
                this.once('prefinish', function () {
                    if (util.isFunction(this._flush))
                        this._flush(function (er) {
                            done(stream, er);
                        });
                    else
                        done(stream);
                });
            }
            
            Transform.prototype.push = function (chunk, encoding) {
                this._transformState.needTransform = false;
                return Duplex.prototype.push.call(this, chunk, encoding);
            };
            
            // This is the part where you do stuff!
            // override this function in implementation classes.
            // 'chunk' is an input chunk.
            //
            // Call `push(newChunk)` to pass along transformed output
            // to the readable side.  You may call 'push' zero or more times.
            //
            // Call `cb(err)` when you are done with this chunk.  If you pass
            // an error, then that'll put the hurt on the whole operation.  If you
            // never call cb(), then you'll never get another chunk.
            Transform.prototype._transform = function (chunk, encoding, cb) {
                throw new Error('not implemented');
            };
            
            Transform.prototype._write = function (chunk, encoding, cb) {
                var ts = this._transformState;
                ts.writecb = cb;
                ts.writechunk = chunk;
                ts.writeencoding = encoding;
                if (!ts.transforming) {
                    var rs = this._readableState;
                    if (ts.needTransform ||
                        rs.needReadable ||
                        rs.length < rs.highWaterMark)
                        this._read(rs.highWaterMark);
                }
            };
            
            // Doesn't matter what the args are here.
            // _transform does all the work.
            // That we got here means that the readable side wants more data.
            Transform.prototype._read = function (n) {
                var ts = this._transformState;
                
                if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
                    ts.transforming = true;
                    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
                } else {
                    // mark that we need a transform, so that any data that comes in
                    // will get processed, now that we've asked for it.
                    ts.needTransform = true;
                }
            };
            
            
            function done(stream, er) {
                if (er)
                    return stream.emit('error', er);
                
                // if there's nothing in the write buffer, then that means
                // that nothing more will ever be provided
                var ws = stream._writableState;
                var ts = stream._transformState;
                
                if (ws.length)
                    throw new Error('calling transform done when ws.length != 0');
                
                if (ts.transforming)
                    throw new Error('calling transform done when still transforming');
                
                return stream.push(null);
            }

        }, { "./_stream_duplex": 96, "core-util-is": 101, "inherits": 102 }], 100: [function (require, module, exports) {
            (function (process) {
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                
                // A bit simpler than readable streams.
                // Implement an async ._write(chunk, cb), and it'll handle all
                // the drain event emission and buffering.
                
                module.exports = Writable;
                
                /*<replacement>*/
                var Buffer = require('buffer').Buffer;
                /*</replacement>*/
                
                Writable.WritableState = WritableState;
                
                
                /*<replacement>*/
                var util = require('core-util-is');
                util.inherits = require('inherits');
                /*</replacement>*/
                
                var Stream = require('stream');
                
                util.inherits(Writable, Stream);
                
                function WriteReq(chunk, encoding, cb) {
                    this.chunk = chunk;
                    this.encoding = encoding;
                    this.callback = cb;
                }
                
                function WritableState(options, stream) {
                    var Duplex = require('./_stream_duplex');
                    
                    options = options || {};
                    
                    // the point at which write() starts returning false
                    // Note: 0 is a valid value, means that we always return false if
                    // the entire buffer is not flushed immediately on write()
                    var hwm = options.highWaterMark;
                    var defaultHwm = options.objectMode ? 16 : 16 * 1024;
                    this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
                    
                    // object stream flag to indicate whether or not this stream
                    // contains buffers or objects.
                    this.objectMode = !!options.objectMode;
                    
                    if (stream instanceof Duplex)
                        this.objectMode = this.objectMode || !!options.writableObjectMode;
                    
                    // cast to ints.
                    this.highWaterMark = ~~this.highWaterMark;
                    
                    this.needDrain = false;
                    // at the start of calling end()
                    this.ending = false;
                    // when end() has been called, and returned
                    this.ended = false;
                    // when 'finish' is emitted
                    this.finished = false;
                    
                    // should we decode strings into buffers before passing to _write?
                    // this is here so that some node-core streams can optimize string
                    // handling at a lower level.
                    var noDecode = options.decodeStrings === false;
                    this.decodeStrings = !noDecode;
                    
                    // Crypto is kind of old and crusty.  Historically, its default string
                    // encoding is 'binary' so we have to make this configurable.
                    // Everything else in the universe uses 'utf8', though.
                    this.defaultEncoding = options.defaultEncoding || 'utf8';
                    
                    // not an actual buffer we keep track of, but a measurement
                    // of how much we're waiting to get pushed to some underlying
                    // socket or file.
                    this.length = 0;
                    
                    // a flag to see when we're in the middle of a write.
                    this.writing = false;
                    
                    // when true all writes will be buffered until .uncork() call
                    this.corked = 0;
                    
                    // a flag to be able to tell if the onwrite cb is called immediately,
                    // or on a later tick.  We set this to true at first, because any
                    // actions that shouldn't happen until "later" should generally also
                    // not happen before the first write call.
                    this.sync = true;
                    
                    // a flag to know if we're processing previously buffered items, which
                    // may call the _write() callback in the same tick, so that we don't
                    // end up in an overlapped onwrite situation.
                    this.bufferProcessing = false;
                    
                    // the callback that's passed to _write(chunk,cb)
                    this.onwrite = function (er) {
                        onwrite(stream, er);
                    };
                    
                    // the callback that the user supplies to write(chunk,encoding,cb)
                    this.writecb = null;
                    
                    // the amount that is being written when _write is called.
                    this.writelen = 0;
                    
                    this.buffer = [];
                    
                    // number of pending user-supplied write callbacks
                    // this must be 0 before 'finish' can be emitted
                    this.pendingcb = 0;
                    
                    // emit prefinish if the only thing we're waiting for is _write cbs
                    // This is relevant for synchronous Transform streams
                    this.prefinished = false;
                    
                    // True if the error was already emitted and should not be thrown again
                    this.errorEmitted = false;
                }
                
                function Writable(options) {
                    var Duplex = require('./_stream_duplex');
                    
                    // Writable ctor is applied to Duplexes, though they're not
                    // instanceof Writable, they're instanceof Readable.
                    if (!(this instanceof Writable) && !(this instanceof Duplex))
                        return new Writable(options);
                    
                    this._writableState = new WritableState(options, this);
                    
                    // legacy.
                    this.writable = true;
                    
                    Stream.call(this);
                }
                
                // Otherwise people can pipe Writable streams, which is just wrong.
                Writable.prototype.pipe = function () {
                    this.emit('error', new Error('Cannot pipe. Not readable.'));
                };
                
                
                function writeAfterEnd(stream, state, cb) {
                    var er = new Error('write after end');
                    // TODO: defer error events consistently everywhere, not just the cb
                    stream.emit('error', er);
                    process.nextTick(function () {
                        cb(er);
                    });
                }
                
                // If we get something that is not a buffer, string, null, or undefined,
                // and we're not in objectMode, then that's an error.
                // Otherwise stream chunks are all considered to be of length=1, and the
                // watermarks determine how many objects to keep in the buffer, rather than
                // how many bytes or characters.
                function validChunk(stream, state, chunk, cb) {
                    var valid = true;
                    if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
                        var er = new TypeError('Invalid non-string/buffer chunk');
                        stream.emit('error', er);
                        process.nextTick(function () {
                            cb(er);
                        });
                        valid = false;
                    }
                    return valid;
                }
                
                Writable.prototype.write = function (chunk, encoding, cb) {
                    var state = this._writableState;
                    var ret = false;
                    
                    if (util.isFunction(encoding)) {
                        cb = encoding;
                        encoding = null;
                    }
                    
                    if (util.isBuffer(chunk))
                        encoding = 'buffer';
                    else if (!encoding)
                        encoding = state.defaultEncoding;
                    
                    if (!util.isFunction(cb))
                        cb = function () { };
                    
                    if (state.ended)
                        writeAfterEnd(this, state, cb);
                    else if (validChunk(this, state, chunk, cb)) {
                        state.pendingcb++;
                        ret = writeOrBuffer(this, state, chunk, encoding, cb);
                    }
                    
                    return ret;
                };
                
                Writable.prototype.cork = function () {
                    var state = this._writableState;
                    
                    state.corked++;
                };
                
                Writable.prototype.uncork = function () {
                    var state = this._writableState;
                    
                    if (state.corked) {
                        state.corked--;
                        
                        if (!state.writing &&
                            !state.corked &&
                            !state.finished &&
                            !state.bufferProcessing &&
                            state.buffer.length)
                            clearBuffer(this, state);
                    }
                };
                
                function decodeChunk(state, chunk, encoding) {
                    if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
                        chunk = new Buffer(chunk, encoding);
                    }
                    return chunk;
                }
                
                // if we're already writing something, then just put this
                // in the queue, and wait our turn.  Otherwise, call _write
                // If we return false, then we need a drain event, so set that flag.
                function writeOrBuffer(stream, state, chunk, encoding, cb) {
                    chunk = decodeChunk(state, chunk, encoding);
                    if (util.isBuffer(chunk))
                        encoding = 'buffer';
                    var len = state.objectMode ? 1 : chunk.length;
                    
                    state.length += len;
                    
                    var ret = state.length < state.highWaterMark;
                    // we must ensure that previous needDrain will not be reset to false.
                    if (!ret)
                        state.needDrain = true;
                    
                    if (state.writing || state.corked)
                        state.buffer.push(new WriteReq(chunk, encoding, cb));
                    else
                        doWrite(stream, state, false, len, chunk, encoding, cb);
                    
                    return ret;
                }
                
                function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                    state.writelen = len;
                    state.writecb = cb;
                    state.writing = true;
                    state.sync = true;
                    if (writev)
                        stream._writev(chunk, state.onwrite);
                    else
                        stream._write(chunk, encoding, state.onwrite);
                    state.sync = false;
                }
                
                function onwriteError(stream, state, sync, er, cb) {
                    if (sync)
                        process.nextTick(function () {
                            state.pendingcb--;
                            cb(er);
                        });
                    else {
                        state.pendingcb--;
                        cb(er);
                    }
                    
                    stream._writableState.errorEmitted = true;
                    stream.emit('error', er);
                }
                
                function onwriteStateUpdate(state) {
                    state.writing = false;
                    state.writecb = null;
                    state.length -= state.writelen;
                    state.writelen = 0;
                }
                
                function onwrite(stream, er) {
                    var state = stream._writableState;
                    var sync = state.sync;
                    var cb = state.writecb;
                    
                    onwriteStateUpdate(state);
                    
                    if (er)
                        onwriteError(stream, state, sync, er, cb);
                    else {
                        // Check if we're actually ready to finish, but don't emit yet
                        var finished = needFinish(stream, state);
                        
                        if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
                            clearBuffer(stream, state);
                        }
                        
                        if (sync) {
                            process.nextTick(function () {
                                afterWrite(stream, state, finished, cb);
                            });
                        } else {
                            afterWrite(stream, state, finished, cb);
                        }
                    }
                }
                
                function afterWrite(stream, state, finished, cb) {
                    if (!finished)
                        onwriteDrain(stream, state);
                    state.pendingcb--;
                    cb();
                    finishMaybe(stream, state);
                }
                
                // Must force callback to be called on nextTick, so that we don't
                // emit 'drain' before the write() consumer gets the 'false' return
                // value, and has a chance to attach a 'drain' listener.
                function onwriteDrain(stream, state) {
                    if (state.length === 0 && state.needDrain) {
                        state.needDrain = false;
                        stream.emit('drain');
                    }
                }
                
                
                // if there's something in the buffer waiting, then process it
                function clearBuffer(stream, state) {
                    state.bufferProcessing = true;
                    
                    if (stream._writev && state.buffer.length > 1) {
                        // Fast case, write everything using _writev()
                        var cbs = [];
                        for (var c = 0; c < state.buffer.length; c++)
                            cbs.push(state.buffer[c].callback);
                        
                        // count the one we are adding, as well.
                        // TODO(isaacs) clean this up
                        state.pendingcb++;
                        doWrite(stream, state, true, state.length, state.buffer, '', function (err) {
                            for (var i = 0; i < cbs.length; i++) {
                                state.pendingcb--;
                                cbs[i](err);
                            }
                        });
                        
                        // Clear buffer
                        state.buffer = [];
                    } else {
                        // Slow case, write chunks one-by-one
                        for (var c = 0; c < state.buffer.length; c++) {
                            var entry = state.buffer[c];
                            var chunk = entry.chunk;
                            var encoding = entry.encoding;
                            var cb = entry.callback;
                            var len = state.objectMode ? 1 : chunk.length;
                            
                            doWrite(stream, state, false, len, chunk, encoding, cb);
                            
                            // if we didn't call the onwrite immediately, then
                            // it means that we need to wait until it does.
                            // also, that means that the chunk and cb are currently
                            // being processed, so move the buffer counter past them.
                            if (state.writing) {
                                c++;
                                break;
                            }
                        }
                        
                        if (c < state.buffer.length)
                            state.buffer = state.buffer.slice(c);
                        else
                            state.buffer.length = 0;
                    }
                    
                    state.bufferProcessing = false;
                }
                
                Writable.prototype._write = function (chunk, encoding, cb) {
                    cb(new Error('not implemented'));

                };
                
                Writable.prototype._writev = null;
                
                Writable.prototype.end = function (chunk, encoding, cb) {
                    var state = this._writableState;
                    
                    if (util.isFunction(chunk)) {
                        cb = chunk;
                        chunk = null;
                        encoding = null;
                    } else if (util.isFunction(encoding)) {
                        cb = encoding;
                        encoding = null;
                    }
                    
                    if (!util.isNullOrUndefined(chunk))
                        this.write(chunk, encoding);
                    
                    // .end() fully uncorks
                    if (state.corked) {
                        state.corked = 1;
                        this.uncork();
                    }
                    
                    // ignore unnecessary end() calls.
                    if (!state.ending && !state.finished)
                        endWritable(this, state, cb);
                };
                
                
                function needFinish(stream, state) {
                    return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
                }
                
                function prefinish(stream, state) {
                    if (!state.prefinished) {
                        state.prefinished = true;
                        stream.emit('prefinish');
                    }
                }
                
                function finishMaybe(stream, state) {
                    var need = needFinish(stream, state);
                    if (need) {
                        if (state.pendingcb === 0) {
                            prefinish(stream, state);
                            state.finished = true;
                            stream.emit('finish');
                        } else
                            prefinish(stream, state);
                    }
                    return need;
                }
                
                function endWritable(stream, state, cb) {
                    state.ending = true;
                    finishMaybe(stream, state);
                    if (cb) {
                        if (state.finished)
                            process.nextTick(cb);
                        else
                            stream.once('finish', cb);
                    }
                    state.ended = true;
                }

            }).call(this, require('_process'))
        }, { "./_stream_duplex": 96, "_process": 322, "buffer": 172, "core-util-is": 101, "inherits": 102, "stream": 338 }], 101: [function (require, module, exports) {
            (function (Buffer) {
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                exports.isArray = isArray;
                
                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }
                exports.isBoolean = isBoolean;
                
                function isNull(arg) {
                    return arg === null;
                }
                exports.isNull = isNull;
                
                function isNullOrUndefined(arg) {
                    return arg == null;
                }
                exports.isNullOrUndefined = isNullOrUndefined;
                
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                exports.isNumber = isNumber;
                
                function isString(arg) {
                    return typeof arg === 'string';
                }
                exports.isString = isString;
                
                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }
                exports.isSymbol = isSymbol;
                
                function isUndefined(arg) {
                    return arg === void 0;
                }
                exports.isUndefined = isUndefined;
                
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }
                exports.isRegExp = isRegExp;
                
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                exports.isObject = isObject;
                
                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }
                exports.isDate = isDate;
                
                function isError(e) {
                    return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
                }
                exports.isError = isError;
                
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                exports.isFunction = isFunction;
                
                function isPrimitive(arg) {
                    return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
                }
                exports.isPrimitive = isPrimitive;
                
                function isBuffer(arg) {
                    return Buffer.isBuffer(arg);
                }
                exports.isBuffer = isBuffer;
                
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 102: [function (require, module, exports) {
            if (typeof Object.create === 'function') {
                // implementation from standard node.js 'util' module
                module.exports = function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor
                    ctor.prototype = Object.create(superCtor.prototype, {
                        constructor: {
                            value: ctor,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                };
            } else {
                // old school shim for old browsers
                module.exports = function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor
                    var TempCtor = function () { }
                    TempCtor.prototype = superCtor.prototype
                    ctor.prototype = new TempCtor()
                    ctor.prototype.constructor = ctor
                }
            }

        }, {}], 103: [function (require, module, exports) {
            module.exports = Array.isArray || function (arr) {
                return Object.prototype.toString.call(arr) == '[object Array]';
            };

        }, {}], 104: [function (require, module, exports) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            
            var Buffer = require('buffer').Buffer;
            
            var isBufferEncoding = Buffer.isEncoding 
  || function (encoding) {
                switch (encoding && encoding.toLowerCase()) {
                    case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
                    default: return false;
                }
            }
            
            
            function assertEncoding(encoding) {
                if (encoding && !isBufferEncoding(encoding)) {
                    throw new Error('Unknown encoding: ' + encoding);
                }
            }
            
            // StringDecoder provides an interface for efficiently splitting a series of
            // buffers into a series of JS strings without breaking apart multi-byte
            // characters. CESU-8 is handled as part of the UTF-8 encoding.
            //
            // @TODO Handling all encodings inside a single object makes it very difficult
            // to reason about this code, so it should be split up in the future.
            // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
            // points as used by CESU-8.
            var StringDecoder = exports.StringDecoder = function (encoding) {
                this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
                assertEncoding(encoding);
                switch (this.encoding) {
                    case 'utf8':
                        // CESU-8 represents each of Surrogate Pair by 3-bytes
                        this.surrogateSize = 3;
                        break;
                    case 'ucs2':
                    case 'utf16le':
                        // UTF-16 represents each of Surrogate Pair by 2-bytes
                        this.surrogateSize = 2;
                        this.detectIncompleteChar = utf16DetectIncompleteChar;
                        break;
                    case 'base64':
                        // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
                        this.surrogateSize = 3;
                        this.detectIncompleteChar = base64DetectIncompleteChar;
                        break;
                    default:
                        this.write = passThroughWrite;
                        return;
                }
                
                // Enough space to store all bytes of a single character. UTF-8 needs 4
                // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
                this.charBuffer = new Buffer(6);
                // Number of bytes received for the current incomplete multi-byte character.
                this.charReceived = 0;
                // Number of bytes expected for the current incomplete multi-byte character.
                this.charLength = 0;
            };
            
            
            // write decodes the given buffer and returns it as JS string that is
            // guaranteed to not contain any partial multi-byte characters. Any partial
            // character found at the end of the buffer is buffered up, and will be
            // returned when calling write again with the remaining bytes.
            //
            // Note: Converting a Buffer containing an orphan surrogate to a String
            // currently works, but converting a String to a Buffer (via `new Buffer`, or
            // Buffer#write) will replace incomplete surrogates with the unicode
            // replacement character. See https://codereview.chromium.org/121173009/ .
            StringDecoder.prototype.write = function (buffer) {
                var charStr = '';
                // if our last write ended with an incomplete multibyte character
                while (this.charLength) {
                    // determine how many remaining bytes this buffer has to offer for this char
                    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;
                    
                    // add the new bytes to the char buffer
                    buffer.copy(this.charBuffer, this.charReceived, 0, available);
                    this.charReceived += available;
                    
                    if (this.charReceived < this.charLength) {
                        // still not enough chars in this buffer? wait for more ...
                        return '';
                    }
                    
                    // remove bytes belonging to the current character from the buffer
                    buffer = buffer.slice(available, buffer.length);
                    
                    // get the character that was split
                    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
                    
                    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
                    var charCode = charStr.charCodeAt(charStr.length - 1);
                    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                        this.charLength += this.surrogateSize;
                        charStr = '';
                        continue;
                    }
                    this.charReceived = this.charLength = 0;
                    
                    // if there are no more bytes in this buffer, just emit our char
                    if (buffer.length === 0) {
                        return charStr;
                    }
                    break;
                }
                
                // determine and set charLength / charReceived
                this.detectIncompleteChar(buffer);
                
                var end = buffer.length;
                if (this.charLength) {
                    // buffer the incomplete character bytes we got
                    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
                    end -= this.charReceived;
                }
                
                charStr += buffer.toString(this.encoding, 0, end);
                
                var end = charStr.length - 1;
                var charCode = charStr.charCodeAt(end);
                // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
                if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                    var size = this.surrogateSize;
                    this.charLength += size;
                    this.charReceived += size;
                    this.charBuffer.copy(this.charBuffer, size, 0, size);
                    buffer.copy(this.charBuffer, 0, 0, size);
                    return charStr.substring(0, end);
                }
                
                // or just emit the charStr
                return charStr;
            };
            
            // detectIncompleteChar determines if there is an incomplete UTF-8 character at
            // the end of the given buffer. If so, it sets this.charLength to the byte
            // length that character, and sets this.charReceived to the number of bytes
            // that are available for this character.
            StringDecoder.prototype.detectIncompleteChar = function (buffer) {
                // determine how many bytes we have to check at the end of this buffer
                var i = (buffer.length >= 3) ? 3 : buffer.length;
                
                // Figure out if one of the last i bytes of our buffer announces an
                // incomplete char.
                for (; i > 0; i--) {
                    var c = buffer[buffer.length - i];
                    
                    // See http://en.wikipedia.org/wiki/UTF-8#Description
                    
                    // 110XXXXX
                    if (i == 1 && c >> 5 == 0x06) {
                        this.charLength = 2;
                        break;
                    }
                    
                    // 1110XXXX
                    if (i <= 2 && c >> 4 == 0x0E) {
                        this.charLength = 3;
                        break;
                    }
                    
                    // 11110XXX
                    if (i <= 3 && c >> 3 == 0x1E) {
                        this.charLength = 4;
                        break;
                    }
                }
                this.charReceived = i;
            };
            
            StringDecoder.prototype.end = function (buffer) {
                var res = '';
                if (buffer && buffer.length)
                    res = this.write(buffer);
                
                if (this.charReceived) {
                    var cr = this.charReceived;
                    var buf = this.charBuffer;
                    var enc = this.encoding;
                    res += buf.slice(0, cr).toString(enc);
                }
                
                return res;
            };
            
            function passThroughWrite(buffer) {
                return buffer.toString(this.encoding);
            }
            
            function utf16DetectIncompleteChar(buffer) {
                this.charReceived = buffer.length % 2;
                this.charLength = this.charReceived ? 2 : 0;
            }
            
            function base64DetectIncompleteChar(buffer) {
                this.charReceived = buffer.length % 3;
                this.charLength = this.charReceived ? 3 : 0;
            }

        }, { "buffer": 172 }], 105: [function (require, module, exports) {
            exports = module.exports = require('./lib/_stream_readable.js');
            exports.Stream = require('stream');
            exports.Readable = exports;
            exports.Writable = require('./lib/_stream_writable.js');
            exports.Duplex = require('./lib/_stream_duplex.js');
            exports.Transform = require('./lib/_stream_transform.js');
            exports.PassThrough = require('./lib/_stream_passthrough.js');

        }, { "./lib/_stream_duplex.js": 96, "./lib/_stream_passthrough.js": 97, "./lib/_stream_readable.js": 98, "./lib/_stream_transform.js": 99, "./lib/_stream_writable.js": 100, "stream": 338 }], 106: [function (require, module, exports) {
            (function (process) {
                "use strict"
                var os = require("os")
                var child_process = require("child_process")
                
                var hasUnicode = module.exports = function () {
                    // Supported Win32 platforms (>XP) support unicode in the console, though
                    // font support isn't fantastic.
                    if (os.type() == "Windows_NT") { return true }
                    
                    var isUTF8 = /[.]UTF-8/
                    if (isUTF8.test(process.env.LC_ALL) 
   || process.env.LC_CTYPE == 'UTF-8' 
   || isUTF8.test(process.env.LANG)) {
                        return true
                    }
                    
                    return false
                }

            }).call(this, require('_process'))
        }, { "_process": 322, "child_process": 169, "os": 320 }], 107: [function (require, module, exports) {
            (function (global) {
                /**
 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseToString = require('lodash._basetostring'),
                    createPadding = require('lodash._createpadding');
                
                /** Native method references. */
                var ceil = Math.ceil,
                    floor = Math.floor;
                
                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeIsFinite = global.isFinite;
                
                /**
 * Pads `string` on the left and right sides if it is shorter than `length`.
 * Padding characters are truncated if they can't be evenly divided by `length`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.pad('abc', 8);
 * // => '  abc   '
 *
 * _.pad('abc', 8, '_-');
 * // => '_-abc_-_'
 *
 * _.pad('abc', 3);
 * // => 'abc'
 */
function pad(string, length, chars) {
                    string = baseToString(string);
                    length = +length;
                    
                    var strLength = string.length;
                    if (strLength >= length || !nativeIsFinite(length)) {
                        return string;
                    }
                    var mid = (length - strLength) / 2,
                        leftLength = floor(mid),
                        rightLength = ceil(mid);
                    
                    chars = createPadding('', rightLength, chars);
                    return chars.slice(0, leftLength) + string + chars;
                }
                
                module.exports = pad;

            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, { "lodash._basetostring": 108, "lodash._createpadding": 109 }], 108: [function (require, module, exports) {
            /**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Converts `value` to a string if it is not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
                if (typeof value == 'string') {
                    return value;
                }
                return value == null ? '' : (value + '');
            }
            
            module.exports = baseToString;

        }, {}], 109: [function (require, module, exports) {
            (function (global) {
                /**
 * lodash 3.6.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var repeat = require('lodash.repeat');
                
                /** Native method references. */
                var ceil = Math.ceil;
                
                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeIsFinite = global.isFinite;
                
                /**
 * Creates the padding required for `string` based on the given `length`.
 * The `chars` string is truncated if the number of characters exceeds `length`.
 *
 * @private
 * @param {string} string The string to create padding for.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the pad for `string`.
 */
function createPadding(string, length, chars) {
                    var strLength = string.length;
                    length = +length;
                    
                    if (strLength >= length || !nativeIsFinite(length)) {
                        return '';
                    }
                    var padLength = length - strLength;
                    chars = chars == null ? ' ' : (chars + '');
                    return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
                }
                
                module.exports = createPadding;

            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, { "lodash.repeat": 110 }], 110: [function (require, module, exports) {
            (function (global) {
                /**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseToString = require('lodash._basetostring');
                
                /** Native method references. */
                var floor = Math.floor;
                
                /* Native method references for those with the same name as other `lodash` methods. */
                var nativeIsFinite = global.isFinite;
                
                /**
 * Repeats the given string `n` times.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to repeat.
 * @param {number} [n=0] The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 * @example
 *
 * _.repeat('*', 3);
 * // => '***'
 *
 * _.repeat('abc', 2);
 * // => 'abcabc'
 *
 * _.repeat('abc', 0);
 * // => ''
 */
function repeat(string, n) {
                    var result = '';
                    string = baseToString(string);
                    n = +n;
                    if (n < 1 || !string || !nativeIsFinite(n)) {
                        return result;
                    }
                    // Leverage the exponentiation by squaring algorithm for a faster repeat.
                    // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                    do {
                        if (n % 2) {
                            result += string;
                        }
                        n = floor(n / 2);
                        string += string;
                    } while (n);
                    
                    return result;
                }
                
                module.exports = repeat;

            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, { "lodash._basetostring": 108 }], 111: [function (require, module, exports) {
            /**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseToString = require('lodash._basetostring'),
                createPadding = require('lodash._createpadding');
            
            /**
 * Creates a function for `_.padLeft` or `_.padRight`.
 *
 * @private
 * @param {boolean} [fromRight] Specify padding from the right.
 * @returns {Function} Returns the new pad function.
 */
function createPadDir(fromRight) {
                return function (string, length, chars) {
                    string = baseToString(string);
                    return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
                };
            }
            
            /**
 * Pads `string` on the left side if it is shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padLeft('abc', 6);
 * // => '   abc'
 *
 * _.padLeft('abc', 6, '_-');
 * // => '_-_abc'
 *
 * _.padLeft('abc', 3);
 * // => 'abc'
 */
var padLeft = createPadDir();
            
            module.exports = padLeft;

        }, { "lodash._basetostring": 112, "lodash._createpadding": 113 }], 112: [function (require, module, exports) {
            arguments[4][108][0].apply(exports, arguments)
        }, { "dup": 108 }], 113: [function (require, module, exports) {
            arguments[4][109][0].apply(exports, arguments)
        }, { "dup": 109, "lodash.repeat": 114 }], 114: [function (require, module, exports) {
            arguments[4][110][0].apply(exports, arguments)
        }, { "dup": 110, "lodash._basetostring": 112 }], 115: [function (require, module, exports) {
            /**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseToString = require('lodash._basetostring'),
                createPadding = require('lodash._createpadding');
            
            /**
 * Creates a function for `_.padLeft` or `_.padRight`.
 *
 * @private
 * @param {boolean} [fromRight] Specify padding from the right.
 * @returns {Function} Returns the new pad function.
 */
function createPadDir(fromRight) {
                return function (string, length, chars) {
                    string = baseToString(string);
                    return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
                };
            }
            
            /**
 * Pads `string` on the right side if it is shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padRight('abc', 6);
 * // => 'abc   '
 *
 * _.padRight('abc', 6, '_-');
 * // => 'abc_-_'
 *
 * _.padRight('abc', 3);
 * // => 'abc'
 */
var padRight = createPadDir(true);
            
            module.exports = padRight;

        }, { "lodash._basetostring": 116, "lodash._createpadding": 117 }], 116: [function (require, module, exports) {
            arguments[4][108][0].apply(exports, arguments)
        }, { "dup": 108 }], 117: [function (require, module, exports) {
            arguments[4][109][0].apply(exports, arguments)
        }, { "dup": 109, "lodash.repeat": 118 }], 118: [function (require, module, exports) {
            arguments[4][110][0].apply(exports, arguments)
        }, { "dup": 110, "lodash._basetostring": 116 }], 119: [function (require, module, exports) {
            (function (process) {
                "use strict"
                var hasUnicode = require("has-unicode")
                var ansi = require("ansi")
                var align = {
                    center: require("lodash.pad"),
                    left: require("lodash.padright"),
                    right: require("lodash.padleft")
                }
                var defaultStream = process.stderr
                function isTTY() {
                    return process.stderr.isTTY
                }
                function getWritableTTYColumns() {
                    // One less than the actual as writing to the final column wraps the line
                    return process.stderr.columns - 1
                }
                
                var ProgressBar = module.exports = function (options, cursor) {
                    if (!options) options = {}
                    if (!cursor && options.write) {
                        cursor = options
                        options = {}
                    }
                    if (!cursor) {
                        cursor = ansi(defaultStream)
                    }
                    this.cursor = cursor
                    this.showing = false
                    this.theme = options.theme || (hasUnicode() ? ProgressBar.unicode : ProgressBar.ascii)
                    this.template = options.template || [
                        { type: "name", separated: true, length: 25 },
                        { type: "spinner", separated: true },
                        { type: "startgroup" },
                        { type: "completionbar" },
                        { type: "endgroup" }
                    ]
                    this.updatefreq = options.maxUpdateFrequency || 50
                    this.lastName = ""
                    this.lastCompleted = 0
                    this.spun = 0
                    this.last = new Date(0)
                }
                ProgressBar.prototype = {}
                
                ProgressBar.unicode = {
                    startgroup: "â•¢",
                    endgroup: "â•Ÿ",
                    complete: "â–ˆ",
                    incomplete: "â–‘",
                    spinner: "â–€â–â–„â–Œ",
                    subsection: "â†’"
                }
                
                ProgressBar.ascii = {
                    startgroup: "|",
                    endgroup: "|",
                    complete: "#",
                    incomplete: "-",
                    spinner: "-\\|/",
                    subsection: "->"
                }
                
                ProgressBar.prototype.setTheme = function (theme) {
                    this.theme = theme
                }
                
                ProgressBar.prototype.setTemplate = function (template) {
                    this.template = template
                }
                
                ProgressBar.prototype.disable = function () {
                    this.hide()
                    this.disabled = true
                }
                
                ProgressBar.prototype.enable = function () {
                    this.disabled = false
                    this.show()
                }
                
                ProgressBar.prototype.hide = function () {
                    if (!isTTY()) return
                    if (this.disabled) return
                    this.cursor.show()
                    if (this.showing) this.cursor.up(1)
                    this.cursor.horizontalAbsolute(0).eraseLine()
                    this.showing = false
                }
                
                var repeat = function (str, count) {
                    var out = ""
                    for (var ii = 0; ii < count; ++ii) out += str
                    return out
                }
                
                ProgressBar.prototype.pulse = function (name) {
                    ++this.spun
                    if (!this.showing) return
                    if (this.disabled) return
                    
                    var baseName = this.lastName
                    name = name
       ? (baseName
         ? baseName + " " + this.theme.subsection + " " + name
         : null)
       : baseName
                    this.show(name)
                    this.lastName = baseName
                }
                
                ProgressBar.prototype.show = function (name, completed) {
                    name = this.lastName = name || this.lastName
                    completed = this.lastCompleted = completed || this.lastCompleted
                    
                    if (!isTTY()) return
                    if (this.disabled) return
                    if (!this.spun && !completed) return
                    if (this.tryAgain) {
                        clearTimeout(this.tryAgain)
                        this.tryAgain = null
                    }
                    var self = this
                    if (this.showing && new Date() - this.last < this.updatefreq) {
                        this.tryAgain = setTimeout(function () {
                            if (self.disabled) return
                            if (!self.spun && !completed) return
                            drawBar()
                        }, this.updatefreq - (new Date() - this.last))
                        return
                    }
                    
                    return drawBar()
                    
                    function drawBar() {
                        var values = {
                            name: name,
                            spinner: self.spun,
                            completed: completed
                        }
                        
                        self.last = new Date()
                        
                        var statusline = self.renderTemplate(self.theme, self.template, values)
                        
                        if (self.showing) self.cursor.up(1)
                        self.cursor
        .hide()
        .horizontalAbsolute(0)
        .write(statusline.substr(0, getWritableTTYColumns()) + "\n")
        .show()
                        
                        self.showing = true
                    }
                }
                
                ProgressBar.prototype.renderTemplate = function (theme, template, values) {
                    values.startgroup = theme.startgroup
                    values.endgroup = theme.endgroup
                    values.spinner = values.spinner
    ? theme.spinner.substr(values.spinner % theme.spinner.length, 1)
    : ""
                    
                    var output = { prebar: "", postbar: "" }
                    var status = "prebar"
                    var self = this
                    template.forEach(function (T) {
                        if (typeof T === "string") {
                            output[status] += T
                            return
                        }
                        if (T.type === "completionbar") {
                            status = "postbar"
                            return
                        }
                        if (!values.hasOwnProperty(T.type)) throw new Error("Unknown template value '" + T.type + "'")
                        var value = self.renderValue(T, values[T.type])
                        if (value === "") return
                        var sofar = output[status].length
                        var lastChar = sofar ? output[status][sofar - 1] : null
                        if (T.separated && sofar && lastChar !== " ") {
                            output[status] += " "
                        }
                        output[status] += value
                        if (T.separated) output[status] += " "
                    })
                    
                    var bar = ""
                    if (status === "postbar") {
                        var nonBarLen = output.prebar.length + output.postbar.length
                        
                        var barLen = getWritableTTYColumns() - nonBarLen
                        var sofar = Math.round(barLen * Math.max(0, Math.min(1, values.completed || 0)))
                        var rest = barLen - sofar
                        bar = repeat(theme.complete, sofar) 
        + repeat(theme.incomplete, rest)
                    }
                    
                    return output.prebar + bar + output.postbar
                }
                ProgressBar.prototype.renderValue = function (template, value) {
                    if (value == null || value === "") return ""
                    var maxLength = template.maxLength || template.length
                    var minLength = template.minLength || template.length
                    var alignWith = align[template.align] || align.left
                    //  if (maxLength) value = value.substr(-1 * maxLength)
                    if (maxLength) value = value.substr(0, maxLength)
                    if (minLength) value = alignWith(value, minLength)
                    return value
                }

            }).call(this, require('_process'))
        }, { "_process": 322, "ansi": 92, "has-unicode": 106, "lodash.pad": 107, "lodash.padleft": 111, "lodash.padright": 115 }], 120: [function (require, module, exports) {
            ; (function (exports) {
                
                // export the class if we are in a Node-like system.
                if (typeof module === 'object' && module.exports === exports)
                    exports = module.exports = SemVer;
                
                // The debug function is excluded entirely from the minified version.
                
                // Note: this is the semver.org version of the spec that it implements
                // Not necessarily the package version of this code.
                exports.SEMVER_SPEC_VERSION = '2.0.0';
                
                var MAX_LENGTH = 256;
                var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
                
                // The actual regexps go on exports.re
                var re = exports.re = [];
                var src = exports.src = [];
                var R = 0;
                
                // The following Regular Expressions can be used for tokenizing,
                // validating, and parsing SemVer version strings.
                
                // ## Numeric Identifier
                // A single `0`, or a non-zero digit followed by zero or more digits.
                
                var NUMERICIDENTIFIER = R++;
                src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
                var NUMERICIDENTIFIERLOOSE = R++;
                src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
                
                
                // ## Non-numeric Identifier
                // Zero or more digits, followed by a letter or hyphen, and then zero or
                // more letters, digits, or hyphens.
                
                var NONNUMERICIDENTIFIER = R++;
                src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
                
                
                // ## Main Version
                // Three dot-separated numeric identifiers.
                
                var MAINVERSION = R++;
                src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';
                
                var MAINVERSIONLOOSE = R++;
                src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
                
                // ## Pre-release Version Identifier
                // A numeric identifier, or a non-numeric identifier.
                
                var PRERELEASEIDENTIFIER = R++;
                src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';
                
                var PRERELEASEIDENTIFIERLOOSE = R++;
                src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';
                
                
                // ## Pre-release Version
                // Hyphen, followed by one or more dot-separated pre-release version
                // identifiers.
                
                var PRERELEASE = R++;
                src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
                
                var PRERELEASELOOSE = R++;
                src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
                
                // ## Build Metadata Identifier
                // Any combination of digits, letters, or hyphens.
                
                var BUILDIDENTIFIER = R++;
                src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
                
                // ## Build Metadata
                // Plus sign, followed by one or more period-separated build metadata
                // identifiers.
                
                var BUILD = R++;
                src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
                
                
                // ## Full Version String
                // A main version, followed optionally by a pre-release version and
                // build metadata.
                
                // Note that the only major, minor, patch, and pre-release sections of
                // the version string are capturing groups.  The build metadata is not a
                // capturing group, because it should not ever be used in version
                // comparison.
                
                var FULL = R++;
                var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';
                
                src[FULL] = '^' + FULLPLAIN + '$';
                
                // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
                // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
                // common in the npm registry.
                var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';
                
                var LOOSE = R++;
                src[LOOSE] = '^' + LOOSEPLAIN + '$';
                
                var GTLT = R++;
                src[GTLT] = '((?:<|>)?=?)';
                
                // Something like "2.*" or "1.2.x".
                // Note that "x.x" is a valid xRange identifer, meaning "any version"
                // Only the first item is strictly required.
                var XRANGEIDENTIFIERLOOSE = R++;
                src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
                var XRANGEIDENTIFIER = R++;
                src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
                
                var XRANGEPLAIN = R++;
                src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';
                
                var XRANGEPLAINLOOSE = R++;
                src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';
                
                var XRANGE = R++;
                src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
                var XRANGELOOSE = R++;
                src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
                
                // Tilde ranges.
                // Meaning is "reasonably at or greater than"
                var LONETILDE = R++;
                src[LONETILDE] = '(?:~>?)';
                
                var TILDETRIM = R++;
                src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
                re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
                var tildeTrimReplace = '$1~';
                
                var TILDE = R++;
                src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
                var TILDELOOSE = R++;
                src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
                
                // Caret ranges.
                // Meaning is "at least and backwards compatible with"
                var LONECARET = R++;
                src[LONECARET] = '(?:\\^)';
                
                var CARETTRIM = R++;
                src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
                re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
                var caretTrimReplace = '$1^';
                
                var CARET = R++;
                src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
                var CARETLOOSE = R++;
                src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
                
                // A simple gt/lt/eq thing, or just "" to indicate "any version"
                var COMPARATORLOOSE = R++;
                src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
                var COMPARATOR = R++;
                src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
                
                
                // An expression to strip any whitespace between the gtlt and the thing
                // it modifies, so that `> 1.2.3` ==> `>1.2.3`
                var COMPARATORTRIM = R++;
                src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
                
                // this one has to use the /g flag
                re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
                var comparatorTrimReplace = '$1$2$3';
                
                
                // Something like `1.2.3 - 1.2.4`
                // Note that these all use the loose form, because they'll be
                // checked against either the strict or loose comparator form
                // later.
                var HYPHENRANGE = R++;
                src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';
                
                var HYPHENRANGELOOSE = R++;
                src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';
                
                // Star ranges basically just allow anything at all.
                var STAR = R++;
                src[STAR] = '(<|>)?=?\\s*\\*';
                
                // Compile to actual regexp objects.
                // All are flag-free, unless they were created above with a flag.
                for (var i = 0; i < R; i++) {
                    ;
                    if (!re[i])
                        re[i] = new RegExp(src[i]);
                }
                
                exports.parse = parse;
                function parse(version, loose) {
                    if (version instanceof SemVer)
                        return version;
                    
                    if (typeof version !== 'string')
                        return null;
                    
                    if (version.length > MAX_LENGTH)
                        return null;
                    
                    var r = loose ? re[LOOSE] : re[FULL];
                    if (!r.test(version))
                        return null;
                    
                    try {
                        return new SemVer(version, loose);
                    } catch (er) {
                        return null;
                    }
                }
                
                exports.valid = valid;
                function valid(version, loose) {
                    var v = parse(version, loose);
                    return v ? v.version : null;
                }
                
                
                exports.clean = clean;
                function clean(version, loose) {
                    var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
                    return s ? s.version : null;
                }
                
                exports.SemVer = SemVer;
                
                function SemVer(version, loose) {
                    if (version instanceof SemVer) {
                        if (version.loose === loose)
                            return version;
                        else
                            version = version.version;
                    } else if (typeof version !== 'string') {
                        throw new TypeError('Invalid Version: ' + version);
                    }
                    
                    if (version.length > MAX_LENGTH)
                        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
                    
                    if (!(this instanceof SemVer))
                        return new SemVer(version, loose);
                    
                    ;
                    this.loose = loose;
                    var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
                    
                    if (!m)
                        throw new TypeError('Invalid Version: ' + version);
                    
                    this.raw = version;
                    
                    // these are actually numbers
                    this.major = +m[1];
                    this.minor = +m[2];
                    this.patch = +m[3];
                    
                    if (this.major > MAX_SAFE_INTEGER || this.major < 0)
                        throw new TypeError('Invalid major version')
                    
                    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
                        throw new TypeError('Invalid minor version')
                    
                    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
                        throw new TypeError('Invalid patch version')
                    
                    // numberify any prerelease numeric ids
                    if (!m[4])
                        this.prerelease = [];
                    else
                        this.prerelease = m[4].split('.').map(function (id) {
                            if (/^[0-9]+$/.test(id)) {
                                var num = +id
                                if (num >= 0 && num < MAX_SAFE_INTEGER)
                                    return num
                            }
                            return id;
                        });
                    
                    this.build = m[5] ? m[5].split('.') : [];
                    this.format();
                }
                
                SemVer.prototype.format = function () {
                    this.version = this.major + '.' + this.minor + '.' + this.patch;
                    if (this.prerelease.length)
                        this.version += '-' + this.prerelease.join('.');
                    return this.version;
                };
                
                SemVer.prototype.inspect = function () {
                    return '<SemVer "' + this + '">';
                };
                
                SemVer.prototype.toString = function () {
                    return this.version;
                };
                
                SemVer.prototype.compare = function (other) {
                    ;
                    if (!(other instanceof SemVer))
                        other = new SemVer(other, this.loose);
                    
                    return this.compareMain(other) || this.comparePre(other);
                };
                
                SemVer.prototype.compareMain = function (other) {
                    if (!(other instanceof SemVer))
                        other = new SemVer(other, this.loose);
                    
                    return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch);
                };
                
                SemVer.prototype.comparePre = function (other) {
                    if (!(other instanceof SemVer))
                        other = new SemVer(other, this.loose);
                    
                    // NOT having a prerelease is > having one
                    if (this.prerelease.length && !other.prerelease.length)
                        return -1;
                    else if (!this.prerelease.length && other.prerelease.length)
                        return 1;
                    else if (!this.prerelease.length && !other.prerelease.length)
                        return 0;
                    
                    var i = 0;
                    do {
                        var a = this.prerelease[i];
                        var b = other.prerelease[i];
                        ;
                        if (a === undefined && b === undefined)
                            return 0;
                        else if (b === undefined)
                            return 1;
                        else if (a === undefined)
                            return -1;
                        else if (a === b)
                            continue;
                        else
                            return compareIdentifiers(a, b);
                    } while (++i);
                };
                
                // preminor will bump the version up to the next minor release, and immediately
                // down to pre-release. premajor and prepatch work the same way.
                SemVer.prototype.inc = function (release, identifier) {
                    switch (release) {
                        case 'premajor':
                            this.prerelease.length = 0;
                            this.patch = 0;
                            this.minor = 0;
                            this.major++;
                            this.inc('pre', identifier);
                            break;
                        case 'preminor':
                            this.prerelease.length = 0;
                            this.patch = 0;
                            this.minor++;
                            this.inc('pre', identifier);
                            break;
                        case 'prepatch':
                            // If this is already a prerelease, it will bump to the next version
                            // drop any prereleases that might already exist, since they are not
                            // relevant at this point.
                            this.prerelease.length = 0;
                            this.inc('patch', identifier);
                            this.inc('pre', identifier);
                            break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
                        case 'prerelease':
                            if (this.prerelease.length === 0)
                                this.inc('patch', identifier);
                            this.inc('pre', identifier);
                            break;

                        case 'major':
                            // If this is a pre-major version, bump up to the same major version.
                            // Otherwise increment major.
                            // 1.0.0-5 bumps to 1.0.0
                            // 1.1.0 bumps to 2.0.0
                            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
                                this.major++;
                            this.minor = 0;
                            this.patch = 0;
                            this.prerelease = [];
                            break;
                        case 'minor':
                            // If this is a pre-minor version, bump up to the same minor version.
                            // Otherwise increment minor.
                            // 1.2.0-5 bumps to 1.2.0
                            // 1.2.1 bumps to 1.3.0
                            if (this.patch !== 0 || this.prerelease.length === 0)
                                this.minor++;
                            this.patch = 0;
                            this.prerelease = [];
                            break;
                        case 'patch':
                            // If this is not a pre-release version, it will increment the patch.
                            // If it is a pre-release it will bump up to the same patch version.
                            // 1.2.0-5 patches to 1.2.0
                            // 1.2.0 patches to 1.2.1
                            if (this.prerelease.length === 0)
                                this.patch++;
                            this.prerelease = [];
                            break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
                        case 'pre':
                            if (this.prerelease.length === 0)
                                this.prerelease = [0];
                            else {
                                var i = this.prerelease.length;
                                while (--i >= 0) {
                                    if (typeof this.prerelease[i] === 'number') {
                                        this.prerelease[i]++;
                                        i = -2;
                                    }
                                }
                                if (i === -1) // didn't increment anything
                                    this.prerelease.push(0);
                            }
                            if (identifier) {
                                // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                                // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                                if (this.prerelease[0] === identifier) {
                                    if (isNaN(this.prerelease[1]))
                                        this.prerelease = [identifier, 0];
                                } else
                                    this.prerelease = [identifier, 0];
                            }
                            break;

                        default:
                            throw new Error('invalid increment argument: ' + release);
                    }
                    this.format();
                    return this;
                };
                
                exports.inc = inc;
                function inc(version, release, loose, identifier) {
                    if (typeof (loose) === 'string') {
                        identifier = loose;
                        loose = undefined;
                    }
                    
                    try {
                        return new SemVer(version, loose).inc(release, identifier).version;
                    } catch (er) {
                        return null;
                    }
                }
                
                exports.diff = diff;
                function diff(version1, version2) {
                    if (eq(version1, version2)) {
                        return null;
                    } else {
                        var v1 = parse(version1);
                        var v2 = parse(version2);
                        if (v1.prerelease.length || v2.prerelease.length) {
                            for (var key in v1) {
                                if (key === 'major' || key === 'minor' || key === 'patch') {
                                    if (v1[key] !== v2[key]) {
                                        return 'pre' + key;
                                    }
                                }
                            }
                            return 'prerelease';
                        }
                        for (var key in v1) {
                            if (key === 'major' || key === 'minor' || key === 'patch') {
                                if (v1[key] !== v2[key]) {
                                    return key;
                                }
                            }
                        }
                    }
                }
                
                exports.compareIdentifiers = compareIdentifiers;
                
                var numeric = /^[0-9]+$/;
                function compareIdentifiers(a, b) {
                    var anum = numeric.test(a);
                    var bnum = numeric.test(b);
                    
                    if (anum && bnum) {
                        a = +a;
                        b = +b;
                    }
                    
                    return (anum && !bnum) ? -1 :
         (bnum && !anum) ? 1 :
         a < b ? -1 :
         a > b ? 1 :
         0;
                }
                
                exports.rcompareIdentifiers = rcompareIdentifiers;
                function rcompareIdentifiers(a, b) {
                    return compareIdentifiers(b, a);
                }
                
                exports.major = major;
                function major(a, loose) {
                    return new SemVer(a, loose).major;
                }
                
                exports.minor = minor;
                function minor(a, loose) {
                    return new SemVer(a, loose).minor;
                }
                
                exports.patch = patch;
                function patch(a, loose) {
                    return new SemVer(a, loose).patch;
                }
                
                exports.compare = compare;
                function compare(a, b, loose) {
                    return new SemVer(a, loose).compare(b);
                }
                
                exports.compareLoose = compareLoose;
                function compareLoose(a, b) {
                    return compare(a, b, true);
                }
                
                exports.rcompare = rcompare;
                function rcompare(a, b, loose) {
                    return compare(b, a, loose);
                }
                
                exports.sort = sort;
                function sort(list, loose) {
                    return list.sort(function (a, b) {
                        return exports.compare(a, b, loose);
                    });
                }
                
                exports.rsort = rsort;
                function rsort(list, loose) {
                    return list.sort(function (a, b) {
                        return exports.rcompare(a, b, loose);
                    });
                }
                
                exports.gt = gt;
                function gt(a, b, loose) {
                    return compare(a, b, loose) > 0;
                }
                
                exports.lt = lt;
                function lt(a, b, loose) {
                    return compare(a, b, loose) < 0;
                }
                
                exports.eq = eq;
                function eq(a, b, loose) {
                    return compare(a, b, loose) === 0;
                }
                
                exports.neq = neq;
                function neq(a, b, loose) {
                    return compare(a, b, loose) !== 0;
                }
                
                exports.gte = gte;
                function gte(a, b, loose) {
                    return compare(a, b, loose) >= 0;
                }
                
                exports.lte = lte;
                function lte(a, b, loose) {
                    return compare(a, b, loose) <= 0;
                }
                
                exports.cmp = cmp;
                function cmp(a, op, b, loose) {
                    var ret;
                    switch (op) {
                        case '===':
                            if (typeof a === 'object') a = a.version;
                            if (typeof b === 'object') b = b.version;
                            ret = a === b;
                            break;
                        case '!==':
                            if (typeof a === 'object') a = a.version;
                            if (typeof b === 'object') b = b.version;
                            ret = a !== b;
                            break;
                        case '': case '=': case '==': ret = eq(a, b, loose); break;
                        case '!=': ret = neq(a, b, loose); break;
                        case '>': ret = gt(a, b, loose); break;
                        case '>=': ret = gte(a, b, loose); break;
                        case '<': ret = lt(a, b, loose); break;
                        case '<=': ret = lte(a, b, loose); break;
                        default: throw new TypeError('Invalid operator: ' + op);
                    }
                    return ret;
                }
                
                exports.Comparator = Comparator;
                function Comparator(comp, loose) {
                    if (comp instanceof Comparator) {
                        if (comp.loose === loose)
                            return comp;
                        else
                            comp = comp.value;
                    }
                    
                    if (!(this instanceof Comparator))
                        return new Comparator(comp, loose);
                    
                    ;
                    this.loose = loose;
                    this.parse(comp);
                    
                    if (this.semver === ANY)
                        this.value = '';
                    else
                        this.value = this.operator + this.semver.version;
                    
                    ;
                }
                
                var ANY = {};
                Comparator.prototype.parse = function (comp) {
                    var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
                    var m = comp.match(r);
                    
                    if (!m)
                        throw new TypeError('Invalid comparator: ' + comp);
                    
                    this.operator = m[1];
                    if (this.operator === '=')
                        this.operator = '';
                    
                    // if it literally is just '>' or '' then allow anything.
                    if (!m[2])
                        this.semver = ANY;
                    else
                        this.semver = new SemVer(m[2], this.loose);
                };
                
                Comparator.prototype.inspect = function () {
                    return '<SemVer Comparator "' + this + '">';
                };
                
                Comparator.prototype.toString = function () {
                    return this.value;
                };
                
                Comparator.prototype.test = function (version) {
                    ;
                    
                    if (this.semver === ANY)
                        return true;
                    
                    if (typeof version === 'string')
                        version = new SemVer(version, this.loose);
                    
                    return cmp(version, this.operator, this.semver, this.loose);
                };
                
                
                exports.Range = Range;
                function Range(range, loose) {
                    if ((range instanceof Range) && range.loose === loose)
                        return range;
                    
                    if (!(this instanceof Range))
                        return new Range(range, loose);
                    
                    this.loose = loose;
                    
                    // First, split based on boolean or ||
                    this.raw = range;
                    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
                        return this.parseRange(range.trim());
                    }, this).filter(function (c) {
                        // throw out any that are not relevant for whatever reason
                        return c.length;
                    });
                    
                    if (!this.set.length) {
                        throw new TypeError('Invalid SemVer Range: ' + range);
                    }
                    
                    this.format();
                }
                
                Range.prototype.inspect = function () {
                    return '<SemVer Range "' + this.range + '">';
                };
                
                Range.prototype.format = function () {
                    this.range = this.set.map(function (comps) {
                        return comps.join(' ').trim();
                    }).join('||').trim();
                    return this.range;
                };
                
                Range.prototype.toString = function () {
                    return this.range;
                };
                
                Range.prototype.parseRange = function (range) {
                    var loose = this.loose;
                    range = range.trim();
                    ;
                    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
                    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
                    range = range.replace(hr, hyphenReplace);
                    ;
                    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
                    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
                    ;
                    
                    // `~ 1.2.3` => `~1.2.3`
                    range = range.replace(re[TILDETRIM], tildeTrimReplace);
                    
                    // `^ 1.2.3` => `^1.2.3`
                    range = range.replace(re[CARETTRIM], caretTrimReplace);
                    
                    // normalize spaces
                    range = range.split(/\s+/).join(' ');
                    
                    // At this point, the range is completely trimmed and
                    // ready to be split into comparators.
                    
                    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
                    var set = range.split(' ').map(function (comp) {
                        return parseComparator(comp, loose);
                    }).join(' ').split(/\s+/);
                    if (this.loose) {
                        // in loose mode, throw out any that are not valid comparators
                        set = set.filter(function (comp) {
                            return !!comp.match(compRe);
                        });
                    }
                    set = set.map(function (comp) {
                        return new Comparator(comp, loose);
                    });
                    
                    return set;
                };
                
                // Mostly just for testing and legacy API reasons
                exports.toComparators = toComparators;
                function toComparators(range, loose) {
                    return new Range(range, loose).set.map(function (comp) {
                        return comp.map(function (c) {
                            return c.value;
                        }).join(' ').trim().split(' ');
                    });
                }
                
                // comprised of xranges, tildes, stars, and gtlt's at this point.
                // already replaced the hyphen ranges
                // turn into a set of JUST comparators.
                function parseComparator(comp, loose) {
                    ;
                    comp = replaceCarets(comp, loose);
                    ;
                    comp = replaceTildes(comp, loose);
                    ;
                    comp = replaceXRanges(comp, loose);
                    ;
                    comp = replaceStars(comp, loose);
                    ;
                    return comp;
                }
                
                function isX(id) {
                    return !id || id.toLowerCase() === 'x' || id === '*';
                }
                
                // ~, ~> --> * (any, kinda silly)
                // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
                // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
                // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
                // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
                // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
                function replaceTildes(comp, loose) {
                    return comp.trim().split(/\s+/).map(function (comp) {
                        return replaceTilde(comp, loose);
                    }).join(' ');
                }
                
                function replaceTilde(comp, loose) {
                    var r = loose ? re[TILDELOOSE] : re[TILDE];
                    return comp.replace(r, function (_, M, m, p, pr) {
                        ;
                        var ret;
                        
                        if (isX(M))
                            ret = '';
                        else if (isX(m))
                            ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
                        else if (isX(p))
                            // ~1.2 == >=1.2.0- <1.3.0-
                            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
                        else if (pr) {
                            ;
                            if (pr.charAt(0) !== '-')
                                pr = '-' + pr;
                            ret = '>=' + M + '.' + m + '.' + p + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
                        } else
                            // ~1.2.3 == >=1.2.3 <1.3.0
                            ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';
                        
                        ;
                        return ret;
                    });
                }
                
                // ^ --> * (any, kinda silly)
                // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
                // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
                // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
                // ^1.2.3 --> >=1.2.3 <2.0.0
                // ^1.2.0 --> >=1.2.0 <2.0.0
                function replaceCarets(comp, loose) {
                    return comp.trim().split(/\s+/).map(function (comp) {
                        return replaceCaret(comp, loose);
                    }).join(' ');
                }
                
                function replaceCaret(comp, loose) {
                    ;
                    var r = loose ? re[CARETLOOSE] : re[CARET];
                    return comp.replace(r, function (_, M, m, p, pr) {
                        ;
                        var ret;
                        
                        if (isX(M))
                            ret = '';
                        else if (isX(m))
                            ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
                        else if (isX(p)) {
                            if (M === '0')
                                ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
                            else
                                ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
                        } else if (pr) {
                            ;
                            if (pr.charAt(0) !== '-')
                                pr = '-' + pr;
                            if (M === '0') {
                                if (m === '0')
                                    ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
                                else
                                    ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
                            } else
                                ret = '>=' + M + '.' + m + '.' + p + pr +
              ' <' + (+M + 1) + '.0.0';
                        } else {
                            ;
                            if (M === '0') {
                                if (m === '0')
                                    ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
                                else
                                    ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
                            } else
                                ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
                        }
                        
                        ;
                        return ret;
                    });
                }
                
                function replaceXRanges(comp, loose) {
                    ;
                    return comp.split(/\s+/).map(function (comp) {
                        return replaceXRange(comp, loose);
                    }).join(' ');
                }
                
                function replaceXRange(comp, loose) {
                    comp = comp.trim();
                    var r = loose ? re[XRANGELOOSE] : re[XRANGE];
                    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
                        ;
                        var xM = isX(M);
                        var xm = xM || isX(m);
                        var xp = xm || isX(p);
                        var anyX = xp;
                        
                        if (gtlt === '=' && anyX)
                            gtlt = '';
                        
                        if (xM) {
                            if (gtlt === '>' || gtlt === '<') {
                                // nothing is allowed
                                ret = '<0.0.0';
                            } else {
                                // nothing is forbidden
                                ret = '*';
                            }
                        } else if (gtlt && anyX) {
                            // replace X with 0
                            if (xm)
                                m = 0;
                            if (xp)
                                p = 0;
                            
                            if (gtlt === '>') {
                                // >1 => >=2.0.0
                                // >1.2 => >=1.3.0
                                // >1.2.3 => >= 1.2.4
                                gtlt = '>=';
                                if (xm) {
                                    M = +M + 1;
                                    m = 0;
                                    p = 0;
                                } else if (xp) {
                                    m = +m + 1;
                                    p = 0;
                                }
                            } else if (gtlt === '<=') {
                                // <=0.7.x is actually <0.8.0, since any 0.7.x should
                                // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                                gtlt = '<'
                                if (xm)
                                    M = +M + 1
                                else
                                    m = +m + 1
                            }
                            
                            ret = gtlt + M + '.' + m + '.' + p;
                        } else if (xm) {
                            ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
                        } else if (xp) {
                            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
                        }
                        
                        ;
                        
                        return ret;
                    });
                }
                
                // Because * is AND-ed with everything else in the comparator,
                // and '' means "any version", just remove the *s entirely.
                function replaceStars(comp, loose) {
                    ;
                    // Looseness is ignored here.  star is always as loose as it gets!
                    return comp.trim().replace(re[STAR], '');
                }
                
                // This function is passed to string.replace(re[HYPHENRANGE])
                // M, m, patch, prerelease, build
                // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
                // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
                // 1.2 - 3.4 => >=1.2.0 <3.5.0
                function hyphenReplace($0,
                       from, fM, fm, fp, fpr, fb,
                       to, tM, tm, tp, tpr, tb) {
                    
                    if (isX(fM))
                        from = '';
                    else if (isX(fm))
                        from = '>=' + fM + '.0.0';
                    else if (isX(fp))
                        from = '>=' + fM + '.' + fm + '.0';
                    else
                        from = '>=' + from;
                    
                    if (isX(tM))
                        to = '';
                    else if (isX(tm))
                        to = '<' + (+tM + 1) + '.0.0';
                    else if (isX(tp))
                        to = '<' + tM + '.' + (+tm + 1) + '.0';
                    else if (tpr)
                        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
                    else
                        to = '<=' + to;
                    
                    return (from + ' ' + to).trim();
                }
                
                
                // if ANY of the sets match ALL of its comparators, then pass
                Range.prototype.test = function (version) {
                    if (!version)
                        return false;
                    
                    if (typeof version === 'string')
                        version = new SemVer(version, this.loose);
                    
                    for (var i = 0; i < this.set.length; i++) {
                        if (testSet(this.set[i], version))
                            return true;
                    }
                    return false;
                };
                
                function testSet(set, version) {
                    for (var i = 0; i < set.length; i++) {
                        if (!set[i].test(version))
                            return false;
                    }
                    
                    if (version.prerelease.length) {
                        // Find the set of versions that are allowed to have prereleases
                        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
                        // That should allow `1.2.3-pr.2` to pass.
                        // However, `1.2.4-alpha.notready` should NOT be allowed,
                        // even though it's within the range set by the comparators.
                        for (var i = 0; i < set.length; i++) {
                            ;
                            if (set[i].semver === ANY)
                                return true;
                            
                            if (set[i].semver.prerelease.length > 0) {
                                var allowed = set[i].semver;
                                if (allowed.major === version.major &&
                                    allowed.minor === version.minor &&
                                    allowed.patch === version.patch)
                                    return true;
                            }
                        }
                        
                        // Version has a -pre, but it's not one of the ones we like.
                        return false;
                    }
                    
                    return true;
                }
                
                exports.satisfies = satisfies;
                function satisfies(version, range, loose) {
                    try {
                        range = new Range(range, loose);
                    } catch (er) {
                        return false;
                    }
                    return range.test(version);
                }
                
                exports.maxSatisfying = maxSatisfying;
                function maxSatisfying(versions, range, loose) {
                    return versions.filter(function (version) {
                        return satisfies(version, range, loose);
                    }).sort(function (a, b) {
                        return rcompare(a, b, loose);
                    })[0] || null;
                }
                
                exports.validRange = validRange;
                function validRange(range, loose) {
                    try {
                        // Return '*' instead of '' so that truthiness works.
                        // This will throw if it's invalid anyway
                        return new Range(range, loose).range || '*';
                    } catch (er) {
                        return null;
                    }
                }
                
                // Determine if version is less than all the versions possible in the range
                exports.ltr = ltr;
                function ltr(version, range, loose) {
                    return outside(version, range, '<', loose);
                }
                
                // Determine if version is greater than all the versions possible in the range.
                exports.gtr = gtr;
                function gtr(version, range, loose) {
                    return outside(version, range, '>', loose);
                }
                
                exports.outside = outside;
                function outside(version, range, hilo, loose) {
                    version = new SemVer(version, loose);
                    range = new Range(range, loose);
                    
                    var gtfn, ltefn, ltfn, comp, ecomp;
                    switch (hilo) {
                        case '>':
                            gtfn = gt;
                            ltefn = lte;
                            ltfn = lt;
                            comp = '>';
                            ecomp = '>=';
                            break;
                        case '<':
                            gtfn = lt;
                            ltefn = gte;
                            ltfn = gt;
                            comp = '<';
                            ecomp = '<=';
                            break;
                        default:
                            throw new TypeError('Must provide a hilo val of "<" or ">"');
                    }
                    
                    // If it satisifes the range it is not outside
                    if (satisfies(version, range, loose)) {
                        return false;
                    }
                    
                    // From now on, variable terms are as if we're in "gtr" mode.
                    // but note that everything is flipped for the "ltr" function.
                    
                    for (var i = 0; i < range.set.length; ++i) {
                        var comparators = range.set[i];
                        
                        var high = null;
                        var low = null;
                        
                        comparators.forEach(function (comparator) {
                            high = high || comparator;
                            low = low || comparator;
                            if (gtfn(comparator.semver, high.semver, loose)) {
                                high = comparator;
                            } else if (ltfn(comparator.semver, low.semver, loose)) {
                                low = comparator;
                            }
                        });
                        
                        // If the edge version comparator has a operator then our version
                        // isn't outside it
                        if (high.operator === comp || high.operator === ecomp) {
                            return false;
                        }
                        
                        // If the lowest version comparator has an operator and our version
                        // is less than it then it isn't higher than the range
                        if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
                            return false;
                        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
                            return false;
                        }
                    }
                    return true;
                }
                
                // Use the define() function if we're in AMD land
                if (typeof define === 'function' && define.amd)
                    define(exports);

            })(
                typeof exports === 'object' ? exports :
  typeof define === 'function' && define.amd ? {} :
  semver = {}
            );

        }, {}], 121: [function (require, module, exports) {
            module.exports = {
                "name": "node-pre-gyp",
                "description": "Node.js native addon binary install tool",
                "version": "0.6.7",
                "keywords": [
                    "native",
                    "addon",
                    "module",
                    "c",
                    "c++",
                    "bindings",
                    "binary"
                ],
                "license": "BSD",
                "author": {
                    "name": "Dane Springmeyer",
                    "email": "dane@mapbox.com"
                },
                "repository": {
                    "type": "git",
                    "url": "git://github.com/mapbox/node-pre-gyp.git"
                },
                "bin": {
                    "node-pre-gyp": "./bin/node-pre-gyp"
                },
                "main": "./lib/node-pre-gyp.js",
                "dependencies": {
                    "nopt": "~3.0.1",
                    "npmlog": "~1.2.0",
                    "request": "2.x",
                    "semver": "~4.3.2",
                    "tar": "~2.1.0",
                    "tar-pack": "~2.0.0",
                    "mkdirp": "~0.5.0",
                    "rc": "~1.0.1",
                    "rimraf": "~2.3.2"
                },
                "devDependencies": {
                    "aws-sdk": "*",
                    "mocha": "1.x",
                    "retire": "0.3.x",
                    "jshint": "^2.5.10"
                },
                "jshintConfig": {
                    "node": true,
                    "globalstrict": true,
                    "undef": true,
                    "unused": true,
                    "noarg": true,
                    "mocha": true
                },
                "engineStrict": true,
                "engines": {
                    "node": ">= 0.8.0"
                },
                "scripts": {
                    "prepublish": "retire -n && npm ls && jshint test/*js",
                    "update-crosswalk": "node scripts/abi_crosswalk.js",
                    "test": "jshint lib lib/util scripts bin/node-pre-gyp && mocha -R spec --timeout 500000"
                },
                "readme": "# node-pre-gyp\n\n#### node-pre-gyp makes it easy to publish and install Node.js C++ addons from binaries\n\n[![NPM](https://nodei.co/npm/node-pre-gyp.png?downloads=true&downloadRank=true)](https://nodei.co/npm/node-pre-gyp/)\n\n[![Build Status](https://api.travis-ci.org/mapbox/node-pre-gyp.svg)](https://travis-ci.org/mapbox/node-pre-gyp)\n[![Build status](https://ci.appveyor.com/api/projects/status/3nxewb425y83c0gv)](https://ci.appveyor.com/project/Mapbox/node-pre-gyp)\n[![Dependencies](https://david-dm.org/mapbox/node-pre-gyp.svg)](https://david-dm.org/mapbox/node-pre-gyp)\n\n`node-pre-gyp` stands between [npm](https://github.com/npm/npm) and [node-gyp](https://github.com/Tootallnate/node-gyp) and offers a cross-platform method of binary deployment.\n\n### Features\n\n - A command line tool called `node-pre-gyp` that can install your package's c++ module from a binary.\n - A variety of developer targeted commands for packaging, testing, and publishing binaries.\n - A Javascript module that can dynamically require your installed binary: `require('node-pre-gyp').find`\n\nFor a hello world example of a module packaged with `node-pre-gyp` see <https://github.com/springmeyer/node-addon-example> and [the wiki ](https://github.com/mapbox/node-pre-gyp/wiki/Modules-using-node-pre-gyp) for real world examples.\n\n## Credits\n\n - The module is modeled after [node-gyp](https://github.com/Tootallnate/node-gyp) by [@Tootallnate](https://github.com/Tootallnate)\n - Motivation for initial development came from [@ErisDS](https://github.com/ErisDS) and the [Ghost Project](https://github.com/TryGhost/Ghost).\n - Development is sponsored by [Mapbox](https://www.mapbox.com/)\n\n## FAQ\n\nSee the [Frequently Ask Questions](https://github.com/mapbox/node-pre-gyp/wiki/FAQ).\n\n## Depends\n\n - Node.js 0.12.x -> 0.8.x\n\n## Install\n\n`node-pre-gyp` is designed to be installed as a local dependency of your Node.js C++ addon and accessed like:\n\n    ./node_modules/.bin/node-pre-gyp --help\n\nBut you can also install it globally:\n\n    npm install node-pre-gyp -g\n\n## Usage\n\n### Commands\n\nView all possible commands:\n\n    node-pre-gyp --help\n\n- clean - Remove the entire folder containing the compiled .node module\n- install - Install pre-built binary for module\n- reinstall - Run \"clean\" and \"install\" at once\n- build - Compile the module by dispatching to node-gyp or nw-gyp\n- rebuild - Run \"clean\" and \"build\" at once\n- package - Pack binary into tarball\n- testpackage - Test that the staged package is valid\n- publish - Publish pre-built binary\n- unpublish - Unpublish pre-built binary\n- info - Fetch info on published binaries\n\nYou can also chain commands:\n\n    node-pre-gyp clean build unpublish publish info\n\n### Options\n\nOptions include:\n\n - `-C/--directory`: run the command in this directory\n - `--build-from-source`: build from source instead of using pre-built binary\n - `--runtime=node-webkit`: customize the runtime: `node` and `node-webkit` are the valid options\n - `--fallback-to-build`: fallback to building from source if pre-built binary is not available\n - `--target=0.10.25`: Pass the target node or node-webkit version to compile against\n - `--target_arch=ia32`: Pass the target arch and override the host `arch`. Valid values are 'ia32','x64', or `arm`.\n - `--target_platform=win32`: Pass the target platform and override the host `platform`. Valid values are `linux`, `darwin`, `win32`, `sunos`, `freebsd`, `openbsd`, and `aix`.\n\nBoth `--build-from-source` and `--fallback-to-build` can be passed alone or they can provide values. You can pass `--fallback-to-build=false` to override the option as declared in package.json. In addition to being able to pass `--build-from-source` you can also pass `--build-from-source=myapp` where `myapp` is the name of your module.\n\nFor example: `npm install --build-from-source=myapp`. This is useful if:\n\n - `myapp` is referenced in the package.json of a larger app and therefore `myapp` is being installed as a dependent with `npm install`.\n - The larger app also depends on other modules installed with `node-pre-gyp`\n - You only want to trigger a source compile for `myapp` and the other modules.\n\n### Configuring\n\nThis is a guide to configuring your module to use node-pre-gyp.\n\n#### 1) Add new entries to your `package.json`\n\n - Add `node-pre-gyp` to `bundledDependencies`\n - Add `aws-sdk` as a `devDependency`\n - Add a custom `install` script\n - Declare a `binary` object\n\nThis looks like:\n\n```js\n    \"dependencies\"  : {\n      \"node-pre-gyp\": \"0.5.x\"\n    },\n    \"bundledDependencies\":[\"node-pre-gyp\"],\n    \"devDependencies\": {\n      \"aws-sdk\": \"~2.0.0-rc.15\"\n    }\n    \"scripts\": {\n        \"install\": \"node-pre-gyp install --fallback-to-build\",\n    },\n    \"binary\": {\n        \"module_name\": \"your_module\",\n        \"module_path\": \"./lib/binding/\",\n        \"host\": \"https://your_module.s3-us-west-1.amazonaws.com\"\n    }\n```\n\nFor a full example see [node-addon-examples's package.json](https://github.com/springmeyer/node-addon-example/blob/2ff60a8ded7f042864ad21db00c3a5a06cf47075/package.json#L11-L22).\n\n##### The `binary` object has three required properties\n\n###### module_name\n\nThe name of your native node module. This value must:\n\n - Match the name passed to [the NODE_MODULE macro](http://nodejs.org/api/addons.html#addons_hello_world)\n - Must be a valid C variable name (e.g. it cannot contain `-`)\n - Should not include the `.node` extension.\n\n###### module_path\n\nThe location your native module is placed after a build. This should be an empty directory without other Javascript files. This entire directory will be packaged in the binary tarball. When installing from a remote package this directory will be overwritten with the contents of the tarball.\n\nNote: This property supports variables based on [Versioning](#versioning).\n\n###### host\n\nA url to the remote location where you've published tarball binaries (must be `https` not `http`).\n\nIt is highly recommended that you use Amazon S3. The reasons are:\n\n  - Various node-pre-gyp commands like `publish` and `info` only work with an S3 host.\n  - S3 is a very solid hosting platform for distributing large files, even [Github recommends using it instead of github](https://help.github.com/articles/distributing-large-binaries).\n  - We provide detail documentation for using [S3 hosting](#s3-hosting) with node-pre-gyp.\n\nWhy then not require S3? Because while some applications using node-pre-gyp need to distribute binaries as large as 20-30 MB, others might have very small binaries and might wish to store them in a github repo. This is not recommended, but if an author really wants to host in a non-s3 location then it should be possible.\n\n##### The `binary` object has two optional properties\n\n###### remote_path\n\nIt **is recommended** that you customize this property. This is an extra path to use for publishing and finding remote tarballs. The default value for `remote_path` is `\"\"` meaning that if you do not provide it then all packages will be published at the base of the `host`. It is recommended to provide a value like `./{name}/v{version}` to help organize remote packages in the case that you choose to publish multiple node addons to the same `host`.\n\nNote: This property supports variables based on [Versioning](#versioning).\n\n###### package_name\n\nIt is **not recommended** to override this property unless you are also overriding the `remote_path`. This is the versioned name of the remote tarball containing the binary `.node` module and any supporting files you've placed inside the `module_path` directory. Unless you specify `package_name` in your `package.json` then it defaults to `{module_name}-v{version}-{node_abi}-{platform}-{arch}.tar.gz` which allows your binary to work across node versions, platforms, and architectures. If you are using `remote_path` that is also versioned by `./{module_name}/v{version}` then you could remove these variables from the `package_name` and just use: `{node_abi}-{platform}-{arch}.tar.gz`. Then your remote tarball will be looked up at, for example, `https://example.com/your-module/v0.1.0/node-v11-linux-x64.tar.gz`.\n\nAvoiding the version of your module in the `package_name` and instead only embedding in a directory name can be useful when you want to make a quick tag of your module that does not change any C++ code. In this case you can just copy binaries to the new version behind the scenes like:\n\n```sh\naws s3 sync --acl public-read s3://mapbox-node-binary/sqlite3/v3.0.3/ s3://mapbox-node-binary/sqlite3/v3.0.4/\n```\n\nNote: This property supports variables based on [Versioning](#versioning).\n\n#### 2) Add a new target to binding.gyp\n\n`node-pre-gyp` calls out to `node-gyp` to compile the module and passes variables along like [module_name](#module_name) and [module_path](#module_path).\n\nA new target must be added to `binding.gyp` that moves the compiled `.node` module from `./build/Release/module_name.node` into the directory specified by `module_path`.\n\nAdd a target like this at the end of your `targets` list:\n\n```js\n    {\n      \"target_name\": \"action_after_build\",\n      \"type\": \"none\",\n      \"dependencies\": [ \"<(module_name)\" ],\n      \"copies\": [\n        {\n          \"files\": [ \"<(PRODUCT_DIR)/<(module_name).node\" ],\n          \"destination\": \"<(module_path)\"\n        }\n      ]\n    }\n```\n\nFor a full example see [node-addon-example's binding.gyp](https://github.com/springmeyer/node-addon-example/blob/2ff60a8ded7f042864ad21db00c3a5a06cf47075/binding.gyp).\n\n#### 3) Dynamically require your `.node`\n\nInside the main js file that requires your addon module you are likely currently doing:\n\n```js\nvar binding = require('../build/Release/binding.node');\n```\n\nor:\n\n```js\nvar bindings = require('./bindings')\n```\n\nChange those lines to:\n\n```js\nvar binary = require('node-pre-gyp');\nvar path = require('path');\nvar binding_path = binary.find(path.resolve(path.join(__dirname,'./package.json')));\nvar binding = require(binding_path);\n```\n\nFor a full example see [node-addon-example's index.js](https://github.com/springmeyer/node-addon-example/blob/2ff60a8ded7f042864ad21db00c3a5a06cf47075/index.js#L1-L4)\n\n#### 4) Build and package your app\n\nNow build your module from source:\n\n    npm install --build-from-source\n\nThe `--build-from-source` tells `node-pre-gyp` to not look for a remote package and instead dispatch to node-gyp to build.\n\nNow `node-pre-gyp` should now also be installed as a local dependency so the command line tool it offers can be found at `./node_modules/.bin/node-pre-gyp`.\n\n#### 5) Test\n\nNow `npm test` should work just as it did before.\n\n#### 6) Publish the tarball\n\nThen package your app:\n\n    ./node_modules/.bin/node-pre-gyp package\n\nOnce packaged, now you can publish:\n\n    ./node_modules/.bin/node-pre-gyp publish\n\nCurrently the `publish` command pushes your binary to S3. This requires:\n\n - You have installed `aws-sdk` with `npm install aws-sdk`\n - You have created a bucket already.\n - The `host` points to an S3 http or https endpoint.\n - You have configured node-pre-gyp to read your S3 credentials (see [S3 hosting](#s3-hosting) for details).\n\nYou can also host your binaries elsewhere. To do this requires:\n\n - You manually publish the binary created by the `package` command to an `https` endpoint\n - Ensure that the `host` value points to your custom `https` endpoint.\n\n#### 7) Automate builds\n\nNow you need to publish builds for all the platforms and node versions you wish to support. This is best automated.\n\n - See [Appveyor Automation](#appveyor-automation) for how to auto-publish builds on Windows.\n - See [Travis Automation](#travis-automation) for how to auto-publish builds on OS X and Linux.\n\n#### 8) You're done!\n\nNow publish your module to the npm registry. Users will now be able to install your module from a binary. \n\nWhat will happen is this:\n\n1. `npm install <your package>` will pull from the npm registry\n2. npm will run the `install` script which will call out to `node-pre-gyp`\n3. `node-pre-gyp` will fetch the binary `.node` module and unpack in the right place\n4. Assuming that all worked, you are done\n\nIf a a binary was not available for a given platform and `--fallback-to-build` was used then `node-gyp rebuild` will be called to try to source compile the module.\n\n## S3 Hosting\n\nYou can host wherever you choose but S3 is cheap, `node-pre-gyp publish` expects it, and S3 can be integrated well with [travis.ci](http://travis-ci.org) to automate builds for OS X and Ubuntu. Here is an approach to do this:\n\nFirst, get setup locally and test the workflow:\n\n#### 1) Create an S3 bucket\n\nAnd have your **key** and **secret key** ready for writing to the bucket.\n\nIt is recommended to create a IAM user with a policy that only gives permissions to the specific bucket you plan to publish to. This can be done in the [IAM console](https://console.aws.amazon.com/iam/) by: 1) adding a new user, 2) choosing `Attach User Policy`, 3) Using the `Policy Generator`, 4) selecting `Amazon S3` for the service, 5) adding the actions: `DeleteObject`, `GetObject`, `GetObjectAcl`, `ListBucket`, `PutObject`, `PutObjectAcl`, 6) adding an ARN of `arn:aws:s3:::bucket/*` (replacing `bucket` with your bucket name), and finally 7) clicking `Add Statement` and saving the policy. It should generate a policy like:\n\n```js\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"Stmt1394587197000\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"s3:DeleteObject\",\n        \"s3:GetObject\",\n        \"s3:GetObjectAcl\",\n        \"s3:ListBucket\",\n        \"s3:PutObject\",\n        \"s3:PutObjectAcl\"\n      ],\n      \"Resource\": [\n        \"arn:aws:s3:::node-pre-gyp-tests/*\"\n      ]\n    }\n  ]\n}\n```\n\n#### 2) Install node-pre-gyp\n\nEither install it globally:\n\n    npm install node-pre-gyp -g\n\nOr put the local version on your PATH\n\n    export PATH=`pwd`/node_modules/.bin/:$PATH\n\n#### 3) Configure AWS credentials\n\nThere are several ways to do this.\n\nYou can use any of the methods described at http://docs.aws.amazon.com/AWSJavaScriptSDK/guide/node-configuring.html.\n\nOr you can create a `~/.node_pre_gyprc`\n\nOr pass options in any way supported by [RC](https://github.com/dominictarr/rc#standards)\n\nA `~/.node_pre_gyprc` looks like:\n\n```js\n{\n    \"accessKeyId\": \"xxx\",\n    \"secretAccessKey\": \"xxx\"\n}\n```\n\nAnother way is to use your environment:\n\n    export node_pre_gyp_accessKeyId=xxx\n    export node_pre_gyp_secretAccessKey=xxx\n\nYou may also need to specify the `region` if it is not explicit in the `host` value you use. The `bucket` can also be specified but it is optional because `node-pre-gyp` will detect it from the `host` value.\n\n#### 4) Package and publish your build\n\nInstall the `aws-sdk`:\n\n    npm install aws-sdk\n\nThen publish:\n\n    node-pre-gyp package publish\n\nNote: if you hit an error like `Hostname/IP doesn't match certificate's altnames` it may mean that you need to provide the `region` option in your config.\n\n## Appveyor Automation\n\n[Appveyor](http://www.appveyor.com/) can build binaries and publish the results per commit and supports:\n\n - Windows Visual Studio 2013 and related compilers\n - Both 64 bit (x64) and 32 bit (x86) build configurations\n - Multiple Node.js versions\n\nFor an example of doing this see [node-sqlite3's appveyor.yml](https://github.com/mapbox/node-sqlite3/blob/master/appveyor.yml).\n\nBelow is a guide to getting set up:\n\n#### 1) Create a free Appveyor account\n\nGo to https://ci.appveyor.com/signup/free and sign in with your github account.\n\n#### 2) Create a new project\n\nGo to https://ci.appveyor.com/projects/new and select the github repo for your module\n\n#### 3) Add appveyor.yml and push it\n\nOnce you have committed an `appveyor.yml` ([appveyor.yml reference](http://www.appveyor.com/docs/appveyor-yml)) to your github repo and pushed it appveyor should automatically start building your project.\n\n#### 4) Create secure variables\n\nEncrypt your S3 AWS keys by going to <https://ci.appveyor.com/tools/encrypt> and hitting the `encrypt` button.\n\nThen paste the result into your `appveyor.yml`\n\n```yml\nenvironment:\n  node_pre_gyp_accessKeyId:\n    secure: Dn9HKdLNYvDgPdQOzRq/DqZ/MPhjknRHB1o+/lVU8MA=\n  node_pre_gyp_secretAccessKey:\n    secure: W1rwNoSnOku1r+28gnoufO8UA8iWADmL1LiiwH9IOkIVhDTNGdGPJqAlLjNqwLnL\n```\n\nNOTE: keys are per account but not per repo (this is difference than travis where keys are per repo but not related to the account used to encrypt them).\n\n#### 5) Hook up publishing\n\nJust put `node-pre-gyp package publish` in your `appveyor.yml` after `npm install`.\n\n#### 6) Publish when you want\n\nYou might wish to publish binaries only on a specific commit. To do this you could borrow from the [travis.ci idea of commit keywords](http://about.travis-ci.org/docs/user/how-to-skip-a-build/) and add special handling for commit messages with `[publish binary]`:\n\n    SET CM=%APPVEYOR_REPO_COMMIT_MESSAGE%\n    if not \"%CM%\" == \"%CM:[publish binary]=%\" node-pre-gyp --msvs_version=2013 publish\n\nIf your commit message contains special characters (e.g. `&`) this method might fail. An alternative is to use PowerShell, which gives you additional possibilities, like ignoring case by using `ToLower()`:\n\n    ps: if($env:APPVEYOR_REPO_COMMIT_MESSAGE.ToLower().Contains('[publish binary]')) { node-pre-gyp --msvs_version=2013 publish }\n\nRemember this publishing is not the same as `npm publish`. We're just talking about the binary module here and not your entire npm package. To automate the publishing of your entire package to npm on travis see http://about.travis-ci.org/docs/user/deployment/npm/\n\n\n## Travis Automation\n\n[Travis](https://travis-ci.org/) can push to S3 after a successful build and supports both:\n\n - Ubuntu Precise and OS X (64 bit)\n - Multiple Node.js versions\n\nFor an example of doing this see [node-add-example's .travis.yml](https://github.com/springmeyer/node-addon-example/blob/2ff60a8ded7f042864ad21db00c3a5a06cf47075/.travis.yml).\n\nNote: if you need 32 bit binaries, this can be done from a 64 bit travis machine. See [the node-sqlite3 scripts for an example of doing this](https://github.com/mapbox/node-sqlite3/blob/bae122aa6a2b8a45f6b717fab24e207740e32b5d/scripts/build_against_node.sh#L54-L74).\n\nBelow is a guide to getting set up:\n\n#### 1) Install the travis gem\n\n    gem install travis\n\n#### 2) Create secure variables\n\nMake sure you run this command from within the directory of your module.\n\nUse `travis-encrypt` like:\n\n    travis encrypt node_pre_gyp_accessKeyId=${node_pre_gyp_accessKeyId}\n    travis encrypt node_pre_gyp_secretAccessKey=${node_pre_gyp_secretAccessKey}\n\nThen put those values in your `.travis.yml` like:\n\n```yaml\nenv:\n  global:\n    - secure: F+sEL/v56CzHqmCSSES4pEyC9NeQlkoR0Gs/ZuZxX1ytrj8SKtp3MKqBj7zhIclSdXBz4Ev966Da5ctmcTd410p0b240MV6BVOkLUtkjZJyErMBOkeb8n8yVfSoeMx8RiIhBmIvEn+rlQq+bSFis61/JkE9rxsjkGRZi14hHr4M=\n    - secure: o2nkUQIiABD139XS6L8pxq3XO5gch27hvm/gOdV+dzNKc/s2KomVPWcOyXNxtJGhtecAkABzaW8KHDDi5QL1kNEFx6BxFVMLO8rjFPsMVaBG9Ks6JiDQkkmrGNcnVdxI/6EKTLHTH5WLsz8+J7caDBzvKbEfTux5EamEhxIWgrI=\n```\n\nMore details on travis encryption at http://about.travis-ci.org/docs/user/encryption-keys/.\n\n#### 3) Hook up publishing\n\nJust put `node-pre-gyp package publish` in your `.travis.yml` after `npm install`.\n\n##### OS X publishing\n\nIf you want binaries for OS X in addition to linux you have two options:\n\n1) [Enabling multi-OS](#enabling-multi-os)\n\n2) [Using `language: objective-c` in a git branch](#using-language-objective-c).\n\n##### Enabling multi-OS\n\nThis requires emailing a request to `support@travis-ci.com` for each repo you wish to have enabled. More details at <http://docs.travis-ci.com/user/multi-os/>.\n\nNext you need to tweak the `.travis.yml` to ensure it is cross platform.\n\nUse a configuration like:\n\n```yml\n\nlanguage: cpp\n\nos:\n- linux\n- osx\n\nenv:\n  matrix:\n    - NODE_VERSION=\"0.10\"\n    - NODE_VERSION=\"0.11.14\"\n\nbefore_install:\n- rm -rf ~/.nvm/ && git clone --depth 1 https://github.com/creationix/nvm.git ~/.nvm\n- source ~/.nvm/nvm.sh\n- nvm install $NODE_VERSION\n- nvm use $NODE_VERSION\n```\n\nSee [Travis OS X Gochas](#travis-os-x-gochas) for why we replace `language: node_js` and `node_js:` sections with `language: cpp` and a custom matrix.\n\n\nAlso create platform specific sections for any deps that need install. For example if you need libpng:\n\n```yml\n- if [ $(uname -s) == 'Linux' ]; then apt-get install libpng-dev; fi;\n- if [ $(uname -s) == 'Darwin' ]; then brew install libpng; fi;\n```\n\nFor detailed multi-OS examples see [node-mapnik](https://github.com/mapnik/node-mapnik/blob/master/.travis.yml) and [node-sqlite3](https://github.com/mapbox/node-sqlite3/blob/master/.travis.yml).\n\n##### Using `language: objective-c`\n\nIf your repo does not have multi-OS enabled, an alternative method for building for OS X is to tweak your `.travis.yml` to use:\n\n```yml\nlanguage: objective-c\n```\n\nKeep that change in a different git branch and sync that when you want binaries published.\n\nNext learn about a few [Travis OS X Gochas](#travis-os-x-gochas).\n\n##### Travis OS X Gochas\n\nFirst, unlike the Travis linux machines the OS X machines do not put `node-pre-gyp` on PATH by default. So to you will need to:\n\n```sh\nexport PATH=$(pwd)/node_modules/.bin:${PATH}\n```\n\nSecond, the OS X machines doe not support using a matrix for installing node.js different versions. So you need to bootstrap the installation of node.js in a cross platform way. \n\nBy doing:\n\n```yml\nenv:\n  matrix:\n    - NODE_VERSION=\"0.10\"\n    - NODE_VERSION=\"0.11.14\"\n\nbefore_install:\n - rm -rf ~/.nvm/ && git clone --depth 1 https://github.com/creationix/nvm.git ~/.nvm\n - source ~/.nvm/nvm.sh\n - nvm install $NODE_VERSION\n - nvm use $NODE_VERSION\n```\n\nYou can easily recreate the previous behavior of this matrix:\n\n```yml\nnode_js:\n  - \"0.10\"\n  - \"0.11.14\"\n```\n\n#### 4) Publish when you want\n\nYou might wish to publish binaries only on a specific commit. To do this you could borrow from the [travis.ci idea of commit keywords](http://about.travis-ci.org/docs/user/how-to-skip-a-build/) and add special handling for commit messages with `[publish binary]`:\n\n    COMMIT_MESSAGE=$(git show -s --format=%B $TRAVIS_COMMIT | tr -d '\\n')\n    if [[ ${COMMIT_MESSAGE} =~ \"[publish binary]\" ]]; then node-pre-gyp publish; fi;\n\nThen you can trigger new binaries to be built like:\n\n    git commit -a -m \"[publish binary]\"\n\nOr, if you don't have any changes to make simply run:\n\n    git commit --allow-empty -m \"[publish binary]\"\n\nRemember this publishing is not the same as `npm publish`. We're just talking about the binary module here and not your entire npm package. To automate the publishing of your entire package to npm on travis see http://about.travis-ci.org/docs/user/deployment/npm/\n\n# Versioning\n\nThe `binary` properties of `module_path`, `remote_path`, and `package_name` support variable substitution. The strings are evaluated by `node-pre-gyp` depending on your system and any custom build flags you passed.\n\n - `node_abi`: The node C++ `ABI` number. This value is available in Javascript as `process.versions.modules` as of [`>= v0.10.4 >= v0.11.7`](https://github.com/joyent/node/commit/ccabd4a6fa8a6eb79d29bc3bbe9fe2b6531c2d8e) and in C++ as the `NODE_MODULE_VERSION` define much earlier. For versions of Node before this was available we fallback to the V8 major and minor version.\n - `platform` matches node's `process.platform` like `linux`, `darwin`, and `win32` unless the user passed the `--target_platform` option to override.\n - `arch` matches node's `process.arch` like `x64` or `ia32` unless the user passes the `--target_arch` option to override.\n - `configuration` - Either 'Release' or 'Debug' depending on if `--debug` is passed during the build.\n - `module_name` - the `binary.module_name` attribute from `package.json`.\n - `version` - the semver `version` value for your module from `package.json` (NOTE: ignores the `semver.build` property).\n - `major`, `minor`, `patch`, and `prelease` match the individual semver values for your module's `version`\n - `build` - the sevmer `build` value. For example it would be `this.that` if your package.json `version` was `v1.0.0+this.that`\n - `prerelease` - the semver `prerelease` value. For example it would be `alpha.beta` if your package.json `version` was `v1.0.0-alpha.beta`\n\n\nThe options are visible in the code at <https://github.com/mapbox/node-pre-gyp/blob/612b7bca2604508d881e1187614870ba19a7f0c5/lib/util/versioning.js#L114-L127>\n",
                "readmeFilename": "README.md",
                "bugs": {
                    "url": "https://github.com/mapbox/node-pre-gyp/issues"
                },
                "bundleDependencies": [
                    "nopt",
                    "npmlog",
                    "request",
                    "semver",
                    "tar",
                    "tar-pack",
                    "mkdirp",
                    "rc",
                    "rimraf"
                ],
                "_id": "node-pre-gyp@0.6.7",
                "dist": {
                    "shasum": "d1126d63b61acdbd6cfe92b268a6d810ab3b670c"
                },
                "_from": "node-pre-gyp@~0.6.2",
                "_resolved": "https://registry.npmjs.org/node-pre-gyp/-/node-pre-gyp-0.6.7.tgz"
            }

        }, {}], 122: [function (require, module, exports) {
            (function (__dirname) {
                var binary = require('node-pre-gyp');
                var path = require('path');
                var binding_path = binary.find(path.resolve(path.join(__dirname, './package.json')));
                
                module.exports = require(binding_path).leveldown;
            }).call(this, "/../node_modules/leveldown")
        }, { "node-pre-gyp": 85, "path": 321 }], 123: [function (require, module, exports) {
            /* Copyright (c) 2012-2015 LevelUP contributors
 * See list at <https://github.com/level/levelup#contributing>
 * MIT License
 * <https://github.com/level/levelup/blob/master/LICENSE.md>
 */

var util = require('./util')
  , WriteError = require('level-errors').WriteError

  , getOptions = util.getOptions
  , dispatchError = util.dispatchError
            
            function Batch(levelup, codec) {
                this._levelup = levelup
                this._codec = codec
                this.batch = levelup.db.batch()
                this.ops = []
            }
            
            Batch.prototype.put = function (key_, value_, options) {
                options = getOptions(options)
                
                var key = this._codec.encodeKey(key_, options)
    , value = this._codec.encodeValue(value_, options)
                
                try {
                    this.batch.put(key, value)
                } catch (e) {
                    throw new WriteError(e)
                }
                this.ops.push({ type : 'put', key : key, value : value })
                
                return this
            }
            
            Batch.prototype.del = function (key_, options) {
                options = getOptions(options)
                
                var key = this._codec.encodeKey(key_, options)
                
                try {
                    this.batch.del(key)
                } catch (err) {
                    throw new WriteError(err)
                }
                this.ops.push({ type : 'del', key : key })
                
                return this
            }
            
            Batch.prototype.clear = function () {
                try {
                    this.batch.clear()
                } catch (err) {
                    throw new WriteError(err)
                }
                
                this.ops = []
                return this
            }
            
            Batch.prototype.write = function (callback) {
                var levelup = this._levelup
    , ops = this.ops
                
                try {
                    this.batch.write(function (err) {
                        if (err)
                            return dispatchError(levelup, new WriteError(err), callback)
                        levelup.emit('batch', ops)
                        if (callback)
                            callback()
                    })
                } catch (err) {
                    throw new WriteError(err)
                }
            }
            
            module.exports = Batch

        }, { "./util": 125, "level-errors": 132 }], 124: [function (require, module, exports) {
            (function (process) {
                /* Copyright (c) 2012-2015 LevelUP contributors
 * See list at <https://github.com/level/levelup#contributing>
 * MIT License
 * <https://github.com/level/levelup/blob/master/LICENSE.md>
 */

var EventEmitter = require('events').EventEmitter
  , inherits = require('util').inherits
  , deprecate = require('util').deprecate
  , extend = require('xtend')
  , prr = require('prr')
  , DeferredLevelDOWN = require('deferred-leveldown')
  , IteratorStream = require('level-iterator-stream')

  , errors = require('level-errors')
  , WriteError = errors.WriteError
  , ReadError = errors.ReadError
  , NotFoundError = errors.NotFoundError
  , OpenError = errors.OpenError
  , EncodingError = errors.EncodingError
  , InitializationError = errors.InitializationError

  , util = require('./util')
  , Batch = require('./batch')
  , Codec = require('level-codec')

  , getOptions = util.getOptions
  , defaultOptions = util.defaultOptions
  , getLevelDOWN = util.getLevelDOWN
  , dispatchError = util.dispatchError
  , isDefined = util.isDefined
                
                function getCallback(options, callback) {
                    return typeof options == 'function' ? options : callback
                }
                
                // Possible LevelUP#_status values:
                //  - 'new'     - newly created, not opened or closed
                //  - 'opening' - waiting for the database to be opened, post open()
                //  - 'open'    - successfully opened the database, available for use
                //  - 'closing' - waiting for the database to be closed, post close()
                //  - 'closed'  - database has been successfully closed, should not be
                //                 used except for another open() operation
                
                function LevelUP(location, options, callback) {
                    if (!(this instanceof LevelUP))
                        return new LevelUP(location, options, callback)
                    
                    var error
                    
                    EventEmitter.call(this)
                    this.setMaxListeners(Infinity)
                    
                    if (typeof location == 'function') {
                        options = typeof options == 'object' ? options : {}
                        options.db = location
                        location = null
                    } else if (typeof location == 'object' && typeof location.db == 'function') {
                        options = location
                        location = null
                    }
                    
                    
                    if (typeof options == 'function') {
                        callback = options
                        options = {}
                    }
                    
                    if ((!options || typeof options.db != 'function') && typeof location != 'string') {
                        error = new InitializationError(
                            'Must provide a location for the database')
                        if (callback) {
                            return process.nextTick(function () {
                                callback(error)
                            })
                        }
                        throw error
                    }
                    
                    options = getOptions(options)
                    this.options = extend(defaultOptions, options)
                    this._codec = new Codec(this.options)
                    this._status = 'new'
                    // set this.location as enumerable but not configurable or writable
                    prr(this, 'location', location, 'e')
                    
                    this.open(callback)
                }
                
                inherits(LevelUP, EventEmitter)
                
                LevelUP.prototype.open = function (callback) {
                    var self = this
    , dbFactory
    , db
                    
                    if (this.isOpen()) {
                        if (callback)
                            process.nextTick(function () { callback(null, self) })
                        return this
                    }
                    
                    if (this._isOpening()) {
                        return callback && this.once(
                            'open'
      , function () { callback(null, self) }
                        )
                    }
                    
                    this.emit('opening')
                    
                    this._status = 'opening'
                    this.db = new DeferredLevelDOWN(this.location)
                    dbFactory = this.options.db || getLevelDOWN()
                    db = dbFactory(this.location)
                    
                    db.open(this.options, function (err) {
                        if (err) {
                            return dispatchError(self, new OpenError(err), callback)
                        } else {
                            self.db.setDb(db)
                            self.db = db
                            self._status = 'open'
                            if (callback)
                                callback(null, self)
                            self.emit('open')
                            self.emit('ready')
                        }
                    })
                }
                
                LevelUP.prototype.close = function (callback) {
                    var self = this
                    
                    if (this.isOpen()) {
                        this._status = 'closing'
                        this.db.close(function () {
                            self._status = 'closed'
                            self.emit('closed')
                            if (callback)
                                callback.apply(null, arguments)
                        })
                        this.emit('closing')
                        this.db = new DeferredLevelDOWN(this.location)
                    } else if (this._status == 'closed' && callback) {
                        return process.nextTick(callback)
                    } else if (this._status == 'closing' && callback) {
                        this.once('closed', callback)
                    } else if (this._isOpening()) {
                        this.once('open', function () {
                            self.close(callback)
                        })
                    }
                }
                
                LevelUP.prototype.isOpen = function () {
                    return this._status == 'open'
                }
                
                LevelUP.prototype._isOpening = function () {
                    return this._status == 'opening'
                }
                
                LevelUP.prototype.isClosed = function () {
                    return (/^clos/).test(this._status)
                }
                
                function maybeError(db, options, callback) {
                    if (!db._isOpening() && !db.isOpen()) {
                        dispatchError(
                            db
      , new ReadError('Database is not open')
      , callback
                        )
                        return true
                    }
                }
                
                function writeError(db, message, callback) {
                    dispatchError(
                        db
     , new WriteError(message)
     , callback
                    )
                }
                
                function readError(db, message, callback) {
                    dispatchError(
                        db
     , new ReadError(message)
     , callback
                    )
                }
                
                
                LevelUP.prototype.get = function (key_, options, callback) {
                    var self = this
    , key
                    
                    callback = getCallback(options, callback)
                    
                    if (maybeError(this, options, callback))
                        return
                    
                    if (key_ === null || key_ === undefined || 'function' !== typeof callback)
                        return readError(this
      , 'get() requires key and callback arguments', callback)
                    
                    options = util.getOptions(options)
                    key = this._codec.encodeKey(key_, options)
                    
                    options.asBuffer = this._codec.valueAsBuffer(options)
                    
                    this.db.get(key, options, function (err, value) {
                        if (err) {
                            if ((/notfound/i).test(err) || err.notFound) {
                                err = new NotFoundError(
                                    'Key not found in database [' + key_ + ']', err)
                            } else {
                                err = new ReadError(err)
                            }
                            return dispatchError(self, err, callback)
                        }
                        if (callback) {
                            try {
                                value = self._codec.decodeValue(value, options)
                            } catch (e) {
                                return callback(new EncodingError(e))
                            }
                            callback(null, value)
                        }
                    })
                }
                
                LevelUP.prototype.put = function (key_, value_, options, callback) {
                    var self = this
    , key
    , value
                    
                    callback = getCallback(options, callback)
                    
                    if (key_ === null || key_ === undefined)
                        return writeError(this, 'put() requires a key argument', callback)
                    
                    if (maybeError(this, options, callback))
                        return
                    
                    options = getOptions(options)
                    key = this._codec.encodeKey(key_, options)
                    value = this._codec.encodeValue(value_, options)
                    
                    this.db.put(key, value, options, function (err) {
                        if (err) {
                            return dispatchError(self, new WriteError(err), callback)
                        } else {
                            self.emit('put', key_, value_)
                            if (callback)
                                callback()
                        }
                    })
                }
                
                LevelUP.prototype.del = function (key_, options, callback) {
                    var self = this
    , key
                    
                    callback = getCallback(options, callback)
                    
                    if (key_ === null || key_ === undefined)
                        return writeError(this, 'del() requires a key argument', callback)
                    
                    if (maybeError(this, options, callback))
                        return
                    
                    options = getOptions(options)
                    key = this._codec.encodeKey(key_, options)
                    
                    this.db.del(key, options, function (err) {
                        if (err) {
                            return dispatchError(self, new WriteError(err), callback)
                        } else {
                            self.emit('del', key_)
                            if (callback)
                                callback()
                        }
                    })
                }
                
                LevelUP.prototype.batch = function (arr_, options, callback) {
                    var self = this
    , keyEnc
    , valueEnc
    , arr
                    
                    if (!arguments.length)
                        return new Batch(this, this._codec)
                    
                    callback = getCallback(options, callback)
                    
                    if (!Array.isArray(arr_))
                        return writeError(this, 'batch() requires an array argument', callback)
                    
                    if (maybeError(this, options, callback))
                        return
                    
                    options = getOptions(options)
                    arr = self._codec.encodeBatch(arr_, options)
                    arr = arr.map(function (op) {
                        if (!op.type && op.key !== undefined && op.value !== undefined)
                            op.type = 'put'
                        return op
                    })
                    
                    this.db.batch(arr, options, function (err) {
                        if (err) {
                            return dispatchError(self, new WriteError(err), callback)
                        } else {
                            self.emit('batch', arr_)
                            if (callback)
                                callback()
                        }
                    })
                }
                
                LevelUP.prototype.approximateSize = deprecate(function (start_, end_, options, callback) {
                    var self = this
    , start    
    , end
                    
                    callback = getCallback(options, callback)
                    
                    options = getOptions(options)
                    
                    if (start_ === null || start_ === undefined 
                        || end_ === null || end_ === undefined || 'function' !== typeof callback)
                        return readError(this, 'approximateSize() requires start, end and callback arguments', callback)
                    
                    start = this._codec.encodeKey(start_, options)
                    end = this._codec.encodeKey(end_, options)
                    
                    this.db.approximateSize(start, end, function (err, size) {
                        if (err) {
                            return dispatchError(self, new OpenError(err), callback)
                        } else if (callback) {
                            callback(null, size)
                        }
                    })
                }, 'db.approximateSize() is deprecated. Use db.db.approximateSize() instead')
                
                LevelUP.prototype.readStream =
LevelUP.prototype.createReadStream = function (options) {
                    options = extend({ keys: true, values: true }, this.options, options)
                    
                    options.keyEncoding = options.keyEncoding
                    options.valueEncoding = options.valueEncoding
                    
                    options = this._codec.encodeLtgt(options);
                    options.keyAsBuffer = this._codec.keyAsBuffer(options)
                    options.valueAsBuffer = this._codec.valueAsBuffer(options)
                    
                    if ('number' !== typeof options.limit)
                        options.limit = -1
                    
                    return new IteratorStream(this.db.iterator(options), extend(options, {
                        decoder: this._codec.createStreamDecoder(options)
                    }))
                }
                
                LevelUP.prototype.keyStream =
LevelUP.prototype.createKeyStream = function (options) {
                    return this.createReadStream(extend(options, { keys: true, values: false }))
                }
                
                LevelUP.prototype.valueStream =
LevelUP.prototype.createValueStream = function (options) {
                    return this.createReadStream(extend(options, { keys: false, values: true }))
                }
                
                LevelUP.prototype.toString = function () {
                    return 'LevelUP'
                }
                
                function utilStatic(name) {
                    return function (location, callback) {
                        getLevelDOWN()[name](location, callback || function () { })
                    }
                }
                
                module.exports = LevelUP
                module.exports.errors = require('level-errors')
                module.exports.destroy = deprecate(
                    utilStatic('destroy')
  , 'levelup.destroy() is deprecated. Use leveldown.destroy() instead'
                )
                module.exports.repair = deprecate(
                    utilStatic('repair')
  , 'levelup.repair() is deprecated. Use leveldown.repair() instead'
                )


            }).call(this, require('_process'))
        }, { "./batch": 123, "./util": 125, "_process": 322, "deferred-leveldown": 126, "events": 317, "level-codec": 130, "level-errors": 132, "level-iterator-stream": 136, "prr": 147, "util": 342, "xtend": 148 }], 125: [function (require, module, exports) {
            /* Copyright (c) 2012-2015 LevelUP contributors
 * See list at <https://github.com/level/levelup#contributing>
 * MIT License
 * <https://github.com/level/levelup/blob/master/LICENSE.md>
 */

var extend = require('xtend')
  , LevelUPError = require('level-errors').LevelUPError
  , format = require('util').format
  , defaultOptions = {
                    createIfMissing : true
                    , errorIfExists   : false
                    , keyEncoding     : 'utf8'
                    , valueEncoding   : 'utf8'
                    , compression     : true
                }

  , leveldown
            
            function getOptions(options) {
                if (typeof options == 'string')
                    options = { valueEncoding: options }
                if (typeof options != 'object')
                    options = {}
                return options
            }
            
            function getLevelDOWN() {
                if (leveldown)
                    return leveldown
                
                var requiredVersion = require('../package.json').devDependencies.leveldown
    , leveldownVersion
                
                try {
                    leveldownVersion = require('leveldown/package').version
                } catch (e) {
                    throw requireError(e)
                }
                
                if (!require('semver').satisfies(leveldownVersion, requiredVersion)) {
                    throw new LevelUPError(
                        'Installed version of LevelDOWN (' 
      + leveldownVersion 
      + ') does not match required version (' 
      + requiredVersion 
      + ')'
                    )
                }
                
                try {
                    return leveldown = require('leveldown')
                } catch (e) {
                    throw requireError(e)
                }
            }
            
            function requireError(e) {
                var template = 'Failed to require LevelDOWN (%s). Try `npm install leveldown` if it\'s missing'
                return new LevelUPError(format(template, e.message))
            }
            
            function dispatchError(db, error, callback) {
                typeof callback == 'function' ? callback(error) : db.emit('error', error)
            }
            
            function isDefined(v) {
                return typeof v !== 'undefined'
            }
            
            module.exports = {
                defaultOptions  : defaultOptions
                , getOptions      : getOptions
                , getLevelDOWN    : getLevelDOWN
                , dispatchError   : dispatchError
                , isDefined       : isDefined
            }

        }, { "../package.json": 149, "level-errors": 132, "leveldown": 171, "leveldown/package": 171, "semver": 171, "util": 342, "xtend": 148 }], 126: [function (require, module, exports) {
            (function (process, Buffer) {
                var util = require('util')
  , AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
  , AbstractIterator = require('abstract-leveldown').AbstractIterator
                
                function DeferredLevelDOWN(location) {
                    AbstractLevelDOWN.call(this, typeof location == 'string' ? location : '') // optional location, who cares?
                    this._db = undefined
                    this._operations = []
                    this._iterators = []
                }
                
                util.inherits(DeferredLevelDOWN, AbstractLevelDOWN)
                
                // called by LevelUP when we have a real DB to take its place
                DeferredLevelDOWN.prototype.setDb = function (db) {
                    this._db = db
                    this._operations.forEach(function (op) {
                        db[op.method].apply(db, op.args)
                    })
                    this._iterators.forEach(function (it) {
                        it.setDb(db)
                    })
                }
                
                DeferredLevelDOWN.prototype._open = function (options, callback) {
                    return process.nextTick(callback)
                }
                
                // queue a new deferred operation
                DeferredLevelDOWN.prototype._operation = function (method, args) {
                    if (this._db)
                        return this._db[method].apply(this._db, args)
                    this._operations.push({ method: method, args: args })
                }
                
                // deferrables
                'put get del batch approximateSize'.split(' ').forEach(function (m) {
                    DeferredLevelDOWN.prototype['_' + m] = function () {
                        this._operation(m, arguments)
                    }
                })
                
                DeferredLevelDOWN.prototype._isBuffer = function (obj) {
                    return Buffer.isBuffer(obj)
                }
                
                DeferredLevelDOWN.prototype._iterator = function (options) {
                    var it = new Iterator(options)
                    this._iterators.push(it)
                    return it
                }
                
                function Iterator(options) {
                    AbstractIterator.call(this, options)
                    
                    this._options = options
                    this._iterator = null
                    this._operations = []
                }
                
                util.inherits(Iterator, AbstractIterator)
                
                Iterator.prototype.setDb = function (db) {
                    var it = this._iterator = db.iterator(this._options)
                    this._operations.forEach(function (op) {
                        it[op.method].apply(it, op.args)
                    })
                }
                
                Iterator.prototype._operation = function (method, args) {
                    if (this._iterator)
                        return this._iterator[method].apply(this._iterator, args)
                    this._operations.push({ method: method, args: args })
                }
                
                'next end'.split(' ').forEach(function (m) {
                    Iterator.prototype['_' + m] = function () {
                        this._operation(m, arguments)
                    }
                })
                
                module.exports = DeferredLevelDOWN


            }).call(this, require('_process'), require("buffer").Buffer)
        }, { "_process": 322, "abstract-leveldown": 129, "buffer": 172, "util": 342 }], 127: [function (require, module, exports) {
            arguments[4][78][0].apply(exports, arguments)
        }, { "_process": 322, "dup": 78 }], 128: [function (require, module, exports) {
            arguments[4][62][0].apply(exports, arguments)
        }, { "_process": 322, "dup": 62 }], 129: [function (require, module, exports) {
            (function (process, Buffer) {
                /* Copyright (c) 2013 Rod Vagg, MIT License */
                
                var xtend = require('xtend')
  , AbstractIterator = require('./abstract-iterator')
  , AbstractChainedBatch = require('./abstract-chained-batch')
                
                function AbstractLevelDOWN(location) {
                    if (!arguments.length || location === undefined)
                        throw new Error('constructor requires at least a location argument')
                    
                    if (typeof location != 'string')
                        throw new Error('constructor requires a location string argument')
                    
                    this.location = location
                }
                
                AbstractLevelDOWN.prototype.open = function (options, callback) {
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('open() requires a callback argument')
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    options.createIfMissing = options.createIfMissing != false
                    options.errorIfExists = !!options.errorIfExists
                    
                    if (typeof this._open == 'function')
                        return this._open(options, callback)
                    
                    process.nextTick(callback)
                }
                
                AbstractLevelDOWN.prototype.close = function (callback) {
                    if (typeof callback != 'function')
                        throw new Error('close() requires a callback argument')
                    
                    if (typeof this._close == 'function')
                        return this._close(callback)
                    
                    process.nextTick(callback)
                }
                
                AbstractLevelDOWN.prototype.get = function (key, options, callback) {
                    var err
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('get() requires a callback argument')
                    
                    if (err = this._checkKey(key, 'key', this._isBuffer))
                        return callback(err)
                    
                    if (!this._isBuffer(key))
                        key = String(key)
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    options.asBuffer = options.asBuffer != false
                    
                    if (typeof this._get == 'function')
                        return this._get(key, options, callback)
                    
                    process.nextTick(function () { callback(new Error('NotFound')) })
                }
                
                AbstractLevelDOWN.prototype.put = function (key, value, options, callback) {
                    var err
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('put() requires a callback argument')
                    
                    if (err = this._checkKey(key, 'key', this._isBuffer))
                        return callback(err)
                    
                    if (!this._isBuffer(key))
                        key = String(key)
                    
                    // coerce value to string in node, don't touch it in browser
                    // (indexeddb can store any JS type)
                    if (value != null && !this._isBuffer(value) && !process.browser)
                        value = String(value)
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    if (typeof this._put == 'function')
                        return this._put(key, value, options, callback)
                    
                    process.nextTick(callback)
                }
                
                AbstractLevelDOWN.prototype.del = function (key, options, callback) {
                    var err
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof callback != 'function')
                        throw new Error('del() requires a callback argument')
                    
                    if (err = this._checkKey(key, 'key', this._isBuffer))
                        return callback(err)
                    
                    if (!this._isBuffer(key))
                        key = String(key)
                    
                    if (typeof options != 'object')
                        options = {}
                    
                    if (typeof this._del == 'function')
                        return this._del(key, options, callback)
                    
                    process.nextTick(callback)
                }
                
                AbstractLevelDOWN.prototype.batch = function (array, options, callback) {
                    if (!arguments.length)
                        return this._chainedBatch()
                    
                    if (typeof options == 'function')
                        callback = options
                    
                    if (typeof array == 'function')
                        callback = array
                    
                    if (typeof callback != 'function')
                        throw new Error('batch(array) requires a callback argument')
                    
                    if (!Array.isArray(array))
                        return callback(new Error('batch(array) requires an array argument'))
                    
                    if (!options || typeof options != 'object')
                        options = {}
                    
                    var i = 0
    , l = array.length
    , e
    , err
                    
                    for (; i < l; i++) {
                        e = array[i]
                        if (typeof e != 'object')
                            continue
                        
                        if (err = this._checkKey(e.type, 'type', this._isBuffer))
                            return callback(err)
                        
                        if (err = this._checkKey(e.key, 'key', this._isBuffer))
                            return callback(err)
                    }
                    
                    if (typeof this._batch == 'function')
                        return this._batch(array, options, callback)
                    
                    process.nextTick(callback)
                }
                
                //TODO: remove from here, not a necessary primitive
                AbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {
                    if (start == null 
      || end == null 
      || typeof start == 'function' 
      || typeof end == 'function') {
                        throw new Error('approximateSize() requires valid `start`, `end` and `callback` arguments')
                    }
                    
                    if (typeof callback != 'function')
                        throw new Error('approximateSize() requires a callback argument')
                    
                    if (!this._isBuffer(start))
                        start = String(start)
                    
                    if (!this._isBuffer(end))
                        end = String(end)
                    
                    if (typeof this._approximateSize == 'function')
                        return this._approximateSize(start, end, callback)
                    
                    process.nextTick(function () {
                        callback(null, 0)
                    })
                }
                
                AbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {
                    var self = this
                    
                    options = xtend(options)

                    ; ['start', 'end', 'gt', 'gte', 'lt', 'lte'].forEach(function (o) {
                        if (options[o] && self._isBuffer(options[o]) && options[o].length === 0)
                            delete options[o]
                    })
                    
                    options.reverse = !!options.reverse
                    options.keys = options.keys != false
                    options.values = options.values != false
                    options.limit = 'limit' in options ? options.limit : -1
                    options.keyAsBuffer = options.keyAsBuffer != false
                    options.valueAsBuffer = options.valueAsBuffer != false
                    
                    return options
                }
                
                AbstractLevelDOWN.prototype.iterator = function (options) {
                    if (typeof options != 'object')
                        options = {}
                    
                    options = this._setupIteratorOptions(options)
                    
                    if (typeof this._iterator == 'function')
                        return this._iterator(options)
                    
                    return new AbstractIterator(this)
                }
                
                AbstractLevelDOWN.prototype._chainedBatch = function () {
                    return new AbstractChainedBatch(this)
                }
                
                AbstractLevelDOWN.prototype._isBuffer = function (obj) {
                    return Buffer.isBuffer(obj)
                }
                
                AbstractLevelDOWN.prototype._checkKey = function (obj, type) {
                    
                    if (obj === null || obj === undefined)
                        return new Error(type + ' cannot be `null` or `undefined`')
                    
                    if (this._isBuffer(obj)) {
                        if (obj.length === 0)
                            return new Error(type + ' cannot be an empty Buffer')
                    } else if (String(obj) === '')
                        return new Error(type + ' cannot be an empty String')
                }
                
                module.exports.AbstractLevelDOWN = AbstractLevelDOWN
                module.exports.AbstractIterator = AbstractIterator
                module.exports.AbstractChainedBatch = AbstractChainedBatch

            }).call(this, require('_process'), require("buffer").Buffer)
        }, { "./abstract-chained-batch": 127, "./abstract-iterator": 128, "_process": 322, "buffer": 172, "xtend": 148 }], 130: [function (require, module, exports) {
            var encodings = require('./lib/encodings');
            
            module.exports = Codec;
            
            function Codec(opts) {
                this.opts = opts || {};
                this.encodings = encodings;
            }
            
            Codec.prototype._encoding = function (encoding) {
                if (typeof encoding == 'string') encoding = encodings[encoding];
                if (!encoding) encoding = encodings.id;
                return encoding;
            };
            
            Codec.prototype._keyEncoding = function (opts, batchOpts) {
                return this._encoding(batchOpts && batchOpts.keyEncoding 
    || opts && opts.keyEncoding 
    || this.opts.keyEncoding);
            };
            
            Codec.prototype._valueEncoding = function (opts, batchOpts) {
                return this._encoding(batchOpts && batchOpts.valueEncoding 
    || opts && opts.valueEncoding 
    || this.opts.valueEncoding);
            };
            
            Codec.prototype.encodeKey = function (key, opts, batchOpts) {
                return this._keyEncoding(opts, batchOpts).encode(key);
            };
            
            Codec.prototype.encodeValue = function (value, opts, batchOpts) {
                return this._valueEncoding(opts, batchOpts).encode(value);
            };
            
            Codec.prototype.decodeKey = function (key, opts) {
                return this._keyEncoding(opts).decode(key);
            };
            
            Codec.prototype.decodeValue = function (value, opts) {
                return this._valueEncoding(opts).decode(value);
            };
            
            Codec.prototype.encodeBatch = function (ops, opts) {
                var self = this;
                
                return ops.map(function (_op) {
                    var op = {
                        type: _op.type,
                        key: self.encodeKey(_op.key, opts, _op)
                    };
                    if (self.keyAsBuffer(opts, _op)) op.keyEncoding = 'binary';
                    if (_op.prefix) op.prefix = _op.prefix;
                    if ('value' in _op) {
                        op.value = self.encodeValue(_op.value, opts, _op);
                        if (self.valueAsBuffer(opts, _op)) op.valueEncoding = 'binary';
                    }
                    return op;
                });
            };
            
            var ltgtKeys = ['lt', 'gt', 'lte', 'gte', 'start', 'end'];
            
            Codec.prototype.encodeLtgt = function (ltgt) {
                var self = this;
                var ret = {};
                Object.keys(ltgt).forEach(function (key) {
                    ret[key] = ltgtKeys.indexOf(key) > -1
      ? self.encodeKey(ltgt[key], ltgt)
      : ltgt[key]
                });
                return ret;
            };
            
            Codec.prototype.createStreamDecoder = function (opts) {
                var self = this;
                
                if (opts.keys && opts.values) {
                    return function (key, value) {
                        return {
                            key: self.decodeKey(key, opts),
                            value: self.decodeValue(value, opts)
                        };
                    };
                } else if (opts.keys) {
                    return function (key) {
                        return self.decodeKey(key, opts);
                    };
                } else if (opts.values) {
                    return function (_, value) {
                        return self.decodeValue(value, opts);
                    }
                } else {
                    return function () { };
                }
            };
            
            Codec.prototype.keyAsBuffer = function (opts) {
                return this._keyEncoding(opts).buffer;
            };
            
            Codec.prototype.valueAsBuffer = function (opts) {
                return this._valueEncoding(opts).buffer;
            };


        }, { "./lib/encodings": 131 }], 131: [function (require, module, exports) {
            (function (Buffer) {
                
                exports.utf8 = exports['utf-8'] = {
                    encode: function (data) {
                        return isBinary(data)
      ? data
      : String(data);
                    },
                    decode: identity,
                    buffer: false,
                    type: 'utf8'
                };
                
                exports.json = {
                    encode: JSON.stringify,
                    decode: JSON.parse,
                    buffer: false,
                    type: 'json'
                };
                
                exports.binary = {
                    encode: function (data) {
                        return isBinary(data)
      ? data
      : new Buffer(data);
                    },
                    decode: identity,
                    buffer: true,
                    type: 'binary'
                };
                
                exports.id = {
                    encode: function (data) {
                        return data;
                    },
                    decode: function (data) {
                        return data;
                    },
                    buffer: false,
                    type: 'id'
                };
                
                var bufferEncodings = [
                    'hex',
                    'ascii',
                    'base64',
                    'ucs2',
                    'ucs-2',
                    'utf16le',
                    'utf-16le'
                ];
                
                bufferEncodings.forEach(function (type) {
                    exports[type] = {
                        encode: function (data) {
                            return isBinary(data)
        ? data
        : new Buffer(data, type);
                        },
                        decode: function (buffer) {
                            return buffer.toString(type);
                        },
                        buffer: true,
                        type: type
                    };
                });
                
                function identity(value) {
                    return value;
                }
                
                function isBinary(data) {
                    return data === undefined 
    || data === null 
    || Buffer.isBuffer(data);
                }


            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 132: [function (require, module, exports) {
            /* Copyright (c) 2012-2015 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>
 */

var createError = require('errno').create
  , LevelUPError = createError('LevelUPError')
  , NotFoundError = createError('NotFoundError', LevelUPError)
            
            NotFoundError.prototype.notFound = true
            NotFoundError.prototype.status = 404
            
            module.exports = {
                LevelUPError        : LevelUPError
                , InitializationError : createError('InitializationError', LevelUPError)
                , OpenError           : createError('OpenError', LevelUPError)
                , ReadError           : createError('ReadError', LevelUPError)
                , WriteError          : createError('WriteError', LevelUPError)
                , NotFoundError       : NotFoundError
                , EncodingError       : createError('EncodingError', LevelUPError)
            }

        }, { "errno": 134 }], 133: [function (require, module, exports) {
            var prr = require('prr')
            
            function init(type, message, cause) {
                prr(this, {
                    type    : type
                    , name    : type
                    // can be passed just a 'cause'
                    , cause   : typeof message != 'string' ? message : cause
                    , message : !!message && typeof message != 'string' ? message.message : message

                }, 'ewr')
            }
            
            // generic prototype, not intended to be actually used - helpful for `instanceof`
            function CustomError(message, cause) {
                Error.call(this)
                if (Error.captureStackTrace)
                    Error.captureStackTrace(this, arguments.callee)
                init.call(this, 'CustomError', message, cause)
            }
            
            CustomError.prototype = new Error()
            
            function createError(errno, type, proto) {
                var err = function (message, cause) {
                    init.call(this, type, message, cause)
                    //TODO: the specificity here is stupid, errno should be available everywhere
                    if (type == 'FilesystemError') {
                        this.code = this.cause.code
                        this.path = this.cause.path
                        this.errno = this.cause.errno
                        this.message =
        (errno.errno[this.cause.errno]
          ? errno.errno[this.cause.errno].description
          : this.cause.message) 
        + (this.cause.path ? ' [' + this.cause.path + ']' : '')
                    }
                    Error.call(this)
                    if (Error.captureStackTrace)
                        Error.captureStackTrace(this, arguments.callee)
                }
                err.prototype = !!proto ? new proto() : new CustomError()
                return err
            }
            
            module.exports = function (errno) {
                var ce = function (type, proto) {
                    return createError(errno, type, proto)
                }
                return {
                    CustomError     : CustomError
                    , FilesystemError : ce('FilesystemError')
                    , createError     : ce
                }
            }

        }, { "prr": 135 }], 134: [function (require, module, exports) {
            var all = module.exports.all = [
                {
                    errno: -1,
                    code: 'UNKNOWN',
                    description: 'unknown error'
                },
                {
                    errno: 0,
                    code: 'OK',
                    description: 'success'
                },
                {
                    errno: 1,
                    code: 'EOF',
                    description: 'end of file'
                },
                {
                    errno: 2,
                    code: 'EADDRINFO',
                    description: 'getaddrinfo error'
                },
                {
                    errno: 3,
                    code: 'EACCES',
                    description: 'permission denied'
                },
                {
                    errno: 4,
                    code: 'EAGAIN',
                    description: 'resource temporarily unavailable'
                },
                {
                    errno: 5,
                    code: 'EADDRINUSE',
                    description: 'address already in use'
                },
                {
                    errno: 6,
                    code: 'EADDRNOTAVAIL',
                    description: 'address not available'
                },
                {
                    errno: 7,
                    code: 'EAFNOSUPPORT',
                    description: 'address family not supported'
                },
                {
                    errno: 8,
                    code: 'EALREADY',
                    description: 'connection already in progress'
                },
                {
                    errno: 9,
                    code: 'EBADF',
                    description: 'bad file descriptor'
                },
                {
                    errno: 10,
                    code: 'EBUSY',
                    description: 'resource busy or locked'
                },
                {
                    errno: 11,
                    code: 'ECONNABORTED',
                    description: 'software caused connection abort'
                },
                {
                    errno: 12,
                    code: 'ECONNREFUSED',
                    description: 'connection refused'
                },
                {
                    errno: 13,
                    code: 'ECONNRESET',
                    description: 'connection reset by peer'
                },
                {
                    errno: 14,
                    code: 'EDESTADDRREQ',
                    description: 'destination address required'
                },
                {
                    errno: 15,
                    code: 'EFAULT',
                    description: 'bad address in system call argument'
                },
                {
                    errno: 16,
                    code: 'EHOSTUNREACH',
                    description: 'host is unreachable'
                },
                {
                    errno: 17,
                    code: 'EINTR',
                    description: 'interrupted system call'
                },
                {
                    errno: 18,
                    code: 'EINVAL',
                    description: 'invalid argument'
                },
                {
                    errno: 19,
                    code: 'EISCONN',
                    description: 'socket is already connected'
                },
                {
                    errno: 20,
                    code: 'EMFILE',
                    description: 'too many open files'
                },
                {
                    errno: 21,
                    code: 'EMSGSIZE',
                    description: 'message too long'
                },
                {
                    errno: 22,
                    code: 'ENETDOWN',
                    description: 'network is down'
                },
                {
                    errno: 23,
                    code: 'ENETUNREACH',
                    description: 'network is unreachable'
                },
                {
                    errno: 24,
                    code: 'ENFILE',
                    description: 'file table overflow'
                },
                {
                    errno: 25,
                    code: 'ENOBUFS',
                    description: 'no buffer space available'
                },
                {
                    errno: 26,
                    code: 'ENOMEM',
                    description: 'not enough memory'
                },
                {
                    errno: 27,
                    code: 'ENOTDIR',
                    description: 'not a directory'
                },
                {
                    errno: 28,
                    code: 'EISDIR',
                    description: 'illegal operation on a directory'
                },
                {
                    errno: 29,
                    code: 'ENONET',
                    description: 'machine is not on the network'
                },
                {
                    errno: 31,
                    code: 'ENOTCONN',
                    description: 'socket is not connected'
                },
                {
                    errno: 32,
                    code: 'ENOTSOCK',
                    description: 'socket operation on non-socket'
                },
                {
                    errno: 33,
                    code: 'ENOTSUP',
                    description: 'operation not supported on socket'
                },
                {
                    errno: 34,
                    code: 'ENOENT',
                    description: 'no such file or directory'
                },
                {
                    errno: 35,
                    code: 'ENOSYS',
                    description: 'function not implemented'
                },
                {
                    errno: 36,
                    code: 'EPIPE',
                    description: 'broken pipe'
                },
                {
                    errno: 37,
                    code: 'EPROTO',
                    description: 'protocol error'
                },
                {
                    errno: 38,
                    code: 'EPROTONOSUPPORT',
                    description: 'protocol not supported'
                },
                {
                    errno: 39,
                    code: 'EPROTOTYPE',
                    description: 'protocol wrong type for socket'
                },
                {
                    errno: 40,
                    code: 'ETIMEDOUT',
                    description: 'connection timed out'
                },
                {
                    errno: 41,
                    code: 'ECHARSET',
                    description: 'invalid Unicode character'
                },
                {
                    errno: 42,
                    code: 'EAIFAMNOSUPPORT',
                    description: 'address family for hostname not supported'
                },
                {
                    errno: 44,
                    code: 'EAISERVICE',
                    description: 'servname not supported for ai_socktype'
                },
                {
                    errno: 45,
                    code: 'EAISOCKTYPE',
                    description: 'ai_socktype not supported'
                },
                {
                    errno: 46,
                    code: 'ESHUTDOWN',
                    description: 'cannot send after transport endpoint shutdown'
                },
                {
                    errno: 47,
                    code: 'EEXIST',
                    description: 'file already exists'
                },
                {
                    errno: 48,
                    code: 'ESRCH',
                    description: 'no such process'
                },
                {
                    errno: 49,
                    code: 'ENAMETOOLONG',
                    description: 'name too long'
                },
                {
                    errno: 50,
                    code: 'EPERM',
                    description: 'operation not permitted'
                },
                {
                    errno: 51,
                    code: 'ELOOP',
                    description: 'too many symbolic links encountered'
                },
                {
                    errno: 52,
                    code: 'EXDEV',
                    description: 'cross-device link not permitted'
                },
                {
                    errno: 53,
                    code: 'ENOTEMPTY',
                    description: 'directory not empty'
                },
                {
                    errno: 54,
                    code: 'ENOSPC',
                    description: 'no space left on device'
                },
                {
                    errno: 55,
                    code: 'EIO',
                    description: 'i/o error'
                },
                {
                    errno: 56,
                    code: 'EROFS',
                    description: 'read-only file system'
                },
                {
                    errno: 57,
                    code: 'ENODEV',
                    description: 'no such device'
                },
                {
                    errno: 58,
                    code: 'ESPIPE',
                    description: 'invalid seek'
                },
                {
                    errno: 59,
                    code: 'ECANCELED',
                    description: 'operation canceled'
                }
            ]
            
            module.exports.errno = {}
            module.exports.code = {}
            
            all.forEach(function (error) {
                module.exports.errno[error.errno] = error
                module.exports.code[error.code] = error
            })
            
            module.exports.custom = require('./custom')(module.exports)
            module.exports.create = module.exports.custom.createError

        }, { "./custom": 133 }], 135: [function (require, module, exports) {
            /*!
  * prr
  * (c) 2013 Rod Vagg <rod@vagg.org>
  * https://github.com/rvagg/prr
  * License: MIT
  */

(function (name, context, definition) {
                if (typeof module != 'undefined' && module.exports)
                    module.exports = definition()
                else
                    context[name] = definition()
            })('prr', this, function () {
                
                var setProperty = typeof Object.defineProperty == 'function'
      ? function (obj, key, options) {
                    Object.defineProperty(obj, key, options)
                    return obj
                }
      : function (obj, key, options) { // < es5
                    obj[key] = options.value
                    return obj
                }

    , makeOptions = function (value, options) {
                        var oo = typeof options == 'object'
          , os = !oo && typeof options == 'string'
          , op = function (p) {
                                return oo
                ? !!options[p]
                : os
                  ? options.indexOf(p[0]) > -1
                  : false
                            }
                        
                        return {
                            enumerable   : op('enumerable')
                            , configurable : op('configurable')
                            , writable     : op('writable')
                            , value        : value
                        }
                    }

    , prr = function (obj, key, value, options) {
                        var k
                        
                        options = makeOptions(value, options)
                        
                        if (typeof key == 'object') {
                            for (k in key) {
                                if (Object.hasOwnProperty.call(key, k)) {
                                    options.value = key[k]
                                    setProperty(obj, k, options)
                                }
                            }
                            return obj
                        }
                        
                        return setProperty(obj, key, options)
                    }
                
                return prr
            })
        }, {}], 136: [function (require, module, exports) {
            var inherits = require('inherits');
            var Readable = require('readable-stream').Readable;
            var extend = require('xtend');
            var EncodingError = require('level-errors').EncodingError;
            
            module.exports = ReadStream;
            inherits(ReadStream, Readable);
            
            function ReadStream(iterator, options) {
                if (!(this instanceof ReadStream)) return new ReadStream(iterator, options);
                Readable.call(this, extend(options, {
                    objectMode: true
                }));
                this._iterator = iterator;
                this._destroyed = false;
                this._decoder = null;
                if (options && options.decoder) this._decoder = options.decoder;
                this.on('end', this._cleanup.bind(this));
            }
            
            ReadStream.prototype._read = function () {
                var self = this;
                if (this._destroyed) return;
                
                this._iterator.next(function (err, key, value) {
                    if (self._destroyed) return;
                    if (err) return self.emit('error', err);
                    if (key === undefined && value === undefined) {
                        self.push(null);
                    } else {
                        if (!self._decoder) return self.push({ key: key, value: value });
                        
                        try {
                            var value = self._decoder(key, value);
                        } catch (err) {
                            self.emit('error', new EncodingError(err));
                            self.push(null);
                            return;
                        }
                        self.push(value);
                    }
                });
            };
            
            ReadStream.prototype.destroy =
ReadStream.prototype._cleanup = function () {
                var self = this;
                if (this._destroyed) return;
                this._destroyed = true;
                
                this._iterator.end(function (err) {
                    if (err) return self.emit('error', err);
                    self.emit('close');
                });
            };


        }, { "inherits": 137, "level-errors": 132, "readable-stream": 146, "xtend": 148 }], 137: [function (require, module, exports) {
            arguments[4][102][0].apply(exports, arguments)
        }, { "dup": 102 }], 138: [function (require, module, exports) {
            arguments[4][96][0].apply(exports, arguments)
        }, { "./_stream_readable": 140, "./_stream_writable": 142, "_process": 322, "core-util-is": 143, "dup": 96, "inherits": 137 }], 139: [function (require, module, exports) {
            arguments[4][97][0].apply(exports, arguments)
        }, { "./_stream_transform": 141, "core-util-is": 143, "dup": 97, "inherits": 137 }], 140: [function (require, module, exports) {
            arguments[4][98][0].apply(exports, arguments)
        }, { "./_stream_duplex": 138, "_process": 322, "buffer": 172, "core-util-is": 143, "dup": 98, "events": 317, "inherits": 137, "isarray": 144, "stream": 338, "string_decoder/": 145, "util": 171 }], 141: [function (require, module, exports) {
            arguments[4][99][0].apply(exports, arguments)
        }, { "./_stream_duplex": 138, "core-util-is": 143, "dup": 99, "inherits": 137 }], 142: [function (require, module, exports) {
            arguments[4][100][0].apply(exports, arguments)
        }, { "./_stream_duplex": 138, "_process": 322, "buffer": 172, "core-util-is": 143, "dup": 100, "inherits": 137, "stream": 338 }], 143: [function (require, module, exports) {
            arguments[4][101][0].apply(exports, arguments)
        }, { "buffer": 172, "dup": 101 }], 144: [function (require, module, exports) {
            arguments[4][103][0].apply(exports, arguments)
        }, { "dup": 103 }], 145: [function (require, module, exports) {
            arguments[4][104][0].apply(exports, arguments)
        }, { "buffer": 172, "dup": 104 }], 146: [function (require, module, exports) {
            arguments[4][105][0].apply(exports, arguments)
        }, { "./lib/_stream_duplex.js": 138, "./lib/_stream_passthrough.js": 139, "./lib/_stream_readable.js": 140, "./lib/_stream_transform.js": 141, "./lib/_stream_writable.js": 142, "dup": 105, "stream": 338 }], 147: [function (require, module, exports) {
            arguments[4][135][0].apply(exports, arguments)
        }, { "dup": 135 }], 148: [function (require, module, exports) {
            arguments[4][64][0].apply(exports, arguments)
        }, { "dup": 64 }], 149: [function (require, module, exports) {
            module.exports = {
                "name": "levelup",
                "description": "Fast & simple storage - a Node.js-style LevelDB wrapper",
                "version": "1.2.1",
                "contributors": [
                    {
                        "name": "Rod Vagg",
                        "email": "r@va.gg",
                        "url": "https://github.com/rvagg"
                    },
                    {
                        "name": "John Chesley",
                        "email": "john@chesl.es",
                        "url": "https://github.com/chesles/"
                    },
                    {
                        "name": "Jake Verbaten",
                        "email": "raynos2@gmail.com",
                        "url": "https://github.com/raynos"
                    },
                    {
                        "name": "Dominic Tarr",
                        "email": "dominic.tarr@gmail.com",
                        "url": "https://github.com/dominictarr"
                    },
                    {
                        "name": "Max Ogden",
                        "email": "max@maxogden.com",
                        "url": "https://github.com/maxogden"
                    },
                    {
                        "name": "Lars-Magnus Skog",
                        "email": "ralphtheninja@riseup.net",
                        "url": "https://github.com/ralphtheninja"
                    },
                    {
                        "name": "David BjÃ¶rklund",
                        "email": "david.bjorklund@gmail.com",
                        "url": "https://github.com/kesla"
                    },
                    {
                        "name": "Julian Gruber",
                        "email": "julian@juliangruber.com",
                        "url": "https://github.com/juliangruber"
                    },
                    {
                        "name": "Paolo Fragomeni",
                        "email": "paolo@async.ly",
                        "url": "https://github.com/hij1nx"
                    },
                    {
                        "name": "Anton Whalley",
                        "email": "anton.whalley@nearform.com",
                        "url": "https://github.com/No9"
                    },
                    {
                        "name": "Matteo Collina",
                        "email": "matteo.collina@gmail.com",
                        "url": "https://github.com/mcollina"
                    },
                    {
                        "name": "Pedro Teixeira",
                        "email": "pedro.teixeira@gmail.com",
                        "url": "https://github.com/pgte"
                    },
                    {
                        "name": "James Halliday",
                        "email": "mail@substack.net",
                        "url": "https://github.com/substack"
                    },
                    {
                        "name": "Jarrett Cruger",
                        "email": "jcrugzz@gmail.com",
                        "url": "https://github.com/jcrugzz"
                    }
                ],
                "repository": {
                    "type": "git",
                    "url": "https://github.com/level/levelup.git"
                },
                "homepage": "https://github.com/level/levelup",
                "keywords": [
                    "leveldb",
                    "stream",
                    "database",
                    "db",
                    "store",
                    "storage",
                    "json"
                ],
                "main": "lib/levelup.js",
                "dependencies": {
                    "deferred-leveldown": "~1.0.0",
                    "level-codec": "~6.0.0",
                    "level-errors": "~1.0.3",
                    "level-iterator-stream": "~1.3.0",
                    "prr": "~1.0.1",
                    "semver": "~4.3.3",
                    "xtend": "~4.0.0"
                },
                "devDependencies": {
                    "async": "~0.9.0",
                    "bustermove": "~1.0.0",
                    "delayed": "~1.0.1",
                    "faucet": "~0.0.1",
                    "leveldown": "^1.1.0",
                    "memdown": "~1.0.0",
                    "msgpack-js": "~0.3.0",
                    "referee": "~1.1.1",
                    "rimraf": "~2.3.2",
                    "slow-stream": "0.0.4",
                    "tape": "~4.0.0"
                },
                "browser": {
                    "leveldown": false,
                    "leveldown/package": false,
                    "semver": false
                },
                "scripts": {
                    "test": "tape test/*-test.js | faucet"
                },
                "license": "MIT",
                "readme": "LevelUP\n=======\n\n<img alt=\"LevelDB Logo\" height=\"100\" src=\"http://leveldb.org/img/logo.svg\">\n\n**Fast & simple storage - a Node.js-style LevelDB wrapper**\n\n[![Build Status](https://secure.travis-ci.org/Level/levelup.png)](http://travis-ci.org/Level/levelup)\n\n[![NPM](https://nodei.co/npm/levelup.png?stars&downloads&downloadRank)](https://nodei.co/npm/levelup/) [![NPM](https://nodei.co/npm-dl/levelup.png?months=6&height=3)](https://nodei.co/npm/levelup/)\n\n\n  * <a href=\"#intro\">Introduction</a>\n  * <a href=\"#leveldown\">Relationship to LevelDOWN</a>\n  * <a href=\"#platforms\">Tested &amp; supported platforms</a>\n  * <a href=\"#basic\">Basic usage</a>\n  * <a href=\"#api\">API</a>\n  * <a href=\"#events\">Events</a>\n  * <a href=\"#json\">JSON data</a>\n  * <a href=\"#custom_encodings\">Custom encodings</a>\n  * <a href=\"#extending\">Extending LevelUP</a>\n  * <a href=\"#multiproc\">Multi-process access</a>\n  * <a href=\"#support\">Getting support</a>\n  * <a href=\"#contributing\">Contributing</a>\n  * <a href=\"#licence\">Licence &amp; copyright</a>\n\n<a name=\"intro\"></a>\nIntroduction\n------------\n\n**[LevelDB](https://github.com/google/leveldb)** is a simple key/value data store built by Google, inspired by BigTable. It's used in Google Chrome and many other products. LevelDB supports arbitrary byte arrays as both keys and values, singular *get*, *put* and *delete* operations, *batched put and delete*, bi-directional iterators and simple compression using the very fast [Snappy](http://code.google.com/p/snappy/) algorithm.\n\n**LevelUP** aims to expose the features of LevelDB in a **Node.js-friendly way**. All standard `Buffer` encoding types are supported, as is a special JSON encoding. LevelDB's iterators are exposed as a Node.js-style **readable stream**.\n\nLevelDB stores entries **sorted lexicographically by keys**. This makes LevelUP's <a href=\"#createReadStream\"><code>ReadStream</code></a> interface a very powerful query mechanism.\n\n**LevelUP** is an **OPEN Open Source Project**, see the <a href=\"#contributing\">Contributing</a> section to find out what this means.\n\n<a name=\"leveldown\"></a>\nRelationship to LevelDOWN\n-------------------------\n\nLevelUP is designed to be backed by **[LevelDOWN](https://github.com/level/leveldown/)** which provides a pure C++ binding to LevelDB and can be used as a stand-alone package if required.\n\n**As of version 0.9, LevelUP no longer requires LevelDOWN as a dependency so you must `npm install leveldown` when you install LevelUP.**\n\nLevelDOWN is now optional because LevelUP can be used with alternative backends, such as **[level.js](https://github.com/maxogden/level.js)** in the browser or [MemDOWN](https://github.com/level/memdown) for a pure in-memory store.\n\nLevelUP will look for LevelDOWN and throw an error if it can't find it in its Node `require()` path. It will also tell you if the installed version of LevelDOWN is incompatible.\n\n**The [level](https://github.com/level/level) package is available as an alternative installation mechanism.** Install it instead to automatically get both LevelUP & LevelDOWN. It exposes LevelUP on its export (i.e. you can `var leveldb = require('level')`).\n\n\n<a name=\"platforms\"></a>\nTested & supported platforms\n----------------------------\n\n  * **Linux**: including ARM platforms such as Raspberry Pi *and Kindle!*\n  * **Mac OS**\n  * **Solaris**: including Joyent's SmartOS & Nodejitsu\n  * **Windows**: Node 0.10 and above only. See installation instructions for *node-gyp's* dependencies [here](https://github.com/TooTallNate/node-gyp#installation), you'll need these (free) components from Microsoft to compile and run any native Node add-on in Windows.\n\n<a name=\"basic\"></a>\nBasic usage\n-----------\n\nFirst you need to install LevelUP!\n\n```sh\n$ npm install levelup leveldown\n```\n\nOr\n\n```sh\n$ npm install level\n```\n\n*(this second option requires you to use LevelUP by calling `var levelup = require('level')`)*\n\n\nAll operations are asynchronous although they don't necessarily require a callback if you don't need to know when the operation was performed.\n\n```js\nvar levelup = require('levelup')\n\n// 1) Create our database, supply location and options.\n//    This will create or open the underlying LevelDB store.\nvar db = levelup('./mydb')\n\n// 2) put a key & value\ndb.put('name', 'LevelUP', function (err) {\n  if (err) return console.log('Ooops!', err) // some kind of I/O error\n\n  // 3) fetch by key\n  db.get('name', function (err, value) {\n    if (err) return console.log('Ooops!', err) // likely the key was not found\n\n    // ta da!\n    console.log('name=' + value)\n  })\n})\n```\n\n<a name=\"api\"></a>\n## API\n\n  * <a href=\"#ctor\"><code><b>levelup()</b></code></a>\n  * <a href=\"#open\"><code>db.<b>open()</b></code></a>\n  * <a href=\"#close\"><code>db.<b>close()</b></code></a>\n  * <a href=\"#put\"><code>db.<b>put()</b></code></a>\n  * <a href=\"#get\"><code>db.<b>get()</b></code></a>\n  * <a href=\"#del\"><code>db.<b>del()</b></code></a>\n  * <a href=\"#batch\"><code>db.<b>batch()</b></code> *(array form)*</a>\n  * <a href=\"#batch_chained\"><code>db.<b>batch()</b></code> *(chained form)*</a>\n  * <a href=\"#isOpen\"><code>db.<b>isOpen()</b></code></a>\n  * <a href=\"#isClosed\"><code>db.<b>isClosed()</b></code></a>\n  * <a href=\"#createReadStream\"><code>db.<b>createReadStream()</b></code></a>\n  * <a href=\"#createKeyStream\"><code>db.<b>createKeyStream()</b></code></a>\n  * <a href=\"#createValueStream\"><code>db.<b>createValueStream()</b></code></a>\n\n### Special operations exposed by LevelDOWN\n\n  * <a href=\"#approximateSize\"><code>db.db.<b>approximateSize()</b></code></a>\n  * <a href=\"#getProperty\"><code>db.db.<b>getProperty()</b></code></a>\n  * <a href=\"#destroy\"><code><b>leveldown.destroy()</b></code></a>\n  * <a href=\"#repair\"><code><b>leveldown.repair()</b></code></a>\n\n### Special Notes\n  * <a href=\"#writeStreams\">What happened to <code><b>db.createWriteStream()</b></code></a>\n\n\n--------------------------------------------------------\n<a name=\"ctor\"></a>\n### levelup(location[, options[, callback]])\n### levelup(options[, callback ])\n### levelup(db[, callback ])\n<code>levelup()</code> is the main entry point for creating a new LevelUP instance and opening the underlying store with LevelDB.\n\nThis function returns a new instance of LevelUP and will also initiate an <a href=\"#open\"><code>open()</code></a> operation. Opening the database is an asynchronous operation which will trigger your callback if you provide one. The callback should take the form: `function (err, db) {}` where the `db` is the LevelUP instance. If you don't provide a callback, any read & write operations are simply queued internally until the database is fully opened.\n\nThis leads to two alternative ways of managing a new LevelUP instance:\n\n```js\nlevelup(location, options, function (err, db) {\n  if (err) throw err\n  db.get('foo', function (err, value) {\n    if (err) return console.log('foo does not exist')\n    console.log('got foo =', value)\n  })\n})\n\n// vs the equivalent:\n\nvar db = levelup(location, options) // will throw if an error occurs\ndb.get('foo', function (err, value) {\n  if (err) return console.log('foo does not exist')\n  console.log('got foo =', value)\n})\n```\n\nThe `location` argument is available as a read-only property on the returned LevelUP instance.\n\nThe `levelup(options, callback)` form (with optional `callback`) is only available where you provide a valid `'db'` property on the options object (see below). Only for back-ends that don't require a `location` argument, such as [MemDOWN](https://github.com/level/memdown).\n\nFor example:\n\n```js\nvar levelup = require('levelup')\nvar memdown = require('memdown')\nvar db = levelup({ db: memdown })\n```\n\nThe `levelup(db, callback)` form (with optional `callback`) is only available where `db` is a factory function, as would be provided as a `'db'` property on an `options` object (see below). Only for back-ends that don't require a `location` argument, such as [MemDOWN](https://github.com/level/memdown).\n\nFor example:\n\n```js\nvar levelup = require('levelup')\nvar memdown = require('memdown')\nvar db = levelup(memdown)\n```\n\n#### `options`\n\n`levelup()` takes an optional options object as its second argument; the following properties are accepted:\n\n* `'createIfMissing'` *(boolean, default: `true`)*: If `true`, will initialise an empty database at the specified location if one doesn't already exist. If `false` and a database doesn't exist you will receive an error in your `open()` callback and your database won't open.\n\n* `'errorIfExists'` *(boolean, default: `false`)*: If `true`, you will receive an error in your `open()` callback if the database exists at the specified location.\n\n* `'compression'` *(boolean, default: `true`)*: If `true`, all *compressible* data will be run through the Snappy compression algorithm before being stored. Snappy is very fast and shouldn't gain much speed by disabling so leave this on unless you have good reason to turn it off.\n\n* `'cacheSize'` *(number, default: `8 * 1024 * 1024`)*: The size (in bytes) of the in-memory [LRU](http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used) cache with frequently used uncompressed block contents.\n\n* `'keyEncoding'` and `'valueEncoding'` *(string, default: `'utf8'`)*: The encoding of the keys and values passed through Node.js' `Buffer` implementation (see [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end)).\n  <p><code>'utf8'</code> is the default encoding for both keys and values so you can simply pass in strings and expect strings from your <code>get()</code> operations. You can also pass <code>Buffer</code> objects as keys and/or values and conversion will be performed.</p>\n  <p>Supported encodings are: hex, utf8, ascii, binary, base64, ucs2, utf16le.</p>\n  <p><code>'json'</code> encoding is also supported, see below.</p>\n\n* `'db'` *(object, default: LevelDOWN)*: LevelUP is backed by [LevelDOWN](https://github.com/level/leveldown/) to provide an interface to LevelDB. You can completely replace the use of LevelDOWN by providing a \"factory\" function that will return a LevelDOWN API compatible object given a `location` argument. For further information, see [MemDOWN](https://github.com/level/memdown), a fully LevelDOWN API compatible replacement that uses a memory store rather than LevelDB. Also see [Abstract LevelDOWN](http://github.com/level/abstract-leveldown), a partial implementation of the LevelDOWN API that can be used as a base prototype for a LevelDOWN substitute.\n\nAdditionally, each of the main interface methods accept an optional options object that can be used to override `'keyEncoding'` and `'valueEncoding'`.\n\n--------------------------------------------------------\n<a name=\"open\"></a>\n### db.open([callback])\n<code>open()</code> opens the underlying LevelDB store. In general **you should never need to call this method directly** as it's automatically called by <a href=\"#ctor\"><code>levelup()</code></a>.\n\nHowever, it is possible to *reopen* a database after it has been closed with <a href=\"#close\"><code>close()</code></a>, although this is not generally advised.\n\n--------------------------------------------------------\n<a name=\"close\"></a>\n### db.close([callback])\n<code>close()</code> closes the underlying LevelDB store. The callback will receive any error encountered during closing as the first argument.\n\nYou should always clean up your LevelUP instance by calling `close()` when you no longer need it to free up resources. A LevelDB store cannot be opened by multiple instances of LevelDB/LevelUP simultaneously.\n\n--------------------------------------------------------\n<a name=\"put\"></a>\n### db.put(key, value[, options][, callback])\n<code>put()</code> is the primary method for inserting data into the store. Both the `key` and `value` can be arbitrary data objects.\n\nThe callback argument is optional but if you don't provide one and an error occurs then expect the error to be thrown.\n\n#### `options`\n\nEncoding of the `key` and `value` objects will adhere to `'keyEncoding'` and `'valueEncoding'` options provided to <a href=\"#ctor\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `put()` (it's recommended that you stay consistent in your encoding of keys and values in a single store).\n\nIf you provide a `'sync'` value of `true` in your `options` object, LevelDB will perform a synchronous write of the data; although the operation will be asynchronous as far as Node is concerned. Normally, LevelDB passes the data to the operating system for writing and returns immediately, however a synchronous write will use `fsync()` or equivalent so your callback won't be triggered until the data is actually on disk. Synchronous filesystem writes are **significantly** slower than asynchronous writes but if you want to be absolutely sure that the data is flushed then you can use `'sync': true`.\n\n--------------------------------------------------------\n<a name=\"get\"></a>\n### db.get(key[, options][, callback])\n<code>get()</code> is the primary method for fetching data from the store. The `key` can be an arbitrary data object. If it doesn't exist in the store then the callback will receive an error as its first argument. A not-found err object will be of type `'NotFoundError'` so you can `err.type == 'NotFoundError'` or you can perform a truthy test on the property `err.notFound`.\n\n```js\ndb.get('foo', function (err, value) {\n  if (err) {\n    if (err.notFound) {\n      // handle a 'NotFoundError' here\n      return\n    }\n    // I/O or other error, pass it up the callback chain\n    return callback(err)\n  }\n\n  // .. handle `value` here\n})\n```\n\n#### `options`\n\nEncoding of the `key` and `value` objects is the same as in <a href=\"#put\"><code>put</code></a>. \n\nLevelDB will by default fill the in-memory LRU Cache with data from a call to get. Disabling this is done by setting `fillCache` to `false`.\n\n--------------------------------------------------------\n<a name=\"del\"></a>\n### db.del(key[, options][, callback])\n<code>del()</code> is the primary method for removing data from the store.\n```js\ndb.del('foo', function (err) {\n  if (err)\n    // handle I/O or other error\n});\n```\n\n#### `options`\n\nEncoding of the `key` object will adhere to the `'keyEncoding'` option provided to <a href=\"#ctor\"><code>levelup()</code></a>, although you can provide alternative encoding settings in the options for `del()` (it's recommended that you stay consistent in your encoding of keys and values in a single store).\n\nA `'sync'` option can also be passed, see <a href=\"#put\"><code>put()</code></a> for details on how this works.\n\n--------------------------------------------------------\n<a name=\"batch\"></a>\n### db.batch(array[, options][, callback]) *(array form)*\n<code>batch()</code> can be used for very fast bulk-write operations (both *put* and *delete*). The `array` argument should contain a list of operations to be executed sequentially, although as a whole they are performed as an atomic operation inside LevelDB.\n\nEach operation is contained in an object having the following properties: `type`, `key`, `value`, where the *type* is either `'put'` or `'del'`. In the case of `'del'` the `'value'` property is ignored. Any entries with a `'key'` of `null` or `undefined` will cause an error to be returned on the `callback` and any `'type': 'put'` entry with a `'value'` of `null` or `undefined` will return an error.\n\nIf `key` and `value` are defined but `type` is not, it will default to `'put'`.\n\n```js\nvar ops = [\n    { type: 'del', key: 'father' }\n  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n  , { type: 'put', key: 'dob', value: '16 February 1941' }\n  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n  , { type: 'put', key: 'occupation', value: 'Clown' }\n]\n\ndb.batch(ops, function (err) {\n  if (err) return console.log('Ooops!', err)\n  console.log('Great success dear leader!')\n})\n```\n\n#### `options`\n\nSee <a href=\"#put\"><code>put()</code></a> for a discussion on the `options` object. You can overwrite default `'keyEncoding'` and `'valueEncoding'` and also specify the use of `sync` filesystem operations.\n\nIn addition to encoding options for the whole batch you can also overwrite the encoding per operation, like:\n\n```js\nvar ops = [{\n    type          : 'put'\n  , key           : new Buffer([1, 2, 3])\n  , value         : { some: 'json' }\n  , keyEncoding   : 'binary'\n  , valueEncoding : 'json'\n}]\n```\n\n--------------------------------------------------------\n<a name=\"batch_chained\"></a>\n### db.batch() *(chained form)*\n<code>batch()</code>, when called with no arguments will return a `Batch` object which can be used to build, and eventually commit, an atomic LevelDB batch operation. Depending on how it's used, it is possible to obtain greater performance when using the chained form of `batch()` over the array form.\n\n```js\ndb.batch()\n  .del('father')\n  .put('name', 'Yuri Irsenovich Kim')\n  .put('dob', '16 February 1941')\n  .put('spouse', 'Kim Young-sook')\n  .put('occupation', 'Clown')\n  .write(function () { console.log('Done!') })\n```\n\n<b><code>batch.put(key, value[, options])</code></b>\n\nQueue a *put* operation on the current batch, not committed until a `write()` is called on the batch.\n\nThe optional `options` argument can be used to override the default `'keyEncoding'` and/or `'valueEncoding'`.\n\nThis method may `throw` a `WriteError` if there is a problem with your put (such as the `value` being `null` or `undefined`).\n\n<b><code>batch.del(key[, options])</code></b>\n\nQueue a *del* operation on the current batch, not committed until a `write()` is called on the batch.\n\nThe optional `options` argument can be used to override the default `'keyEncoding'`.\n\nThis method may `throw` a `WriteError` if there is a problem with your delete.\n\n<b><code>batch.clear()</code></b>\n\nClear all queued operations on the current batch, any previous operations will be discarded.\n\n<b><code>batch.write([callback])</code></b>\n\nCommit the queued operations for this batch. All operations not *cleared* will be written to the database atomically, that is, they will either all succeed or fail with no partial commits. The optional `callback` will be called when the operation has completed with an *error* argument if an error has occurred; if no `callback` is supplied and an error occurs then this method will `throw` a `WriteError`.\n\n\n--------------------------------------------------------\n<a name=\"isOpen\"></a>\n### db.isOpen()\n\nA LevelUP object can be in one of the following states:\n\n  * *\"new\"*     - newly created, not opened or closed\n  * *\"opening\"* - waiting for the database to be opened\n  * *\"open\"*    - successfully opened the database, available for use\n  * *\"closing\"* - waiting for the database to be closed\n  * *\"closed\"*  - database has been successfully closed, should not be used\n\n`isOpen()` will return `true` only when the state is \"open\".\n\n--------------------------------------------------------\n<a name=\"isClosed\"></a>\n### db.isClosed()\n\n*See <a href=\"#put\"><code>isOpen()</code></a>*\n\n`isClosed()` will return `true` only when the state is \"closing\" *or* \"closed\", it can be useful for determining if read and write operations are permissible.\n\n--------------------------------------------------------\n<a name=\"createReadStream\"></a>\n### db.createReadStream([options])\n\nYou can obtain a **ReadStream** of the full database by calling the `createReadStream()` method. The resulting stream is a complete Node.js-style [Readable Stream](http://nodejs.org/docs/latest/api/stream.html#stream_readable_stream) where `'data'` events emit objects with `'key'` and `'value'` pairs. You can also use the `gt`, `lt` and `limit` options to control the range of keys that are streamed.\n\n```js\ndb.createReadStream()\n  .on('data', function (data) {\n    console.log(data.key, '=', data.value)\n  })\n  .on('error', function (err) {\n    console.log('Oh my!', err)\n  })\n  .on('close', function () {\n    console.log('Stream closed')\n  })\n  .on('end', function () {\n    console.log('Stream closed')\n  })\n```\n\nThe standard `pause()`, `resume()` and `destroy()` methods are implemented on the ReadStream, as is `pipe()` (see below). `'data'`, '`error'`, `'end'` and `'close'` events are emitted.\n\nAdditionally, you can supply an options object as the first parameter to `createReadStream()` with the following options:\n\n* `'gt'` (greater than), `'gte'` (greater than or equal) define the lower bound of the range to be streamed. Only records where the key is greater than (or equal to) this option will be included in the range. When `reverse=true` the order will be reversed, but the records streamed will be the same.\n\n* `'lt'` (less than), `'lte'` (less than or equal) define the higher bound of the range to be streamed. Only key/value pairs where the key is less than (or equal to) this option will be included in the range. When `reverse=true` the order will be reversed, but the records streamed will be the same.\n\n* `'start', 'end'` legacy ranges - instead use `'gte', 'lte'`\n\n* `'reverse'` *(boolean, default: `false`)*: a boolean, set true and the stream output will be reversed. Beware that due to the way LevelDB works, a reverse seek will be slower than a forward seek.\n\n* `'keys'` *(boolean, default: `true`)*: whether the `'data'` event should contain keys. If set to `true` and `'values'` set to `false` then `'data'` events will simply be keys, rather than objects with a `'key'` property. Used internally by the `createKeyStream()` method.\n\n* `'values'` *(boolean, default: `true`)*: whether the `'data'` event should contain values. If set to `true` and `'keys'` set to `false` then `'data'` events will simply be values, rather than objects with a `'value'` property. Used internally by the `createValueStream()` method.\n\n* `'limit'` *(number, default: `-1`)*: limit the number of results collected by this stream. This number represents a *maximum* number of results and may not be reached if you get to the end of the data first. A value of `-1` means there is no limit. When `reverse=true` the highest keys will be returned instead of the lowest keys.\n\n* `'fillCache'` *(boolean, default: `false`)*: wheather LevelDB's LRU-cache should be filled with data read.\n\n* `'keyEncoding'` / `'valueEncoding'` *(string)*: the encoding applied to each read piece of data.\n\n--------------------------------------------------------\n<a name=\"createKeyStream\"></a>\n### db.createKeyStream([options])\n\nA **KeyStream** is a **ReadStream** where the `'data'` events are simply the keys from the database so it can be used like a traditional stream rather than an object stream.\n\nYou can obtain a KeyStream either by calling the `createKeyStream()` method on a LevelUP object or by passing passing an options object to `createReadStream()` with `keys` set to `true` and `values` set to `false`.\n\n```js\ndb.createKeyStream()\n  .on('data', function (data) {\n    console.log('key=', data)\n  })\n\n// same as:\ndb.createReadStream({ keys: true, values: false })\n  .on('data', function (data) {\n    console.log('key=', data)\n  })\n```\n\n--------------------------------------------------------\n<a name=\"createValueStream\"></a>\n### db.createValueStream([options])\n\nA **ValueStream** is a **ReadStream** where the `'data'` events are simply the values from the database so it can be used like a traditional stream rather than an object stream.\n\nYou can obtain a ValueStream either by calling the `createValueStream()` method on a LevelUP object or by passing passing an options object to `createReadStream()` with `values` set to `true` and `keys` set to `false`.\n\n```js\ndb.createValueStream()\n  .on('data', function (data) {\n    console.log('value=', data)\n  })\n\n// same as:\ndb.createReadStream({ keys: false, values: true })\n  .on('data', function (data) {\n    console.log('value=', data)\n  })\n```\n\n--------------------------------------------------------\n<a name=\"writeStreams\"></a>\n#### What happened to `db.createWriteStream`?\n\n`db.createWriteStream()` has been removed in order to provide a smaller and more maintainable core. It primarily existed to create symmetry with `db.createReadStream()` but through much [discussion](https://github.com/level/levelup/issues/199), removing it was the best cause of action.\n\nThe main driver for this was performance. While `db.createReadStream()` performs well under most use cases, `db.createWriteStream()` was highly dependent on the application keys and values. Thus we can't provide a standard implementation and encourage more `write-stream` implementations to be created to solve the broad spectrum of use cases.\n\nCheck out the implementations that the community has already produced [here](https://github.com/level/levelup/wiki/Modules#write-streams).\n\n--------------------------------------------------------\n<a name='approximateSize'></a>\n### db.db.approximateSize(start, end, callback)\n<code>approximateSize()</code> can used to get the approximate number of bytes of file system space used by the range `[start..end)`. The result may not include recently written data.\n\n```js\nvar db = require('level')('./huge.db')\n\ndb.db.approximateSize('a', 'c', function (err, size) {\n  if (err) return console.error('Ooops!', err)\n  console.log('Approximate size of range is %d', size)\n})\n```\n\n**Note:** `approximateSize()` is available via [LevelDOWN](https://github.com/level/leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `'db'` option.\n\n\n--------------------------------------------------------\n<a name='getProperty'></a>\n### db.db.getProperty(property)\n<code>getProperty</code> can be used to get internal details from LevelDB. When issued with a valid property string, a readable string will be returned (this method is synchronous).\n\nCurrently, the only valid properties are:\n\n* <b><code>'leveldb.num-files-at-levelN'</code></b>: returns the number of files at level *N*, where N is an integer representing a valid level (e.g. \"0\").\n\n* <b><code>'leveldb.stats'</code></b>: returns a multi-line string describing statistics about LevelDB's internal operation.\n\n* <b><code>'leveldb.sstables'</code></b>: returns a multi-line string describing all of the *sstables* that make up contents of the current database.\n\n\n```js\nvar db = require('level')('./huge.db')\nconsole.log(db.db.getProperty('leveldb.num-files-at-level3'))\n// â†’ '243'\n```\n\n**Note:** `getProperty()` is available via [LevelDOWN](https://github.com/level/leveldown/), which by default is accessible as the `db` property of your LevelUP instance. This is a specific LevelDB operation and is not likely to be available where you replace LevelDOWN with an alternative back-end via the `'db'` option.\n\n\n--------------------------------------------------------\n<a name=\"destroy\"></a>\n### leveldown.destroy(location, callback)\n<code>destroy()</code> is used to completely remove an existing LevelDB database directory. You can use this function in place of a full directory *rm* if you want to be sure to only remove LevelDB-related files. If the directory only contains LevelDB files, the directory itself will be removed as well. If there are additional, non-LevelDB files in the directory, those files, and the directory, will be left alone.\n\nThe callback will be called when the destroy operation is complete, with a possible `error` argument.\n\n**Note:** `destroy()` is available via [LevelDOWN](https://github.com/level/leveldown/) which you will have to install seperately, e.g.:\n\n```js\nrequire('leveldown').destroy('./huge.db', function (err) { console.log('done!') })\n```\n\n--------------------------------------------------------\n<a name=\"repair\"></a>\n### leveldown.repair(location, callback)\n<code>repair()</code> can be used to attempt a restoration of a damaged LevelDB store. From the LevelDB documentation:\n\n> If a DB cannot be opened, you may attempt to call this method to resurrect as much of the contents of the database as possible. Some data may be lost, so be careful when calling this function on a database that contains important information.\n\nYou will find information on the *repair* operation in the *LOG* file inside the store directory.\n\nA `repair()` can also be used to perform a compaction of the LevelDB log into table files.\n\nThe callback will be called when the repair operation is complete, with a possible `error` argument.\n\n**Note:** `repair()` is available via [LevelDOWN](https://github.com/level/leveldown/) which you will have to install seperately, e.g.:\n\n```js\nrequire('leveldown').repair('./huge.db', function (err) { console.log('done!') })\n```\n\n--------------------------------------------------------\n\n<a name=\"events\"></a>\nEvents\n------\n\nLevelUP emits events when the callbacks to the corresponding methods are called.\n\n* `db.emit('put', key, value)` emitted when a new value is `'put'`\n* `db.emit('del', key)` emitted when a value is deleted\n* `db.emit('batch', ary)` emitted when a batch operation has executed\n* `db.emit('ready')` emitted when the database has opened (`'open'` is synonym)\n* `db.emit('closed')` emitted when the database has closed\n* `db.emit('opening')` emitted when the database is opening\n* `db.emit('closing')` emitted when the database is closing\n\nIf you do not pass a callback to an async function, and there is an error, LevelUP will `emit('error', err)` instead.\n\n<a name=\"json\"></a>\nJSON data\n---------\n\nYou specify `'json'` encoding for both keys and/or values, you can then supply JavaScript objects to LevelUP and receive them from all fetch operations, including ReadStreams. LevelUP will automatically *stringify* your objects and store them as *utf8* and parse the strings back into objects before passing them back to you.\n\n<a name=\"custom_encodings\"></a>\nCustom encodings\n----------------\n\nA custom encoding may be provided by passing in an object as an value for `keyEncoding` or `valueEncoding` (wherever accepted), it must have the following properties:\n\n```js\n{\n    encode : function (val) { ... }\n  , decode : function (val) { ... }\n  , buffer : boolean // encode returns a buffer and decode accepts a buffer\n  , type   : String  // name of this encoding type.\n}\n```\n\n<a name=\"extending\"></a>\nExtending LevelUP\n-----------------\n\nA list of <a href=\"https://github.com/level/levelup/wiki/Modules\"><b>Node.js LevelDB modules and projects</b></a> can be found in the wiki.\n\nWhen attempting to extend the functionality of LevelUP, it is recommended that you consider using [level-hooks](https://github.com/dominictarr/level-hooks) and/or [level-sublevel](https://github.com/dominictarr/level-sublevel). **level-sublevel** is particularly helpful for keeping additional, extension-specific, data in a LevelDB store. It allows you to partition a LevelUP instance into multiple sub-instances that each correspond to discrete namespaced key ranges.\n\n<a name=\"multiproc\"></a>\nMulti-process access\n--------------------\n\nLevelDB is thread-safe but is **not** suitable for accessing with multiple processes. You should only ever have a LevelDB database open from a single Node.js process. Node.js clusters are made up of multiple processes so a LevelUP instance cannot be shared between them either.\n\nSee the <a href=\"https://github.com/level/levelup/wiki/Modules\"><b>wiki</b></a> for some LevelUP extensions, including [multilevel](https://github.com/juliangruber/multilevel), that may help if you require a single data store to be shared across processes.\n\n<a name=\"support\"></a>\nGetting support\n---------------\n\nThere are multiple ways you can find help in using LevelDB in Node.js:\n\n * **IRC:** you'll find an active group of LevelUP users in the **##leveldb** channel on Freenode, including most of the contributors to this project.\n * **Mailing list:** there is an active [Node.js LevelDB](https://groups.google.com/forum/#!forum/node-levelup) Google Group.\n * **GitHub:** you're welcome to open an issue here on this GitHub repository if you have a question.\n\n<a name=\"contributing\"></a>\nContributing\n------------\n\nLevelUP is an **OPEN Open Source Project**. This means that:\n\n> Individuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.\n\nSee the [contribution guide](https://github.com/Level/community/blob/master/CONTRIBUTING.md) for more details.\n\n### Windows\n\nA large portion of the Windows support comes from code by [Krzysztof Kowalczyk](http://blog.kowalczyk.info/) [@kjk](https://twitter.com/kjk), see his Windows LevelDB port [here](http://code.google.com/r/kkowalczyk-leveldb/). If you're using LevelUP on Windows, you should give him your thanks!\n\n\n<a name=\"license\"></a>\nLicense &amp; copyright\n-------------------\n\nCopyright &copy; 2012-2015 **LevelUP** [contributors](https://github.com/level/community#contributors).\n\n**LevelUP** is licensed under the MIT license. All rights not explicitly granted in the MIT license are reserved. See the included `LICENSE.md` file for more details.\n\n=======\n*LevelUP builds on the excellent work of the LevelDB and Snappy teams from Google and additional contributors. LevelDB and Snappy are both issued under the [New BSD Licence](http://opensource.org/licenses/BSD-3-Clause).*\n",
                "readmeFilename": "README.md",
                "bugs": {
                    "url": "https://github.com/level/levelup/issues"
                },
                "_id": "levelup@1.2.1",
                "dist": {
                    "shasum": "e29fe79f187e9a33abfad859d21db2e450b03064"
                },
                "_from": "levelup@^1.2.1",
                "_resolved": "https://registry.npmjs.org/levelup/-/levelup-1.2.1.tgz"
            }

        }, {}], 150: [function (require, module, exports) {
            (function (process) {
                var path = require('path');
                var fs = require('fs');
                var _0777 = parseInt('0777', 8);
                
                module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
                
                function mkdirP(p, opts, f, made) {
                    if (typeof opts === 'function') {
                        f = opts;
                        opts = {};
                    }
                    else if (!opts || typeof opts !== 'object') {
                        opts = { mode: opts };
                    }
                    
                    var mode = opts.mode;
                    var xfs = opts.fs || fs;
                    
                    if (mode === undefined) {
                        mode = _0777 & (~process.umask());
                    }
                    if (!made) made = null;
                    
                    var cb = f || function () { };
                    p = path.resolve(p);
                    
                    xfs.mkdir(p, mode, function (er) {
                        if (!er) {
                            made = made || p;
                            return cb(null, made);
                        }
                        switch (er.code) {
                            case 'ENOENT':
                                mkdirP(path.dirname(p), opts, function (er, made) {
                                    if (er) cb(er, made);
                                    else mkdirP(p, opts, cb, made);
                                });
                                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
                            default:
                                xfs.stat(p, function (er2, stat) {
                                    // if the stat fails, then that's super weird.
                                    // let the original error be the failure reason.
                                    if (er2 || !stat.isDirectory()) cb(er, made)
                                    else cb(null, made);
                                });
                                break;
                        }
                    });
                }
                
                mkdirP.sync = function sync(p, opts, made) {
                    if (!opts || typeof opts !== 'object') {
                        opts = { mode: opts };
                    }
                    
                    var mode = opts.mode;
                    var xfs = opts.fs || fs;
                    
                    if (mode === undefined) {
                        mode = _0777 & (~process.umask());
                    }
                    if (!made) made = null;
                    
                    p = path.resolve(p);
                    
                    try {
                        xfs.mkdirSync(p, mode);
                        made = made || p;
                    }
    catch (err0) {
                        switch (err0.code) {
                            case 'ENOENT':
                                made = sync(path.dirname(p), opts, made);
                                sync(p, opts, made);
                                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
                            default:
                                var stat;
                                try {
                                    stat = xfs.statSync(p);
                                }
                catch (err1) {
                                    throw err0;
                                }
                                if (!stat.isDirectory()) throw err0;
                                break;
                        }
                    }
                    
                    return made;
                };

            }).call(this, require('_process'))
        }, { "_process": 322, "fs": 169, "path": 321 }], 151: [function (require, module, exports) {
            var util = require('util');
            var EventEmitter = require('events').EventEmitter;
            var WebSocket = require('ws');
            var SimplePeer = require('simple-peer');
            var randomstring = require('randomstring').generate;
            
            var Client = module.exports = function (uri, opts, cb) {
                var self = this;
                if (typeof uri === 'object') {
                    opts = uri;
                    uri = opts.uri;
                } else if (typeof opts === 'function') {
                    cb = opts;
                    opts = {};
                }
                
                if (!uri) throw new Error('must specify a URI');
                this.opts = opts;
                this.uri = uri;
                
                this.pendingPeers = {};
                
                this.handlers = new EventEmitter;
                this.handlers.once('init', function (data) {
                    self.id = data.id;
                    self.emit('initialized', data);
                });
                this.handlers.on('signal', this.onSignal.bind(this));
                
                if (cb) this.on('initialized', cb);
                this.conn = new WebSocket('ws://' + this.uri);
                this.conn.onopen = function () { self.emit('connect'); }
                this.conn.onmessage = this.onMessage.bind(this);
            };
            util.inherits(Client, EventEmitter);
            
            Client.prototype.disconnect = function () {
                this.conn.close();
                this.emit('disconnect');
            };
            
            Client.prototype.onMessage = function (e) {
                var data;
                try { data = JSON.parse(e.data); }
  catch (err) { return this.conn.close(); }
                if (!data.event) return this.conn.close();
                
                if (this.opts.debug || this.opts.verbose)
                    console.log('received "' + data.event + '" message');
                if (this.opts.debug)
                    console.log(e.data);
                
                this.handlers.emit(data.event, data);
            };
            
            Client.prototype.discover = function (n, cb) {
                var self = this;
                
                if (typeof n === 'function') {
                    cb = n;
                    n = 20;
                }
                
                var reqId;
                if (cb) {
                    reqId = randomstring(8);
                    this.handlers.once('peers:' + reqId, function (res) {
                        cb(null, res.peers);
                    });
                }
                this.conn.send(JSON.stringify({ event: 'peers', reqId: reqId, n: n }));
            };
            
            Client.prototype.accept = function (onConnect) {
                this.accepting = true;
                if (onConnect) this.on('incomingConnection', onConnect);
                this.conn.send(JSON.stringify({ event: 'announce' }));
            };
            
            Client.prototype.connect = function (peerId, cb) {
                var self = this;
                if (this.pendingPeers[peerId]) return;
                var peer = this.pendingPeers[peerId] = new SimplePeer({ initiator: true, wrtc: require('wrtc') });
                peer.on('signal', function (signalData) {
                    self.conn.send(JSON.stringify({ event: 'signal', to: peerId, signal: signalData }));
                });
                peer.on('connect', function () {
                    self.onPeerConnect(peerId);
                    if (cb) cb(null, peer);
                });
            };
            
            Client.prototype.onSignal = function (data) {
                var self = this;
                var peer = this.pendingPeers[data.from];
                if (!peer) {
                    if (!this.accepting) return;
                    
                    this.emit('signal', data);
                    
                    peer = this.pendingPeers[data.from] = new SimplePeer({ wrtc: require('wrtc') });
                    peer.on('signal', function (signalData) {
                        self.conn.send(JSON.stringify({
                            event: 'signal',
                            to: data.from,
                            signal: signalData
                        }));
                    });
                    peer.on('connect', function () {
                        self.onPeerConnect(data.from);
                        self.emit('incomingConnection', data.from, peer);
                    });
                }
                peer.signal(data.signal);
            };
            
            Client.prototype.onPeerConnect = function (peerId) {
                var peer = this.pendingPeers[peerId];
                delete this.pendingPeers[peerId];
                this.emit('connection', peerId, peer);
            };

        }, { "events": 317, "randomstring": 152, "simple-peer": 154, "util": 342, "wrtc": 167, "ws": 165 }], 152: [function (require, module, exports) {
            module.exports = require("./lib/randomstring");
        }, { "./lib/randomstring": 153 }], 153: [function (require, module, exports) {
            "use strict";
            
            var charsNumbers = '0123456789';
            var charsLower = 'abcdefghijklmnopqrstuvwxyz';
            var charsUpper = charsLower.toUpperCase();
            
            var chars = charsNumbers + charsLower + charsUpper;
            
            exports.generate = function (length) {
                
                if (!length) length = 32;
                
                var string = '';
                
                for (var i = 0; i < length; i++) {
                    var randomNumber = Math.floor(Math.random() * chars.length);
                    string += chars.substring(randomNumber, randomNumber + 1);
                }
                
                return string;
            }

        }, {}], 154: [function (require, module, exports) {
            (function (Buffer) {
                /* global Blob */
                
                module.exports = Peer
                
                var debug = require('debug')('simple-peer')
                var getBrowserRTC = require('get-browser-rtc')
                var hat = require('hat')
                var inherits = require('inherits')
                var isTypedArray = require('is-typedarray')
                var once = require('once')
                var stream = require('stream')
                var toBuffer = require('typedarray-to-buffer')
                
                inherits(Peer, stream.Duplex)
                
                /**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
function Peer(opts) {
                    var self = this
                    if (!(self instanceof Peer)) return new Peer(opts)
                    self._debug('new peer %o', opts)
                    
                    if (!opts) opts = {}
                    opts.allowHalfOpen = false
                    if (opts.highWaterMark == null) opts.highWaterMark = 1024 * 1024
                    
                    stream.Duplex.call(self, opts)
                    
                    self.initiator = opts.initiator || false
                    self.channelConfig = opts.channelConfig || Peer.channelConfig
                    self.channelName = opts.channelName || hat(160)
                    if (!opts.initiator) self.channelName = null
                    self.config = opts.config || Peer.config
                    self.constraints = opts.constraints || Peer.constraints
                    self.reconnectTimer = opts.reconnectTimer || 0
                    self.sdpTransform = opts.sdpTransform || function (sdp) { return sdp }
                    self.stream = opts.stream || false
                    self.trickle = opts.trickle !== undefined ? opts.trickle : true
                    
                    self.destroyed = false
                    self.connected = false
                    
                    // so Peer object always has same shape (V8 optimization)
                    self.remoteAddress = undefined
                    self.remoteFamily = undefined
                    self.remotePort = undefined
                    self.localAddress = undefined
                    self.localPort = undefined
                    
                    self._wrtc = opts.wrtc || getBrowserRTC()
                    if (!self._wrtc) {
                        if (typeof window === 'undefined') {
                            throw new Error('No WebRTC support: Specify `opts.wrtc` option in this environment')
                        } else {
                            throw new Error('No WebRTC support: Not a supported browser')
                        }
                    }
                    
                    self._maxBufferedAmount = opts.highWaterMark
                    self._pcReady = false
                    self._channelReady = false
                    self._iceComplete = false // ice candidate trickle done (got null candidate)
                    self._channel = null
                    
                    self._chunk = null
                    self._cb = null
                    self._interval = null
                    self._reconnectTimeout = null
                    
                    self._pc = new (self._wrtc.RTCPeerConnection)(self.config, self.constraints)
                    self._pc.oniceconnectionstatechange = self._onIceConnectionStateChange.bind(self)
                    self._pc.onsignalingstatechange = self._onSignalingStateChange.bind(self)
                    self._pc.onicecandidate = self._onIceCandidate.bind(self)
                    
                    if (self.stream) self._pc.addStream(self.stream)
                    self._pc.onaddstream = self._onAddStream.bind(self)
                    
                    if (self.initiator) {
                        self._setupData({ channel: self._pc.createDataChannel(self.channelName, self.channelConfig) })
                        self._pc.onnegotiationneeded = once(self._createOffer.bind(self))
                        // Only Chrome triggers "negotiationneeded"; this is a workaround for other
                        // implementations
                        if (typeof window === 'undefined' || !window.webkitRTCPeerConnection) {
                            self._pc.onnegotiationneeded()
                        }
                    } else {
                        self._pc.ondatachannel = self._setupData.bind(self)
                    }
                    
                    self.on('finish', function () {
                        if (self.connected) {
                            // When local peer is finished writing, close connection to remote peer.
                            // Half open connections are currently not supported.
                            // Wait a bit before destroying so the datachannel flushes.
                            // TODO: is there a more reliable way to accomplish this?
                            setTimeout(function () {
                                self._destroy()
                            }, 100)
                        } else {
                            // If data channel is not connected when local peer is finished writing, wait until
                            // data is flushed to network at "connect" event.
                            // TODO: is there a more reliable way to accomplish this?
                            self.once('connect', function () {
                                setTimeout(function () {
                                    self._destroy()
                                }, 100)
                            })
                        }
                    })
                }
                
                Peer.WEBRTC_SUPPORT = !!getBrowserRTC()
                
                /**
 * Expose config, constraints, and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config, opts.constraints, or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
                    iceServers: [
                        {
                            url: 'stun:23.21.150.121', // deprecated, replaced by `urls`
                            urls: 'stun:23.21.150.121'
                        }
                    ]
                }
                Peer.constraints = {}
                Peer.channelConfig = {}
                
                Object.defineProperty(Peer.prototype, 'bufferSize', {
                    get: function () {
                        var self = this
                        return (self._channel && self._channel.bufferedAmount) || 0
                    }
                })
                
                Peer.prototype.address = function () {
                    var self = this
                    return { port: self.localPort, family: 'IPv4', address: self.localAddress }
                }
                
                Peer.prototype.signal = function (data) {
                    var self = this
                    //if (self.destroyed) throw new Error('cannot signal after peer is destroyed')
                    if (self.destroyed) console.log('cannot signal after peer is destroyed')
                    if (typeof data === 'string') {
                        try {
                            data = JSON.parse(data)
                        } catch (err) {
                            data = {}
                        }
                    }
                    self._debug('signal()')
                    if (data.sdp) {
                        self._pc.setRemoteDescription(new (self._wrtc.RTCSessionDescription)(data), function () {
                            if (self.destroyed) return
                            if (self._pc.remoteDescription.type === 'offer') self._createAnswer()
                        }, self._onError.bind(self))
                    }
                    if (data.candidate) {
                        try {
                            self._pc.addIceCandidate(
                                new (self._wrtc.RTCIceCandidate)(data.candidate), noop, self._onError.bind(self)
                            )
                        } catch (err) {
                            self._destroy(new Error('error adding candidate: ' + err.message))
                        }
                    }
                    if (!data.sdp && !data.candidate) {
                        self._destroy(new Error('signal() called with invalid signal data'))
                    }
                }
                
                /**
 * Send text/binary data to the remote peer.
 * @param {TypedArrayView|ArrayBuffer|Buffer|string|Blob|Object} chunk
 */
Peer.prototype.send = function (chunk) {
                    var self = this
                    
                    if (!isTypedArray.strict(chunk) && !(chunk instanceof ArrayBuffer) &&
    !Buffer.isBuffer(chunk) && typeof chunk !== 'string' &&
    (typeof Blob === 'undefined' || !(chunk instanceof Blob))) {
                        chunk = JSON.stringify(chunk)
                    }
                    
                    // `wrtc` module doesn't accept node.js buffer
                    if (Buffer.isBuffer(chunk) && !isTypedArray.strict(chunk)) {
                        chunk = new Uint8Array(chunk)
                    }
                    
                    var len = chunk.length || chunk.byteLength || chunk.size
                    self._channel.send(chunk)
                    self._debug('write: %d bytes', len)
                }
                
                Peer.prototype.destroy = function (onclose) {
                    var self = this
                    self._destroy(null, onclose)
                }
                
                Peer.prototype._destroy = function (err, onclose) {
                    var self = this
                    if (self.destroyed) return
                    if (onclose) self.once('close', onclose)
                    
                    self._debug('destroy (error: %s)', err && err.message)
                    
                    self.readable = self.writable = false
                    
                    if (!self._readableState.ended) self.push(null)
                    if (!self._writableState.finished) self.end()
                    
                    self.destroyed = true
                    self.connected = false
                    self._pcReady = false
                    self._channelReady = false
                    
                    self._chunk = null
                    self._cb = null
                    clearInterval(self._interval)
                    clearTimeout(self._reconnectTimeout)
                    
                    if (self._pc) {
                        try {
                            self._pc.close()
                        } catch (err) { }
                        
                        self._pc.oniceconnectionstatechange = null
                        self._pc.onsignalingstatechange = null
                        self._pc.onicecandidate = null
                    }
                    
                    if (self._channel) {
                        try {
                            self._channel.close()
                        } catch (err) { }
                        
                        self._channel.onmessage = null
                        self._channel.onopen = null
                        self._channel.onclose = null
                    }
                    self._pc = null
                    self._channel = null
                    
                    if (err) self.emit('error', err)
                    self.emit('close')
                }
                
                Peer.prototype._setupData = function (event) {
                    var self = this
                    self._channel = event.channel
                    self.channelName = self._channel.label
                    
                    self._channel.binaryType = 'arraybuffer'
                    self._channel.onmessage = self._onChannelMessage.bind(self)
                    self._channel.onopen = self._onChannelOpen.bind(self)
                    self._channel.onclose = self._onChannelClose.bind(self)
                }
                
                Peer.prototype._read = function () { }
                
                Peer.prototype._write = function (chunk, encoding, cb) {
                    var self = this
                    if (self.destroyed) return cb(new Error('cannot write after peer is destroyed'))
                    
                    if (self.connected) {
                        self.send(chunk)
                        if (self._channel.bufferedAmount > self._maxBufferedAmount) {
                            self._debug('start backpressure: bufferedAmount %d', self._channel.bufferedAmount)
                            self._cb = cb
                        } else {
                            cb(null)
                        }
                    } else {
                        self._debug('write before connect')
                        self._chunk = chunk
                        self._cb = cb
                    }
                }
                
                Peer.prototype._createOffer = function () {
                    var self = this
                    if (self.destroyed) return
                    
                    self._pc.createOffer(function (offer) {
                        if (self.destroyed) return
                        offer.sdp = self.sdpTransform(offer.sdp)
                        self._pc.setLocalDescription(offer, noop, self._onError.bind(self))
                        var sendOffer = function () {
                            var signal = self._pc.localDescription || offer
                            self._debug('signal')
                            self.emit('signal', {
                                type: signal.type,
                                sdp: signal.sdp
                            })
                        }
                        if (self.trickle || self._iceComplete) sendOffer()
                        else self.once('_iceComplete', sendOffer) // wait for candidates
                    }, self._onError.bind(self), self.offerConstraints)
                }
                
                Peer.prototype._createAnswer = function () {
                    var self = this
                    if (self.destroyed) return
                    
                    self._pc.createAnswer(function (answer) {
                        if (self.destroyed) return
                        answer.sdp = self.sdpTransform(answer.sdp)
                        self._pc.setLocalDescription(answer, noop, self._onError.bind(self))
                        var sendAnswer = function () {
                            var signal = self._pc.localDescription || answer
                            self._debug('signal')
                            self.emit('signal', {
                                type: signal.type,
                                sdp: signal.sdp
                            })
                        }
                        if (self.trickle || self._iceComplete) sendAnswer()
                        else self.once('_iceComplete', sendAnswer)
                    }, self._onError.bind(self), self.answerConstraints)
                }
                
                Peer.prototype._onIceConnectionStateChange = function () {
                    var self = this
                    if (self.destroyed) return
                    var iceGatheringState = self._pc.iceGatheringState
                    var iceConnectionState = self._pc.iceConnectionState
                    self._debug('iceConnectionStateChange %s %s', iceGatheringState, iceConnectionState)
                    self.emit('iceConnectionStateChange', iceGatheringState, iceConnectionState)
                    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
                        clearTimeout(self._reconnectTimeout)
                        self._pcReady = true
                        self._maybeReady()
                    }
                    if (iceConnectionState === 'disconnected') {
                        if (self.reconnectTimer) {
                            // If user has set `opt.reconnectTimer`, allow time for ICE to attempt a reconnect
                            clearTimeout(self._reconnectTimeout)
                            self._reconnectTimeout = setTimeout(function () {
                                self._destroy()
                            }, self.reconnectTimer)
                        } else {
                            self._destroy()
                        }
                    }
                    if (iceConnectionState === 'closed') {
                        self._destroy()
                    }
                }
                
                Peer.prototype._maybeReady = function () {
                    var self = this
                    self._debug('maybeReady pc %s channel %s', self._pcReady, self._channelReady)
                    if (self.connected || self._connecting || !self._pcReady || !self._channelReady) return
                    self._connecting = true
                    
                    if (typeof window !== 'undefined' && !!window.mozRTCPeerConnection) {
                        self._pc.getStats(null, function (res) {
                            var items = []
                            res.forEach(function (item) {
                                items.push(item)
                            })
                            onStats(items)
                        }, self._onError.bind(self))
                    } else {
                        self._pc.getStats(function (res) {
                            var items = []
                            res.result().forEach(function (result) {
                                var item = {}
                                result.names().forEach(function (name) {
                                    item[name] = result.stat(name)
                                })
                                item.id = result.id
                                item.type = result.type
                                item.timestamp = result.timestamp
                                items.push(item)
                            })
                            onStats(items)
                        })
                    }
                    
                    function onStats(items) {
                        items.forEach(function (item) {
                            if (item.type === 'remotecandidate') {
                                self.remoteAddress = item.ipAddress
                                self.remoteFamily = 'IPv4'
                                self.remotePort = Number(item.portNumber)
                                self._debug(
                                    'connect remote: %s:%s (%s)',
          self.remoteAddress, self.remotePort, self.remoteFamily
                                )
                            } else if (item.type === 'localcandidate' && item.candidateType === 'host') {
                                self.localAddress = item.ipAddress
                                self.localPort = Number(item.portNumber)
                                self._debug('connect local: %s:%s', self.localAddress, self.localPort)
                            }
                        })
                        
                        self._connecting = false
                        self.connected = true
                        
                        if (self._chunk) {
                            self.send(self._chunk)
                            self._chunk = null
                            self._debug('sent chunk from "write before connect"')
                            
                            var cb = self._cb
                            self._cb = null
                            cb(null)
                        }
                        
                        self._interval = setInterval(function () {
                            if (!self._cb || !self._channel || self._channel.bufferedAmount > self._maxBufferedAmount) return
                            self._debug('ending backpressure: bufferedAmount %d', self._channel.bufferedAmount)
                            var cb = self._cb
                            self._cb = null
                            cb(null)
                        }, 150)
                        if (self._interval.unref) self._interval.unref()
                        
                        self._debug('connect')
                        self.emit('connect')
                    }
                }
                
                Peer.prototype._onSignalingStateChange = function () {
                    var self = this
                    if (self.destroyed) return
                    self._debug('signalingStateChange %s', self._pc.signalingState)
                    self.emit('signalingStateChange', self._pc.signalingState)
                }
                
                Peer.prototype._onIceCandidate = function (event) {
                    var self = this
                    if (self.destroyed) return
                    if (event.candidate && self.trickle) {
                        self.emit('signal', {
                            candidate: {
                                candidate: event.candidate.candidate,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                sdpMid: event.candidate.sdpMid
                            }
                        })
                    } else if (!event.candidate) {
                        self._iceComplete = true
                        self.emit('_iceComplete')
                    }
                }
                
                Peer.prototype._onChannelMessage = function (event) {
                    var self = this
                    if (self.destroyed) return
                    var data = event.data
                    self._debug('read: %d bytes', data.byteLength || data.length)
                    
                    if (data instanceof ArrayBuffer) {
                        data = toBuffer(new Uint8Array(data))
                        self.push(data)
                    } else {
                        try {
                            data = JSON.parse(data)
                        } catch (err) { }
                        self.emit('data', data)
                    }
                }
                
                Peer.prototype._onChannelOpen = function () {
                    var self = this
                    if (self.connected || self.destroyed) return
                    self._debug('on channel open')
                    self._channelReady = true
                    self._maybeReady()
                }
                
                Peer.prototype._onChannelClose = function () {
                    var self = this
                    if (self.destroyed) return
                    self._debug('on channel close')
                    self._destroy()
                }
                
                Peer.prototype._onAddStream = function (event) {
                    var self = this
                    if (self.destroyed) return
                    self._debug('on add stream')
                    self.emit('stream', event.stream)
                }
                
                Peer.prototype._onError = function (err) {
                    var self = this
                    if (self.destroyed) return
                    self._debug('error %s', err.message || err)
                    self._destroy(err)
                }
                
                Peer.prototype._debug = function () {
                    var self = this
                    var args = [].slice.call(arguments)
                    var id = self.channelName && self.channelName.substring(0, 7)
                    args[0] = '[' + id + '] ' + args[0]
                    debug.apply(null, args)
                }
                
                function noop() { }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172, "debug": 155, "get-browser-rtc": 158, "hat": 159, "inherits": 160, "is-typedarray": 161, "once": 163, "stream": 338, "typedarray-to-buffer": 164 }], 155: [function (require, module, exports) {
            
            /**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
            exports.log = log;
            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.storage = 'undefined' != typeof chrome 
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();
            
            /**
 * Colors.
 */

exports.colors = [
                'lightseagreen',
                'forestgreen',
                'goldenrod',
                'dodgerblue',
                'darkorchid',
                'crimson'
            ];
            
            /**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
                // is webkit? http://stackoverflow.com/a/16459606/376773
                return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
            }
            
            /**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
                return JSON.stringify(v);
            };
            
            
            /**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
                var args = arguments;
                var useColors = this.useColors;
                
                args[0] = (useColors ? '%c' : '') 
    + this.namespace 
    + (useColors ? ' %c' : ' ') 
    + args[0] 
    + (useColors ? '%c ' : ' ') 
    + '+' + exports.humanize(this.diff);
                
                if (!useColors) return args;
                
                var c = 'color: ' + this.color;
                args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
                
                // the final "%c" is somewhat tricky, because there could be other
                // arguments passed either before or after the %c, so we need to
                // figure out the correct index to insert the CSS into
                var index = 0;
                var lastC = 0;
                args[0].replace(/%[a-z%]/g, function (match) {
                    if ('%%' === match) return;
                    index++;
                    if ('%c' === match) {
                        // we only are interested in the *last* %c
                        // (the user may have provided their own)
                        lastC = index;
                    }
                });
                
                args.splice(lastC, 0, c);
                return args;
            }
            
            /**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
                // this hackery is required for IE8/9, where
                // the `console.log` function doesn't have 'apply'
                return 'object' === typeof console 
    && console.log 
    && Function.prototype.apply.call(console.log, console, arguments);
            }
            
            /**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
                try {
                    if (null == namespaces) {
                        exports.storage.removeItem('debug');
                    } else {
                        exports.storage.debug = namespaces;
                    }
                } catch (e) { }
            }
            
            /**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
                var r;
                try {
                    r = exports.storage.debug;
                } catch (e) { }
                return r;
            }
            
            /**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());
            
            /**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
                try {
                    return window.localStorage;
                } catch (e) { }
            }

        }, { "./debug": 156 }], 156: [function (require, module, exports) {
            
            /**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
            exports.coerce = coerce;
            exports.disable = disable;
            exports.enable = enable;
            exports.enabled = enabled;
            exports.humanize = require('ms');
            
            /**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
            exports.skips = [];
            
            /**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};
            
            /**
 * Previously assigned color.
 */

var prevColor = 0;
            
            /**
 * Previous log timestamp.
 */

var prevTime;
            
            /**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
                return exports.colors[prevColor++ % exports.colors.length];
            }
            
            /**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {
                
                // define the `disabled` version
                function disabled() {
                }
                disabled.enabled = false;
                
                // define the `enabled` version
                function enabled() {
                    
                    var self = enabled;
                    
                    // set `diff` timestamp
                    var curr = +new Date();
                    var ms = curr - (prevTime || curr);
                    self.diff = ms;
                    self.prev = prevTime;
                    self.curr = curr;
                    prevTime = curr;
                    
                    // add the `color` if not set
                    if (null == self.useColors) self.useColors = exports.useColors();
                    if (null == self.color && self.useColors) self.color = selectColor();
                    
                    var args = Array.prototype.slice.call(arguments);
                    
                    args[0] = exports.coerce(args[0]);
                    
                    if ('string' !== typeof args[0]) {
                        // anything else let's inspect with %o
                        args = ['%o'].concat(args);
                    }
                    
                    // apply any `formatters` transformations
                    var index = 0;
                    args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
                        // if we encounter an escaped % then don't increase the array index
                        if (match === '%%') return match;
                        index++;
                        var formatter = exports.formatters[format];
                        if ('function' === typeof formatter) {
                            var val = args[index];
                            match = formatter.call(self, val);
                            
                            // now we need to remove `args[index]` since it's inlined in the `format`
                            args.splice(index, 1);
                            index--;
                        }
                        return match;
                    });
                    
                    if ('function' === typeof exports.formatArgs) {
                        args = exports.formatArgs.apply(self, args);
                    }
                    var logFn = enabled.log || exports.log || console.log.bind(console);
                    logFn.apply(self, args);
                }
                enabled.enabled = true;
                
                var fn = exports.enabled(namespace) ? enabled : disabled;
                
                fn.namespace = namespace;
                
                return fn;
            }
            
            /**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
                exports.save(namespaces);
                
                var split = (namespaces || '').split(/[\s,]+/);
                var len = split.length;
                
                for (var i = 0; i < len; i++) {
                    if (!split[i]) continue; // ignore empty strings
                    namespaces = split[i].replace(/\*/g, '.*?');
                    if (namespaces[0] === '-') {
                        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
                    } else {
                        exports.names.push(new RegExp('^' + namespaces + '$'));
                    }
                }
            }
            
            /**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
                exports.enable('');
            }
            
            /**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
                var i, len;
                for (i = 0, len = exports.skips.length; i < len; i++) {
                    if (exports.skips[i].test(name)) {
                        return false;
                    }
                }
                for (i = 0, len = exports.names.length; i < len; i++) {
                    if (exports.names[i].test(name)) {
                        return true;
                    }
                }
                return false;
            }
            
            /**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
                if (val instanceof Error) return val.stack || val.message;
                return val;
            }

        }, { "ms": 157 }], 157: [function (require, module, exports) {
            /**
 * Helpers.
 */

var s = 1000;
            var m = s * 60;
            var h = m * 60;
            var d = h * 24;
            var y = d * 365.25;
            
            /**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
                options = options || {};
                if ('string' == typeof val) return parse(val);
                return options.long
    ? long(val)
    : short(val);
            };
            
            /**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
                str = '' + str;
                if (str.length > 10000) return;
                var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
                if (!match) return;
                var n = parseFloat(match[1]);
                var type = (match[2] || 'ms').toLowerCase();
                switch (type) {
                    case 'years':
                    case 'year':
                    case 'yrs':
                    case 'yr':
                    case 'y':
                        return n * y;
                    case 'days':
                    case 'day':
                    case 'd':
                        return n * d;
                    case 'hours':
                    case 'hour':
                    case 'hrs':
                    case 'hr':
                    case 'h':
                        return n * h;
                    case 'minutes':
                    case 'minute':
                    case 'mins':
                    case 'min':
                    case 'm':
                        return n * m;
                    case 'seconds':
                    case 'second':
                    case 'secs':
                    case 'sec':
                    case 's':
                        return n * s;
                    case 'milliseconds':
                    case 'millisecond':
                    case 'msecs':
                    case 'msec':
                    case 'ms':
                        return n;
                }
            }
            
            /**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
                if (ms >= d) return Math.round(ms / d) + 'd';
                if (ms >= h) return Math.round(ms / h) + 'h';
                if (ms >= m) return Math.round(ms / m) + 'm';
                if (ms >= s) return Math.round(ms / s) + 's';
                return ms + 'ms';
            }
            
            /**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
                return plural(ms, d, 'day') 
    || plural(ms, h, 'hour') 
    || plural(ms, m, 'minute') 
    || plural(ms, s, 'second') 
    || ms + ' ms';
            }
            
            /**
 * Pluralization helper.
 */

function plural(ms, n, name) {
                if (ms < n) return;
                if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
                return Math.ceil(ms / n) + ' ' + name + 's';
            }

        }, {}], 158: [function (require, module, exports) {
            // originally pulled out of simple-peer
            
            module.exports = function getBrowserRTC() {
                if (typeof window === 'undefined') return null
                var wrtc = {
                    RTCPeerConnection: window.mozRTCPeerConnection || window.RTCPeerConnection ||
      window.webkitRTCPeerConnection,
                    RTCSessionDescription: window.mozRTCSessionDescription ||
      window.RTCSessionDescription || window.webkitRTCSessionDescription,
                    RTCIceCandidate: window.mozRTCIceCandidate || window.RTCIceCandidate ||
      window.webkitRTCIceCandidate
                }
                if (!wrtc.RTCPeerConnection) return null
                return wrtc
            }

        }, {}], 159: [function (require, module, exports) {
            var hat = module.exports = function (bits, base) {
                if (!base) base = 16;
                if (bits === undefined) bits = 128;
                if (bits <= 0) return '0';
                
                var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
                for (var i = 2; digits === Infinity; i *= 2) {
                    digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
                }
                
                var rem = digits - Math.floor(digits);
                
                var res = '';
                
                for (var i = 0; i < Math.floor(digits); i++) {
                    var x = Math.floor(Math.random() * base).toString(base);
                    res = x + res;
                }
                
                if (rem) {
                    var b = Math.pow(base, rem);
                    var x = Math.floor(Math.random() * b).toString(base);
                    res = x + res;
                }
                
                var parsed = parseInt(res, base);
                if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
                    return hat(bits, base)
                }
                else return res;
            };
            
            hat.rack = function (bits, base, expandBy) {
                var fn = function (data) {
                    var iters = 0;
                    do {
                        if (iters++ > 10) {
                            if (expandBy) bits += expandBy;
                            else throw new Error('too many ID collisions, use more bits')
                        }
                        
                        var id = hat(bits, base);
                    } while (Object.hasOwnProperty.call(hats, id));
                    
                    hats[id] = data;
                    return id;
                };
                var hats = fn.hats = {};
                
                fn.get = function (id) {
                    return fn.hats[id];
                };
                
                fn.set = function (id, value) {
                    fn.hats[id] = value;
                    return fn;
                };
                
                fn.bits = bits || 128;
                fn.base = base || 16;
                return fn;
            };

        }, {}], 160: [function (require, module, exports) {
            arguments[4][102][0].apply(exports, arguments)
        }, { "dup": 102 }], 161: [function (require, module, exports) {
            module.exports = isTypedArray
            isTypedArray.strict = isStrictTypedArray
            isTypedArray.loose = isLooseTypedArray
            
            var toString = Object.prototype.toString
            var names = {
                '[object Int8Array]': true
                , '[object Int16Array]': true
                , '[object Int32Array]': true
                , '[object Uint8Array]': true
                , '[object Uint8ClampedArray]': true
                , '[object Uint16Array]': true
                , '[object Uint32Array]': true
                , '[object Float32Array]': true
                , '[object Float64Array]': true
            }
            
            function isTypedArray(arr) {
                return (
       isStrictTypedArray(arr) 
    || isLooseTypedArray(arr)
)
            }
            
            function isStrictTypedArray(arr) {
                return (
       arr instanceof Int8Array 
    || arr instanceof Int16Array 
    || arr instanceof Int32Array 
    || arr instanceof Uint8Array 
    || arr instanceof Uint8ClampedArray 
    || arr instanceof Uint16Array 
    || arr instanceof Uint32Array 
    || arr instanceof Float32Array 
    || arr instanceof Float64Array
)
            }
            
            function isLooseTypedArray(arr) {
                return names[toString.call(arr)]
            }

        }, {}], 162: [function (require, module, exports) {
            // Returns a wrapper function that returns a wrapped callback
            // The wrapper function should do some stuff, and return a
            // presumably different callback function.
            // This makes sure that own properties are retained, so that
            // decorations and such are not lost along the way.
            module.exports = wrappy
            function wrappy(fn, cb) {
                if (fn && cb) return wrappy(fn)(cb)
                
                if (typeof fn !== 'function')
                    throw new TypeError('need wrapper function')
                
                Object.keys(fn).forEach(function (k) {
                    wrapper[k] = fn[k]
                })
                
                return wrapper
                
                function wrapper() {
                    var args = new Array(arguments.length)
                    for (var i = 0; i < args.length; i++) {
                        args[i] = arguments[i]
                    }
                    var ret = fn.apply(this, args)
                    var cb = args[args.length - 1]
                    if (typeof ret === 'function' && ret !== cb) {
                        Object.keys(cb).forEach(function (k) {
                            ret[k] = cb[k]
                        })
                    }
                    return ret
                }
            }

        }, {}], 163: [function (require, module, exports) {
            var wrappy = require('wrappy')
            module.exports = wrappy(once)
            
            once.proto = once(function () {
                Object.defineProperty(Function.prototype, 'once', {
                    value: function () {
                        return once(this)
                    },
                    configurable: true
                })
            })
            
            function once(fn) {
                var f = function () {
                    if (f.called) return f.value
                    f.called = true
                    return f.value = fn.apply(this, arguments)
                }
                f.called = false
                return f
            }

        }, { "wrappy": 162 }], 164: [function (require, module, exports) {
            (function (Buffer) {
                /**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = require('is-typedarray').strict
                
                module.exports = function (arr) {
                    // If `Buffer` is the browser `buffer` module, and the browser supports typed arrays,
                    // then avoid a copy. Otherwise, create a `Buffer` with a copy.
                    var constructor = Buffer.TYPED_ARRAY_SUPPORT
    ? Buffer._augment
    : function (arr) { return new Buffer(arr) }
                    
                    if (arr instanceof Uint8Array) {
                        return constructor(arr)
                    } else if (arr instanceof ArrayBuffer) {
                        return constructor(new Uint8Array(arr))
                    } else if (isTypedArray(arr)) {
                        // Use the typed array's underlying ArrayBuffer to back new Buffer. This respects
                        // the "view" on the ArrayBuffer, i.e. byteOffset and byteLength. No copy.
                        return constructor(new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength))
                    } else {
                        // Unsupported type, just pass it through to the `Buffer` constructor.
                        return new Buffer(arr)
                    }
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172, "is-typedarray": 161 }], 165: [function (require, module, exports) {
            
            /**
 * Module dependencies.
 */

var global = (function () { return this; })();
            
            /**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;
            
            /**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;
            
            /**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
                var instance;
                if (protocols) {
                    instance = new WebSocket(uri, protocols);
                } else {
                    instance = new WebSocket(uri);
                }
                return instance;
            }
            
            if (WebSocket) ws.prototype = WebSocket.prototype;

        }, {}], 166: [function (require, module, exports) {
            (function (process) {
                (function (global, undefined) {
                    "use strict";
                    
                    if (global.setImmediate) {
                        return;
                    }
                    
                    var nextHandle = 1; // Spec says greater than zero
                    var tasksByHandle = {};
                    var currentlyRunningATask = false;
                    var doc = global.document;
                    var setImmediate;
                    
                    function addFromSetImmediateArguments(args) {
                        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
                        return nextHandle++;
                    }
                    
                    // This function accepts the same arguments as setImmediate, but
                    // returns a function that requires no arguments.
                    function partiallyApplied(handler) {
                        var args = [].slice.call(arguments, 1);
                        return function () {
                            if (typeof handler === "function") {
                                handler.apply(undefined, args);
                            } else {
                                (new Function("" + handler))();
                            }
                        };
                    }
                    
                    function runIfPresent(handle) {
                        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
                        // So if we're currently running a task, we'll need to delay this invocation.
                        if (currentlyRunningATask) {
                            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
                            // "too much recursion" error.
                            setTimeout(partiallyApplied(runIfPresent, handle), 0);
                        } else {
                            var task = tasksByHandle[handle];
                            if (task) {
                                currentlyRunningATask = true;
                                try {
                                    task();
                                } finally {
                                    clearImmediate(handle);
                                    currentlyRunningATask = false;
                                }
                            }
                        }
                    }
                    
                    function clearImmediate(handle) {
                        delete tasksByHandle[handle];
                    }
                    
                    function installNextTickImplementation() {
                        setImmediate = function () {
                            var handle = addFromSetImmediateArguments(arguments);
                            process.nextTick(partiallyApplied(runIfPresent, handle));
                            return handle;
                        };
                    }
                    
                    function canUsePostMessage() {
                        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
                        // where `global.postMessage` means something completely different and can't be used for this purpose.
                        if (global.postMessage && !global.importScripts) {
                            var postMessageIsAsynchronous = true;
                            var oldOnMessage = global.onmessage;
                            global.onmessage = function () {
                                postMessageIsAsynchronous = false;
                            };
                            global.postMessage("", "*");
                            global.onmessage = oldOnMessage;
                            return postMessageIsAsynchronous;
                        }
                    }
                    
                    function installPostMessageImplementation() {
                        // Installs an event handler on `global` for the `message` event: see
                        // * https://developer.mozilla.org/en/DOM/window.postMessage
                        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
                        
                        var messagePrefix = "setImmediate$" + Math.random() + "$";
                        var onGlobalMessage = function (event) {
                            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                                runIfPresent(+event.data.slice(messagePrefix.length));
                            }
                        };
                        
                        if (global.addEventListener) {
                            global.addEventListener("message", onGlobalMessage, false);
                        } else {
                            global.attachEvent("onmessage", onGlobalMessage);
                        }
                        
                        setImmediate = function () {
                            var handle = addFromSetImmediateArguments(arguments);
                            global.postMessage(messagePrefix + handle, "*");
                            return handle;
                        };
                    }
                    
                    function installMessageChannelImplementation() {
                        var channel = new MessageChannel();
                        channel.port1.onmessage = function (event) {
                            var handle = event.data;
                            runIfPresent(handle);
                        };
                        
                        setImmediate = function () {
                            var handle = addFromSetImmediateArguments(arguments);
                            channel.port2.postMessage(handle);
                            return handle;
                        };
                    }
                    
                    function installReadyStateChangeImplementation() {
                        var html = doc.documentElement;
                        setImmediate = function () {
                            var handle = addFromSetImmediateArguments(arguments);
                            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                            var script = doc.createElement("script");
                            script.onreadystatechange = function () {
                                runIfPresent(handle);
                                script.onreadystatechange = null;
                                html.removeChild(script);
                                script = null;
                            };
                            html.appendChild(script);
                            return handle;
                        };
                    }
                    
                    function installSetTimeoutImplementation() {
                        setImmediate = function () {
                            var handle = addFromSetImmediateArguments(arguments);
                            setTimeout(partiallyApplied(runIfPresent, handle), 0);
                            return handle;
                        };
                    }
                    
                    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
                    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
                    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
                    
                    // Don't get fooled by e.g. browserify environments.
                    if ({}.toString.call(global.process) === "[object process]") {
                        // For Node.js before 0.9
                        installNextTickImplementation();

                    } else if (canUsePostMessage()) {
                        // For non-IE10 modern browsers
                        installPostMessageImplementation();

                    } else if (global.MessageChannel) {
                        // For web workers, where supported
                        installMessageChannelImplementation();

                    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
                        // For IE 6â€“8
                        installReadyStateChangeImplementation();

                    } else {
                        // For older browsers
                        installSetTimeoutImplementation();
                    }
                    
                    attachTo.setImmediate = setImmediate;
                    attachTo.clearImmediate = clearImmediate;
                }(new Function("return this")()));

            }).call(this, require('_process'))
        }, { "_process": 322 }], 167: [function (require, module, exports) {
            var RTCIceCandidate = window.mozRTCIceCandidate || window.webkitRTCIceCandidate || window.RTCIceCandidate;
            var RTCPeerConnection = window.mozRTCPeerConnection || window.webkitRTCPeerConnection || window.RTCPeerConnection;
            var RTCSessionDescription = window.mozRTCSessionDescription || window.webkitRTCSessionDescription || window.RTCSessionDescription;
            
            exports.RTCIceCandidate = RTCIceCandidate;
            exports.RTCPeerConnection = RTCPeerConnection;
            exports.RTCSessionDescription = RTCSessionDescription;

        }, {}], 168: [function (require, module, exports) {
            module.exports = {
                "name": "webcoin",
                "version": "0.0.0-semantically-released",
                "description": "Bitcoin client for Node.js and the browser",
                "main": "index.js",
                "scripts": {
                    "test": "npm run standard && ./node_modules/.bin/tape test/*.js",
                    "standard": "./node_modules/.bin/standard lib/*.js",
                    "prepublish": "semantic-release pre",
                    "postpublish": "semantic-release post"
                },
                "bin": {
                    "webcoin-bridge": "./bin/bridge.js"
                },
                "keywords": [
                    "bitcoin",
                    "client",
                    "spv",
                    "cryptocurrency",
                    "p2p"
                ],
                "author": "Matt Bell <mappum@gmail.com>",
                "license": "MIT",
                "dependencies": {
                    "async": "^1.2.1",
                    "bitcoin": "^2.3.1",
                    "bitcore": "^0.12.10",
                    "bitcore-p2p": "^0.14.0",
                    "bitcore-p2p-browserify": "^0.14.0",
                    "browserify-buffertools": "^1.0.2",
                    "buffertools": "^2.1.2",
                    "level-js": "^2.1.6",
                    "leveldown": "^1.3.0",
                    "levelup": "^1.2.1",
                    "minimist": "^1.1.1",
                    "mkdirp": "^0.5.1",
                    "peerhub": "^0.1.0",
                    "setimmediate": "^1.0.2"
                },
                "devDependencies": {
                    "semantic-release": "^3.4.1",
                    "standard": "^4.3.2",
                    "tape": "^4.0.0"
                },
                "browser": {
                    "buffertools": "browserify-buffertools",
                    "bitcore-p2p": "bitcore-p2p-browserify"
                },
                "optionalDependencies": {
                    "wrtc": "0.0.55"
                },
                "repository": {
                    "type": "git",
                    "url": "https://github.com/mappum/webcoin"
                }
            }

        }, {}], 169: [function (require, module, exports) {

        }, {}], 170: [function (require, module, exports) {
            // http://wiki.commonjs.org/wiki/Unit_Testing/1.0
            //
            // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
            //
            // Originally from narwhal.js (http://narwhaljs.org)
            // Copyright (c) 2009 Thomas Robinson <280north.com>
            //
            // Permission is hereby granted, free of charge, to any person obtaining a copy
            // of this software and associated documentation files (the 'Software'), to
            // deal in the Software without restriction, including without limitation the
            // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
            // sell copies of the Software, and to permit persons to whom the Software is
            // furnished to do so, subject to the following conditions:
            //
            // The above copyright notice and this permission notice shall be included in
            // all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
            // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
            // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
            
            // when used in node, this will actually load the util module we depend on
            // versus loading the builtin util module as happens otherwise
            // this is a bug in node module loading as far as I am concerned
            var util = require('util/');
            
            var pSlice = Array.prototype.slice;
            var hasOwn = Object.prototype.hasOwnProperty;
            
            // 1. The assert module provides functions that throw
            // AssertionError's when particular conditions are not met. The
            // assert module must conform to the following interface.
            
            var assert = module.exports = ok;
            
            // 2. The AssertionError is defined in assert.
            // new assert.AssertionError({ message: message,
            //                             actual: actual,
            //                             expected: expected })
            
            assert.AssertionError = function AssertionError(options) {
                this.name = 'AssertionError';
                this.actual = options.actual;
                this.expected = options.expected;
                this.operator = options.operator;
                if (options.message) {
                    this.message = options.message;
                    this.generatedMessage = false;
                } else {
                    this.message = getMessage(this);
                    this.generatedMessage = true;
                }
                var stackStartFunction = options.stackStartFunction || fail;
                
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, stackStartFunction);
                }
                else {
                    // non v8 browsers so we can have a stacktrace
                    var err = new Error();
                    if (err.stack) {
                        var out = err.stack;
                        
                        // try to strip useless frames
                        var fn_name = stackStartFunction.name;
                        var idx = out.indexOf('\n' + fn_name);
                        if (idx >= 0) {
                            // once we have located the function frame
                            // we need to strip out everything before it (and its line)
                            var next_line = out.indexOf('\n', idx + 1);
                            out = out.substring(next_line + 1);
                        }
                        
                        this.stack = out;
                    }
                }
            };
            
            // assert.AssertionError instanceof Error
            util.inherits(assert.AssertionError, Error);
            
            function replacer(key, value) {
                if (util.isUndefined(value)) {
                    return '' + value;
                }
                if (util.isNumber(value) && !isFinite(value)) {
                    return value.toString();
                }
                if (util.isFunction(value) || util.isRegExp(value)) {
                    return value.toString();
                }
                return value;
            }
            
            function truncate(s, n) {
                if (util.isString(s)) {
                    return s.length < n ? s : s.slice(0, n);
                } else {
                    return s;
                }
            }
            
            function getMessage(self) {
                return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
            }
            
            // At present only the three keys mentioned above are used and
            // understood by the spec. Implementations or sub modules can pass
            // other keys to the AssertionError's constructor - they will be
            // ignored.
            
            // 3. All of the following functions must throw an AssertionError
            // when a corresponding condition is not met, with a message that
            // may be undefined if not provided.  All assertion methods provide
            // both the actual and expected values to the assertion error for
            // display purposes.
            
            function fail(actual, expected, message, operator, stackStartFunction) {
                throw new assert.AssertionError({
                    message: message,
                    actual: actual,
                    expected: expected,
                    operator: operator,
                    stackStartFunction: stackStartFunction
                });
            }
            
            // EXTENSION! allows for well behaved errors defined elsewhere.
            assert.fail = fail;
            
            // 4. Pure assertion tests whether a value is truthy, as determined
            // by !!guard.
            // assert.ok(guard, message_opt);
            // This statement is equivalent to assert.equal(true, !!guard,
            // message_opt);. To test strictly for the value true, use
            // assert.strictEqual(true, guard, message_opt);.
            
            function ok(value, message) {
                if (!value) fail(value, true, message, '==', assert.ok);
            }
            assert.ok = ok;
            
            // 5. The equality assertion tests shallow, coercive equality with
            // ==.
            // assert.equal(actual, expected, message_opt);
            
            assert.equal = function equal(actual, expected, message) {
                if (actual != expected) fail(actual, expected, message, '==', assert.equal);
            };
            
            // 6. The non-equality assertion tests for whether two objects are not equal
            // with != assert.notEqual(actual, expected, message_opt);
            
            assert.notEqual = function notEqual(actual, expected, message) {
                if (actual == expected) {
                    fail(actual, expected, message, '!=', assert.notEqual);
                }
            };
            
            // 7. The equivalence assertion tests a deep equality relation.
            // assert.deepEqual(actual, expected, message_opt);
            
            assert.deepEqual = function deepEqual(actual, expected, message) {
                if (!_deepEqual(actual, expected)) {
                    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
                }
            };
            
            function _deepEqual(actual, expected) {
                // 7.1. All identical values are equivalent, as determined by ===.
                if (actual === expected) {
                    return true;

                } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
                    if (actual.length != expected.length) return false;
                    
                    for (var i = 0; i < actual.length; i++) {
                        if (actual[i] !== expected[i]) return false;
                    }
                    
                    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
                } else if (util.isDate(actual) && util.isDate(expected)) {
                    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
                } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
                } else if (!util.isObject(actual) && !util.isObject(expected)) {
                    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
                } else {
                    return objEquiv(actual, expected);
                }
            }
            
            function isArguments(object) {
                return Object.prototype.toString.call(object) == '[object Arguments]';
            }
            
            function objEquiv(a, b) {
                if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
                    return false;
                // an identical 'prototype' property.
                if (a.prototype !== b.prototype) return false;
                // if one is a primitive, the other must be same
                if (util.isPrimitive(a) || util.isPrimitive(b)) {
                    return a === b;
                }
                var aIsArgs = isArguments(a),
                    bIsArgs = isArguments(b);
                if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
                    return false;
                if (aIsArgs) {
                    a = pSlice.call(a);
                    b = pSlice.call(b);
                    return _deepEqual(a, b);
                }
                var ka = objectKeys(a),
                    kb = objectKeys(b),
                    key, i;
                // having the same number of owned properties (keys incorporates
                // hasOwnProperty)
                if (ka.length != kb.length)
                    return false;
                //the same set of keys (although not necessarily the same order),
                ka.sort();
                kb.sort();
                //~~~cheap key test
                for (i = ka.length - 1; i >= 0; i--) {
                    if (ka[i] != kb[i])
                        return false;
                }
                //equivalent values for every corresponding key, and
                //~~~possibly expensive deep test
                for (i = ka.length - 1; i >= 0; i--) {
                    key = ka[i];
                    if (!_deepEqual(a[key], b[key])) return false;
                }
                return true;
            }
            
            // 8. The non-equivalence assertion tests for any deep inequality.
            // assert.notDeepEqual(actual, expected, message_opt);
            
            assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                if (_deepEqual(actual, expected)) {
                    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
                }
            };
            
            // 9. The strict equality assertion tests strict equality, as determined by ===.
            // assert.strictEqual(actual, expected, message_opt);
            
            assert.strictEqual = function strictEqual(actual, expected, message) {
                if (actual !== expected) {
                    fail(actual, expected, message, '===', assert.strictEqual);
                }
            };
            
            // 10. The strict non-equality assertion tests for strict inequality, as
            // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
            
            assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                if (actual === expected) {
                    fail(actual, expected, message, '!==', assert.notStrictEqual);
                }
            };
            
            function expectedException(actual, expected) {
                if (!actual || !expected) {
                    return false;
                }
                
                if (Object.prototype.toString.call(expected) == '[object RegExp]') {
                    return expected.test(actual);
                } else if (actual instanceof expected) {
                    return true;
                } else if (expected.call({}, actual) === true) {
                    return true;
                }
                
                return false;
            }
            
            function _throws(shouldThrow, block, expected, message) {
                var actual;
                
                if (util.isString(expected)) {
                    message = expected;
                    expected = null;
                }
                
                try {
                    block();
                } catch (e) {
                    actual = e;
                }
                
                message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');
                
                if (shouldThrow && !actual) {
                    fail(actual, expected, 'Missing expected exception' + message);
                }
                
                if (!shouldThrow && expectedException(actual, expected)) {
                    fail(actual, expected, 'Got unwanted exception' + message);
                }
                
                if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
                    throw actual;
                }
            }
            
            // 11. Expected to throw an error:
            // assert.throws(block, Error_opt, message_opt);
            
            assert.throws = function (block, /*optional*/error, /*optional*/message) {
                _throws.apply(this, [true].concat(pSlice.call(arguments)));
            };
            
            // EXTENSION! This is annoying to write outside this module.
            assert.doesNotThrow = function (block, /*optional*/message) {
                _throws.apply(this, [false].concat(pSlice.call(arguments)));
            };
            
            assert.ifError = function (err) { if (err) { throw err; } };
            
            var objectKeys = Object.keys || function (obj) {
                var keys = [];
                for (var key in obj) {
                    if (hasOwn.call(obj, key)) keys.push(key);
                }
                return keys;
            };

        }, { "util/": 342 }], 171: [function (require, module, exports) {
            arguments[4][169][0].apply(exports, arguments)
        }, { "dup": 169 }], 172: [function (require, module, exports) {
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
            var ieee754 = require('ieee754')
            var isArray = require('is-array')
            
            exports.Buffer = Buffer
            exports.SlowBuffer = SlowBuffer
            exports.INSPECT_MAX_BYTES = 50
            Buffer.poolSize = 8192 // not used by this implementation
            
            var kMaxLength = 0x3fffffff
            var rootParent = {}
            
            /**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
                try {
                    var buf = new ArrayBuffer(0)
                    var arr = new Uint8Array(buf)
                    arr.foo = function () { return 42 }
                    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
                } catch (e) {
                    return false
                }
            })()
            
            /**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer(arg) {
                if (!(this instanceof Buffer)) {
                    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
                    if (arguments.length > 1) return new Buffer(arg, arguments[1])
                    return new Buffer(arg)
                }
                
                this.length = 0
                this.parent = undefined
                
                // Common case.
                if (typeof arg === 'number') {
                    return fromNumber(this, arg)
                }
                
                // Slightly less common case.
                if (typeof arg === 'string') {
                    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
                }
                
                // Unusual.
                return fromObject(this, arg)
            }
            
            function fromNumber(that, length) {
                that = allocate(that, length < 0 ? 0 : checked(length) | 0)
                if (!Buffer.TYPED_ARRAY_SUPPORT) {
                    for (var i = 0; i < length; i++) {
                        that[i] = 0
                    }
                }
                return that
            }
            
            function fromString(that, string, encoding) {
                if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
                
                // Assumption: byteLength() return value is always < kMaxLength.
                var length = byteLength(string, encoding) | 0
                that = allocate(that, length)
                
                that.write(string, encoding)
                return that
            }
            
            function fromObject(that, object) {
                if (Buffer.isBuffer(object)) return fromBuffer(that, object)
                
                if (isArray(object)) return fromArray(that, object)
                
                if (object == null) {
                    throw new TypeError('must start with number, buffer, array or string')
                }
                
                if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
                    return fromTypedArray(that, object)
                }
                
                if (object.length) return fromArrayLike(that, object)
                
                return fromJsonObject(that, object)
            }
            
            function fromBuffer(that, buffer) {
                var length = checked(buffer.length) | 0
                that = allocate(that, length)
                buffer.copy(that, 0, 0, length)
                return that
            }
            
            function fromArray(that, array) {
                var length = checked(array.length) | 0
                that = allocate(that, length)
                for (var i = 0; i < length; i += 1) {
                    that[i] = array[i] & 255
                }
                return that
            }
            
            // Duplicate of fromArray() to keep fromArray() monomorphic.
            function fromTypedArray(that, array) {
                var length = checked(array.length) | 0
                that = allocate(that, length)
                // Truncating the elements is probably not what people expect from typed
                // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
                // of the old Buffer constructor.
                for (var i = 0; i < length; i += 1) {
                    that[i] = array[i] & 255
                }
                return that
            }
            
            function fromArrayLike(that, array) {
                var length = checked(array.length) | 0
                that = allocate(that, length)
                for (var i = 0; i < length; i += 1) {
                    that[i] = array[i] & 255
                }
                return that
            }
            
            // Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
            // Returns a zero-length buffer for inputs that don't conform to the spec.
            function fromJsonObject(that, object) {
                var array
                var length = 0
                
                if (object.type === 'Buffer' && isArray(object.data)) {
                    array = object.data
                    length = checked(array.length) | 0
                }
                that = allocate(that, length)
                
                for (var i = 0; i < length; i += 1) {
                    that[i] = array[i] & 255
                }
                return that
            }
            
            function allocate(that, length) {
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    // Return an augmented `Uint8Array` instance, for best performance
                    that = Buffer._augment(new Uint8Array(length))
                } else {
                    // Fallback: Return an object instance of the Buffer class
                    that.length = length
                    that._isBuffer = true
                }
                
                var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
                if (fromPool) that.parent = rootParent
                
                return that
            }
            
            function checked(length) {
                // Note: cannot use `length < kMaxLength` here because that fails when
                // length is NaN (which is otherwise coerced to zero.)
                if (length >= kMaxLength) {
                    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength.toString(16) + ' bytes')
                }
                return length | 0
            }
            
            function SlowBuffer(subject, encoding) {
                if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
                
                var buf = new Buffer(subject, encoding)
                delete buf.parent
                return buf
            }
            
            Buffer.isBuffer = function isBuffer(b) {
                return !!(b != null && b._isBuffer)
            }
            
            Buffer.compare = function compare(a, b) {
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                    throw new TypeError('Arguments must be Buffers')
                }
                
                if (a === b) return 0
                
                var x = a.length
                var y = b.length
                
                var i = 0
                var len = Math.min(x, y)
                while (i < len) {
                    if (a[i] !== b[i]) break
                    
                    ++i
                }
                
                if (i !== len) {
                    x = a[i]
                    y = b[i]
                }
                
                if (x < y) return -1
                if (y < x) return 1
                return 0
            }
            
            Buffer.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'binary':
                    case 'base64':
                    case 'raw':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return true
                    default:
                        return false
                }
            }
            
            Buffer.concat = function concat(list, length) {
                if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
                
                if (list.length === 0) {
                    return new Buffer(0)
                } else if (list.length === 1) {
                    return list[0]
                }
                
                var i
                if (length === undefined) {
                    length = 0
                    for (i = 0; i < list.length; i++) {
                        length += list[i].length
                    }
                }
                
                var buf = new Buffer(length)
                var pos = 0
                for (i = 0; i < list.length; i++) {
                    var item = list[i]
                    item.copy(buf, pos)
                    pos += item.length
                }
                return buf
            }
            
            function byteLength(string, encoding) {
                if (typeof string !== 'string') string = String(string)
                
                if (string.length === 0) return 0
                
                switch (encoding || 'utf8') {
                    case 'ascii':
                    case 'binary':
                    case 'raw':
                        return string.length
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return string.length * 2
                    case 'hex':
                        return string.length >>> 1
                    case 'utf8':
                    case 'utf-8':
                        return utf8ToBytes(string).length
                    case 'base64':
                        return base64ToBytes(string).length
                    default:
                        return string.length
                }
            }
            Buffer.byteLength = byteLength
            
            // pre-set for values that may exist in the future
            Buffer.prototype.length = undefined
            Buffer.prototype.parent = undefined
            
            // toString(encoding, start=0, end=buffer.length)
            Buffer.prototype.toString = function toString(encoding, start, end) {
                var loweredCase = false
                
                start = start | 0
                end = end === undefined || end === Infinity ? this.length : end | 0
                
                if (!encoding) encoding = 'utf8'
                if (start < 0) start = 0
                if (end > this.length) end = this.length
                if (end <= start) return ''
                
                while (true) {
                    switch (encoding) {
                        case 'hex':
                            return hexSlice(this, start, end)

                        case 'utf8':
                        case 'utf-8':
                            return utf8Slice(this, start, end)

                        case 'ascii':
                            return asciiSlice(this, start, end)

                        case 'binary':
                            return binarySlice(this, start, end)

                        case 'base64':
                            return base64Slice(this, start, end)

                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return utf16leSlice(this, start, end)

                        default:
                            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = (encoding + '').toLowerCase()
                            loweredCase = true
                    }
                }
            }
            
            Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
                if (this === b) return true
                return Buffer.compare(this, b) === 0
            }
            
            Buffer.prototype.inspect = function inspect() {
                var str = ''
                var max = exports.INSPECT_MAX_BYTES
                if (this.length > 0) {
                    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
                    if (this.length > max) str += ' ... '
                }
                return '<Buffer ' + str + '>'
            }
            
            Buffer.prototype.compare = function compare(b) {
                if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
                if (this === b) return 0
                return Buffer.compare(this, b)
            }
            
            Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
                if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
                else if (byteOffset < -0x80000000) byteOffset = -0x80000000
                byteOffset >>= 0
                
                if (this.length === 0) return -1
                if (byteOffset >= this.length) return -1
                
                // Negative offsets start from the end of the buffer
                if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
                
                if (typeof val === 'string') {
                    if (val.length === 0) return -1 // special case: looking for empty string always fails
                    return String.prototype.indexOf.call(this, val, byteOffset)
                }
                if (Buffer.isBuffer(val)) {
                    return arrayIndexOf(this, val, byteOffset)
                }
                if (typeof val === 'number') {
                    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
                        return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
                    }
                    return arrayIndexOf(this, [val], byteOffset)
                }
                
                function arrayIndexOf(arr, val, byteOffset) {
                    var foundIndex = -1
                    for (var i = 0; byteOffset + i < arr.length; i++) {
                        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                            if (foundIndex === -1) foundIndex = i
                            if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
                        } else {
                            foundIndex = -1
                        }
                    }
                    return -1
                }
                
                throw new TypeError('val must be string, number or Buffer')
            }
            
            // `get` will be removed in Node 0.13+
            Buffer.prototype.get = function get(offset) {
                console.log('.get() is deprecated. Access using array indexes instead.')
                return this.readUInt8(offset)
            }
            
            // `set` will be removed in Node 0.13+
            Buffer.prototype.set = function set(v, offset) {
                console.log('.set() is deprecated. Access using array indexes instead.')
                return this.writeUInt8(v, offset)
            }
            
            function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0
                var remaining = buf.length - offset
                if (!length) {
                    length = remaining
                } else {
                    length = Number(length)
                    if (length > remaining) {
                        length = remaining
                    }
                }
                
                // must be an even number of digits
                var strLen = string.length
                if (strLen % 2 !== 0) throw new Error('Invalid hex string')
                
                if (length > strLen / 2) {
                    length = strLen / 2
                }
                for (var i = 0; i < length; i++) {
                    var parsed = parseInt(string.substr(i * 2, 2), 16)
                    if (isNaN(parsed)) throw new Error('Invalid hex string')
                    buf[offset + i] = parsed
                }
                return i
            }
            
            function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
            }
            
            function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length)
            }
            
            function binaryWrite(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length)
            }
            
            function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length)
            }
            
            function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
            }
            
            Buffer.prototype.write = function write(string, offset, length, encoding) {
                // Buffer#write(string)
                if (offset === undefined) {
                    encoding = 'utf8'
                    length = this.length
                    offset = 0
  // Buffer#write(string, encoding)
                } else if (length === undefined && typeof offset === 'string') {
                    encoding = offset
                    length = this.length
                    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
                } else if (isFinite(offset)) {
                    offset = offset | 0
                    if (isFinite(length)) {
                        length = length | 0
                        if (encoding === undefined) encoding = 'utf8'
                    } else {
                        encoding = length
                        length = undefined
                    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
                } else {
                    var swap = encoding
                    encoding = offset
                    offset = length | 0
                    length = swap
                }
                
                var remaining = this.length - offset
                if (length === undefined || length > remaining) length = remaining
                
                if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                    throw new RangeError('attempt to write outside buffer bounds')
                }
                
                if (!encoding) encoding = 'utf8'
                
                var loweredCase = false
                for (;;) {
                    switch (encoding) {
                        case 'hex':
                            return hexWrite(this, string, offset, length)

                        case 'utf8':
                        case 'utf-8':
                            return utf8Write(this, string, offset, length)

                        case 'ascii':
                            return asciiWrite(this, string, offset, length)

                        case 'binary':
                            return binaryWrite(this, string, offset, length)

                        case 'base64':
                            // Warning: maxLength not taken into account in base64Write
                            return base64Write(this, string, offset, length)

                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return ucs2Write(this, string, offset, length)

                        default:
                            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = ('' + encoding).toLowerCase()
                            loweredCase = true
                    }
                }
            }
            
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: 'Buffer',
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }
            
            function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf)
                } else {
                    return base64.fromByteArray(buf.slice(start, end))
                }
            }
            
            function utf8Slice(buf, start, end) {
                var res = ''
                var tmp = ''
                end = Math.min(buf.length, end)
                
                for (var i = start; i < end; i++) {
                    if (buf[i] <= 0x7F) {
                        res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
                        tmp = ''
                    } else {
                        tmp += '%' + buf[i].toString(16)
                    }
                }
                
                return res + decodeUtf8Char(tmp)
            }
            
            function asciiSlice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)
                
                for (var i = start; i < end; i++) {
                    ret += String.fromCharCode(buf[i] & 0x7F)
                }
                return ret
            }
            
            function binarySlice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)
                
                for (var i = start; i < end; i++) {
                    ret += String.fromCharCode(buf[i])
                }
                return ret
            }
            
            function hexSlice(buf, start, end) {
                var len = buf.length
                
                if (!start || start < 0) start = 0
                if (!end || end < 0 || end > len) end = len
                
                var out = ''
                for (var i = start; i < end; i++) {
                    out += toHex(buf[i])
                }
                return out
            }
            
            function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end)
                var res = ''
                for (var i = 0; i < bytes.length; i += 2) {
                    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
                }
                return res
            }
            
            Buffer.prototype.slice = function slice(start, end) {
                var len = this.length
                start = ~~start
                end = end === undefined ? len : ~~end
                
                if (start < 0) {
                    start += len
                    if (start < 0) start = 0
                } else if (start > len) {
                    start = len
                }
                
                if (end < 0) {
                    end += len
                    if (end < 0) end = 0
                } else if (end > len) {
                    end = len
                }
                
                if (end < start) end = start
                
                var newBuf
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    newBuf = Buffer._augment(this.subarray(start, end))
                } else {
                    var sliceLen = end - start
                    newBuf = new Buffer(sliceLen, undefined)
                    for (var i = 0; i < sliceLen; i++) {
                        newBuf[i] = this[i + start]
                    }
                }
                
                if (newBuf.length) newBuf.parent = this.parent || this
                
                return newBuf
            }
            
            /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
                if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
                if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
            }
            
            Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)
                
                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                }
                
                return val
            }
            
            Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) {
                    checkOffset(offset, byteLength, this.length)
                }
                
                var val = this[offset + --byteLength]
                var mul = 1
                while (byteLength > 0 && (mul *= 0x100)) {
                    val += this[offset + --byteLength] * mul
                }
                
                return val
            }
            
            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 1, this.length)
                return this[offset]
            }
            
            Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                return this[offset] | (this[offset + 1] << 8)
            }
            
            Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                return (this[offset] << 8) | this[offset + 1]
            }
            
            Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                
                return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
            }
            
            Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                
                return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
            }
            
            Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)
                
                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                }
                mul *= 0x80
                
                if (val >= mul) val -= Math.pow(2, 8 * byteLength)
                
                return val
            }
            
            Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkOffset(offset, byteLength, this.length)
                
                var i = byteLength
                var mul = 1
                var val = this[offset + --i]
                while (i > 0 && (mul *= 0x100)) {
                    val += this[offset + --i] * mul
                }
                mul *= 0x80
                
                if (val >= mul) val -= Math.pow(2, 8 * byteLength)
                
                return val
            }
            
            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 1, this.length)
                if (!(this[offset] & 0x80)) return (this[offset])
                return ((0xff - this[offset] + 1) * -1)
            }
            
            Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset] | (this[offset + 1] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }
            
            Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length)
                var val = this[offset + 1] | (this[offset] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }
            
            Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                
                return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
            }
            
            Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                
                return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
            }
            
            Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, true, 23, 4)
            }
            
            Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, false, 23, 4)
            }
            
            Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, true, 52, 8)
            }
            
            Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, false, 52, 8)
            }
            
            function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
                if (value > max || value < min) throw new RangeError('value is out of bounds')
                if (offset + ext > buf.length) throw new RangeError('index out of range')
            }
            
            Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
                
                var mul = 1
                var i = 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                }
                
                return offset + byteLength
            }
            
            Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
                
                var i = byteLength - 1
                var mul = 1
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                }
                
                return offset + byteLength
            }
            
            Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
                if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
                this[offset] = value
                return offset + 1
            }
            
            function objectWriteUInt16(buf, value, offset, littleEndian) {
                if (value < 0) value = 0xffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
                    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
                }
            }
            
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = value
                    this[offset + 1] = (value >>> 8)
                } else {
                    objectWriteUInt16(this, value, offset, true)
                }
                return offset + 2
            }
            
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 8)
                    this[offset + 1] = value
                } else {
                    objectWriteUInt16(this, value, offset, false)
                }
                return offset + 2
            }
            
            function objectWriteUInt32(buf, value, offset, littleEndian) {
                if (value < 0) value = 0xffffffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
                    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
                }
            }
            
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset + 3] = (value >>> 24)
                    this[offset + 2] = (value >>> 16)
                    this[offset + 1] = (value >>> 8)
                    this[offset] = value
                } else {
                    objectWriteUInt32(this, value, offset, true)
                }
                return offset + 4
            }
            
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 24)
                    this[offset + 1] = (value >>> 16)
                    this[offset + 2] = (value >>> 8)
                    this[offset + 3] = value
                } else {
                    objectWriteUInt32(this, value, offset, false)
                }
                return offset + 4
            }
            
            Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1)
                    
                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }
                
                var i = 0
                var mul = 1
                var sub = value < 0 ? 1 : 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) {
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }
                
                return offset + byteLength
            }
            
            Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1)
                    
                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }
                
                var i = byteLength - 1
                var mul = 1
                var sub = value < 0 ? 1 : 0
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) {
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }
                
                return offset + byteLength
            }
            
            Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
                if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
                if (value < 0) value = 0xff + value + 1
                this[offset] = value
                return offset + 1
            }
            
            Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = value
                    this[offset + 1] = (value >>> 8)
                } else {
                    objectWriteUInt16(this, value, offset, true)
                }
                return offset + 2
            }
            
            Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 8)
                    this[offset + 1] = value
                } else {
                    objectWriteUInt16(this, value, offset, false)
                }
                return offset + 2
            }
            
            Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = value
                    this[offset + 1] = (value >>> 8)
                    this[offset + 2] = (value >>> 16)
                    this[offset + 3] = (value >>> 24)
                } else {
                    objectWriteUInt32(this, value, offset, true)
                }
                return offset + 4
            }
            
            Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (value < 0) value = 0xffffffff + value + 1
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 24)
                    this[offset + 1] = (value >>> 16)
                    this[offset + 2] = (value >>> 8)
                    this[offset + 3] = value
                } else {
                    objectWriteUInt32(this, value, offset, false)
                }
                return offset + 4
            }
            
            function checkIEEE754(buf, value, offset, ext, max, min) {
                if (value > max || value < min) throw new RangeError('value is out of bounds')
                if (offset + ext > buf.length) throw new RangeError('index out of range')
                if (offset < 0) throw new RangeError('index out of range')
            }
            
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4)
                return offset + 4
            }
            
            Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert)
            }
            
            Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert)
            }
            
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8)
                return offset + 8
            }
            
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert)
            }
            
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert)
            }
            
            // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                if (!start) start = 0
                if (!end && end !== 0) end = this.length
                if (targetStart >= target.length) targetStart = target.length
                if (!targetStart) targetStart = 0
                if (end > 0 && end < start) end = start
                
                // Copy 0 bytes; we're done
                if (end === start) return 0
                if (target.length === 0 || this.length === 0) return 0
                
                // Fatal error conditions
                if (targetStart < 0) {
                    throw new RangeError('targetStart out of bounds')
                }
                if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
                if (end < 0) throw new RangeError('sourceEnd out of bounds')
                
                // Are we oob?
                if (end > this.length) end = this.length
                if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start
                }
                
                var len = end - start
                
                if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                    for (var i = 0; i < len; i++) {
                        target[i + targetStart] = this[i + start]
                    }
                } else {
                    target._set(this.subarray(start, start + len), targetStart)
                }
                
                return len
            }
            
            // fill(value, start=0, end=buffer.length)
            Buffer.prototype.fill = function fill(value, start, end) {
                if (!value) value = 0
                if (!start) start = 0
                if (!end) end = this.length
                
                if (end < start) throw new RangeError('end < start')
                
                // Fill 0 bytes; we're done
                if (end === start) return
                if (this.length === 0) return
                
                if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
                if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
                
                var i
                if (typeof value === 'number') {
                    for (i = start; i < end; i++) {
                        this[i] = value
                    }
                } else {
                    var bytes = utf8ToBytes(value.toString())
                    var len = bytes.length
                    for (i = start; i < end; i++) {
                        this[i] = bytes[i % len]
                    }
                }
                
                return this
            }
            
            /**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
                if (typeof Uint8Array !== 'undefined') {
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        return (new Buffer(this)).buffer
                    } else {
                        var buf = new Uint8Array(this.length)
                        for (var i = 0, len = buf.length; i < len; i += 1) {
                            buf[i] = this[i]
                        }
                        return buf.buffer
                    }
                } else {
                    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
                }
            }
            
            // HELPER FUNCTIONS
            // ================
            
            var BP = Buffer.prototype
            
            /**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment(arr) {
                arr.constructor = Buffer
                arr._isBuffer = true
                
                // save reference to original Uint8Array set method before overwriting
                arr._set = arr.set
                
                // deprecated, will be removed in node 0.13+
                arr.get = BP.get
                arr.set = BP.set
                
                arr.write = BP.write
                arr.toString = BP.toString
                arr.toLocaleString = BP.toString
                arr.toJSON = BP.toJSON
                arr.equals = BP.equals
                arr.compare = BP.compare
                arr.indexOf = BP.indexOf
                arr.copy = BP.copy
                arr.slice = BP.slice
                arr.readUIntLE = BP.readUIntLE
                arr.readUIntBE = BP.readUIntBE
                arr.readUInt8 = BP.readUInt8
                arr.readUInt16LE = BP.readUInt16LE
                arr.readUInt16BE = BP.readUInt16BE
                arr.readUInt32LE = BP.readUInt32LE
                arr.readUInt32BE = BP.readUInt32BE
                arr.readIntLE = BP.readIntLE
                arr.readIntBE = BP.readIntBE
                arr.readInt8 = BP.readInt8
                arr.readInt16LE = BP.readInt16LE
                arr.readInt16BE = BP.readInt16BE
                arr.readInt32LE = BP.readInt32LE
                arr.readInt32BE = BP.readInt32BE
                arr.readFloatLE = BP.readFloatLE
                arr.readFloatBE = BP.readFloatBE
                arr.readDoubleLE = BP.readDoubleLE
                arr.readDoubleBE = BP.readDoubleBE
                arr.writeUInt8 = BP.writeUInt8
                arr.writeUIntLE = BP.writeUIntLE
                arr.writeUIntBE = BP.writeUIntBE
                arr.writeUInt16LE = BP.writeUInt16LE
                arr.writeUInt16BE = BP.writeUInt16BE
                arr.writeUInt32LE = BP.writeUInt32LE
                arr.writeUInt32BE = BP.writeUInt32BE
                arr.writeIntLE = BP.writeIntLE
                arr.writeIntBE = BP.writeIntBE
                arr.writeInt8 = BP.writeInt8
                arr.writeInt16LE = BP.writeInt16LE
                arr.writeInt16BE = BP.writeInt16BE
                arr.writeInt32LE = BP.writeInt32LE
                arr.writeInt32BE = BP.writeInt32BE
                arr.writeFloatLE = BP.writeFloatLE
                arr.writeFloatBE = BP.writeFloatBE
                arr.writeDoubleLE = BP.writeDoubleLE
                arr.writeDoubleBE = BP.writeDoubleBE
                arr.fill = BP.fill
                arr.inspect = BP.inspect
                arr.toArrayBuffer = BP.toArrayBuffer
                
                return arr
            }
            
            var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g
            
            function base64clean(str) {
                // Node strips out invalid characters like \n and \t from the string, base64-js does not
                str = stringtrim(str).replace(INVALID_BASE64_RE, '')
                // Node converts strings with length < 2 to ''
                if (str.length < 2) return ''
                // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                while (str.length % 4 !== 0) {
                    str = str + '='
                }
                return str
            }
            
            function stringtrim(str) {
                if (str.trim) return str.trim()
                return str.replace(/^\s+|\s+$/g, '')
            }
            
            function toHex(n) {
                if (n < 16) return '0' + n.toString(16)
                return n.toString(16)
            }
            
            function utf8ToBytes(string, units) {
                units = units || Infinity
                var codePoint
                var length = string.length
                var leadSurrogate = null
                var bytes = []
                var i = 0
                
                for (; i < length; i++) {
                    codePoint = string.charCodeAt(i)
                    
                    // is surrogate component
                    if (codePoint > 0xD7FF && codePoint < 0xE000) {
                        // last char was a lead
                        if (leadSurrogate) {
                            // 2 leads in a row
                            if (codePoint < 0xDC00) {
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                leadSurrogate = codePoint
                                continue
                            } else {
                                // valid surrogate pair
                                codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
                                leadSurrogate = null
                            }
                        } else {
                            // no lead yet
                            
                            if (codePoint > 0xDBFF) {
                                // unexpected trail
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            } else if (i + 1 === length) {
                                // unpaired lead
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            } else {
                                // valid lead
                                leadSurrogate = codePoint
                                continue
                            }
                        }
                    } else if (leadSurrogate) {
                        // valid bmp char, but last char was a lead
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                        leadSurrogate = null
                    }
                    
                    // encode utf8
                    if (codePoint < 0x80) {
                        if ((units -= 1) < 0) break
                        bytes.push(codePoint)
                    } else if (codePoint < 0x800) {
                        if ((units -= 2) < 0) break
                        bytes.push(
                            codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
                        )
                    } else if (codePoint < 0x10000) {
                        if ((units -= 3) < 0) break
                        bytes.push(
                            codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
                        )
                    } else if (codePoint < 0x200000) {
                        if ((units -= 4) < 0) break
                        bytes.push(
                            codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
                        )
                    } else {
                        throw new Error('Invalid code point')
                    }
                }
                
                return bytes
            }
            
            function asciiToBytes(str) {
                var byteArray = []
                for (var i = 0; i < str.length; i++) {
                    // Node's code seems to be doing this and not & 0x7F..
                    byteArray.push(str.charCodeAt(i) & 0xFF)
                }
                return byteArray
            }
            
            function utf16leToBytes(str, units) {
                var c, hi, lo
                var byteArray = []
                for (var i = 0; i < str.length; i++) {
                    if ((units -= 2) < 0) break
                    
                    c = str.charCodeAt(i)
                    hi = c >> 8
                    lo = c % 256
                    byteArray.push(lo)
                    byteArray.push(hi)
                }
                
                return byteArray
            }
            
            function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str))
            }
            
            function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; i++) {
                    if ((i + offset >= dst.length) || (i >= src.length)) break
                    dst[i + offset] = src[i]
                }
                return i
            }
            
            function decodeUtf8Char(str) {
                try {
                    return decodeURIComponent(str)
                } catch (err) {
                    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
                }
            }

        }, { "base64-js": 173, "ieee754": 174, "is-array": 175 }], 173: [function (require, module, exports) {
            var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
            
            ; (function (exports) {
                'use strict';
                
                var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array
                
                var PLUS = '+'.charCodeAt(0)
                var SLASH = '/'.charCodeAt(0)
                var NUMBER = '0'.charCodeAt(0)
                var LOWER = 'a'.charCodeAt(0)
                var UPPER = 'A'.charCodeAt(0)
                var PLUS_URL_SAFE = '-'.charCodeAt(0)
                var SLASH_URL_SAFE = '_'.charCodeAt(0)
                
                function decode(elt) {
                    var code = elt.charCodeAt(0)
                    if (code === PLUS ||
                        code === PLUS_URL_SAFE)
                        return 62 // '+'
                    if (code === SLASH ||
                        code === SLASH_URL_SAFE)
                        return 63 // '/'
                    if (code < NUMBER)
                        return -1 //no match
                    if (code < NUMBER + 10)
                        return code - NUMBER + 26 + 26
                    if (code < UPPER + 26)
                        return code - UPPER
                    if (code < LOWER + 26)
                        return code - LOWER + 26
                }
                
                function b64ToByteArray(b64) {
                    var i, j, l, tmp, placeHolders, arr
                    
                    if (b64.length % 4 > 0) {
                        throw new Error('Invalid string. Length must be a multiple of 4')
                    }
                    
                    // the number of equal signs (place holders)
                    // if there are two placeholders, than the two characters before it
                    // represent one byte
                    // if there is only one, then the three characters before it represent 2 bytes
                    // this is just a cheap hack to not do indexOf twice
                    var len = b64.length
                    placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
                    
                    // base64 is 4/3 + up to two characters of the original data
                    arr = new Arr(b64.length * 3 / 4 - placeHolders)
                    
                    // if there are placeholders, only get up to the last complete 4 chars
                    l = placeHolders > 0 ? b64.length - 4 : b64.length
                    
                    var L = 0
                    
                    function push(v) {
                        arr[L++] = v
                    }
                    
                    for (i = 0, j = 0; i < l; i += 4, j += 3) {
                        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
                        push((tmp & 0xFF0000) >> 16)
                        push((tmp & 0xFF00) >> 8)
                        push(tmp & 0xFF)
                    }
                    
                    if (placeHolders === 2) {
                        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
                        push(tmp & 0xFF)
                    } else if (placeHolders === 1) {
                        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
                        push((tmp >> 8) & 0xFF)
                        push(tmp & 0xFF)
                    }
                    
                    return arr
                }
                
                function uint8ToBase64(uint8) {
                    var i,
                        extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
                        output = "",
                        temp, length
                    
                    function encode(num) {
                        return lookup.charAt(num)
                    }
                    
                    function tripletToBase64(num) {
                        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
                    }
                    
                    // go through the array every three bytes, we'll deal with trailing stuff later
                    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
                        output += tripletToBase64(temp)
                    }
                    
                    // pad the end with zeros, but make sure to not forget the extra bytes
                    switch (extraBytes) {
                        case 1:
                            temp = uint8[uint8.length - 1]
                            output += encode(temp >> 2)
                            output += encode((temp << 4) & 0x3F)
                            output += '=='
                            break
                        case 2:
                            temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
                            output += encode(temp >> 10)
                            output += encode((temp >> 4) & 0x3F)
                            output += encode((temp << 2) & 0x3F)
                            output += '='
                            break
                    }
                    
                    return output
                }
                
                exports.toByteArray = b64ToByteArray
                exports.fromByteArray = uint8ToBase64
            }(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

        }, {}], 174: [function (require, module, exports) {
            exports.read = function (buffer, offset, isLE, mLen, nBytes) {
                var e, m
                var eLen = nBytes * 8 - mLen - 1
                var eMax = (1 << eLen) - 1
                var eBias = eMax >> 1
                var nBits = -7
                var i = isLE ? (nBytes - 1) : 0
                var d = isLE ? -1 : 1
                var s = buffer[offset + i]
                
                i += d
                
                e = s & ((1 << (-nBits)) - 1)
                s >>= (-nBits)
                nBits += eLen
                for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) { }
                
                m = e & ((1 << (-nBits)) - 1)
                e >>= (-nBits)
                nBits += mLen
                for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) { }
                
                if (e === 0) {
                    e = 1 - eBias
                } else if (e === eMax) {
                    return m ? NaN : ((s ? -1 : 1) * Infinity)
                } else {
                    m = m + Math.pow(2, mLen)
                    e = e - eBias
                }
                return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
            }
            
            exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
                var e, m, c
                var eLen = nBytes * 8 - mLen - 1
                var eMax = (1 << eLen) - 1
                var eBias = eMax >> 1
                var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
                var i = isLE ? 0 : (nBytes - 1)
                var d = isLE ? 1 : -1
                var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
                
                value = Math.abs(value)
                
                if (isNaN(value) || value === Infinity) {
                    m = isNaN(value) ? 1 : 0
                    e = eMax
                } else {
                    e = Math.floor(Math.log(value) / Math.LN2)
                    if (value * (c = Math.pow(2, -e)) < 1) {
                        e--
                        c *= 2
                    }
                    if (e + eBias >= 1) {
                        value += rt / c
                    } else {
                        value += rt * Math.pow(2, 1 - eBias)
                    }
                    if (value * c >= 2) {
                        e++
                        c /= 2
                    }
                    
                    if (e + eBias >= eMax) {
                        m = 0
                        e = eMax
                    } else if (e + eBias >= 1) {
                        m = (value * c - 1) * Math.pow(2, mLen)
                        e = e + eBias
                    } else {
                        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                        e = 0
                    }
                }
                
                for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }
                
                e = (e << mLen) | m
                eLen += mLen
                for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }
                
                buffer[offset + i - d] |= s * 128
            }

        }, {}], 175: [function (require, module, exports) {
            
            /**
 * isArray
 */

var isArray = Array.isArray;
            
            /**
 * toString
 */

var str = Object.prototype.toString;
            
            /**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
                return !!val && '[object Array]' == str.call(val);
            };

        }, {}], 176: [function (require, module, exports) {
            'use strict';
            
            exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')
            
            exports.createHash = exports.Hash = require('create-hash')
            
            exports.createHmac = exports.Hmac = require('create-hmac')
            
            var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(require('browserify-sign/algos')))
            exports.getHashes = function () {
                return hashes;
            }
            
            var p = require('pbkdf2')
            exports.pbkdf2 = p.pbkdf2
            exports.pbkdf2Sync = p.pbkdf2Sync
            
            var aes = require('browserify-aes');
            [
                'Cipher',
                'createCipher',
                'Cipheriv',
                'createCipheriv',
                'Decipher',
                'createDecipher',
                'Decipheriv',
                'createDecipheriv',
                'getCiphers',
                'listCiphers'
            ].forEach(function (key) {
                exports[key] = aes[key];
            })
            
            var dh = require('diffie-hellman');
            [
                'DiffieHellmanGroup',
                'createDiffieHellmanGroup',
                'getDiffieHellman',
                'createDiffieHellman',
                'DiffieHellman'
            ].forEach(function (key) {
                exports[key] = dh[key];
            })
            
            var sign = require('browserify-sign');
            [
                'createSign',
                'Sign',
                'createVerify',
                'Verify'
            ].forEach(function (key) {
                exports[key] = sign[key];
            })
            
            exports.createECDH = require('create-ecdh')
            
            var publicEncrypt = require('public-encrypt');
            
            [
                'publicEncrypt',
                'privateEncrypt',
                'publicDecrypt',
                'privateDecrypt'
            ].forEach(function (key) {
                exports[key] = publicEncrypt[key];
            })

// the least I can do is make error messages for the rest of the node.js/crypto api.
            ; [
                'createCredentials'
            ].forEach(function (name) {
                exports[name] = function () {
                    throw new Error([
                        'sorry, ' + name + ' is not implemented yet',
                        'we accept pull requests',
                        'https://github.com/crypto-browserify/crypto-browserify'
                    ].join('\n'));
                }
            })

        }, { "browserify-aes": 180, "browserify-sign": 196, "browserify-sign/algos": 195, "create-ecdh": 244, "create-hash": 267, "create-hmac": 279, "diffie-hellman": 280, "pbkdf2": 287, "public-encrypt": 288, "randombytes": 316 }], 177: [function (require, module, exports) {
            (function (Buffer) {
                var md5 = require('create-hash/md5')
                module.exports = EVP_BytesToKey
                function EVP_BytesToKey(password, keyLen, ivLen) {
                    if (!Buffer.isBuffer(password)) {
                        password = new Buffer(password, 'binary')
                    }
                    keyLen = keyLen / 8
                    ivLen = ivLen || 0
                    var ki = 0
                    var ii = 0
                    var key = new Buffer(keyLen)
                    var iv = new Buffer(ivLen)
                    var addmd = 0
                    var md_buf
                    var i
                    var bufs = []
                    while (true) {
                        if (addmd++ > 0) {
                            bufs.push(md_buf)
                        }
                        bufs.push(password)
                        md_buf = md5(Buffer.concat(bufs))
                        bufs = []
                        i = 0
                        if (keyLen > 0) {
                            while (true) {
                                if (keyLen === 0) {
                                    break
                                }
                                if (i === md_buf.length) {
                                    break
                                }
                                key[ki++] = md_buf[i]
                                keyLen--
                                i++
                            }
                        }
                        if (ivLen > 0 && i !== md_buf.length) {
                            while (true) {
                                if (ivLen === 0) {
                                    break
                                }
                                if (i === md_buf.length) {
                                    break
                                }
                                iv[ii++] = md_buf[i]
                                ivLen--
                                i++
                            }
                        }
                        if (keyLen === 0 && ivLen === 0) {
                            break
                        }
                    }
                    for (i = 0; i < md_buf.length; i++) {
                        md_buf[i] = 0
                    }
                    return {
                        key: key,
                        iv: iv
                    }
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172, "create-hash/md5": 269 }], 178: [function (require, module, exports) {
            (function (Buffer) {
                // based on the aes implimentation in triple sec
                // https://github.com/keybase/triplesec
                
                // which is in turn based on the one from crypto-js
                // https://code.google.com/p/crypto-js/
                
                var uint_max = Math.pow(2, 32)
                function fixup_uint32(x) {
                    var ret, x_pos
                    ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
                    return ret
                }
                function scrub_vec(v) {
                    for (var i = 0; i < v.length; v++) {
                        v[i] = 0
                    }
                    return false
                }
                
                function Global() {
                    this.SBOX = []
                    this.INV_SBOX = []
                    this.SUB_MIX = [[], [], [], []]
                    this.INV_SUB_MIX = [[], [], [], []]
                    this.init()
                    this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
                }
                
                Global.prototype.init = function () {
                    var d, i, sx, t, x, x2, x4, x8, xi, _i
                    d = (function () {
                        var _i, _results
                        _results = []
                        for (i = _i = 0; _i < 256; i = ++_i) {
                            if (i < 128) {
                                _results.push(i << 1)
                            } else {
                                _results.push((i << 1) ^ 0x11b)
                            }
                        }
                        return _results
                    })()
                    x = 0
                    xi = 0
                    for (i = _i = 0; _i < 256; i = ++_i) {
                        sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
                        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
                        this.SBOX[x] = sx
                        this.INV_SBOX[sx] = x
                        x2 = d[x]
                        x4 = d[x2]
                        x8 = d[x4]
                        t = (d[sx] * 0x101) ^ (sx * 0x1010100)
                        this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
                        this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
                        this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
                        this.SUB_MIX[3][x] = t
                        t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
                        this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
                        this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
                        this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
                        this.INV_SUB_MIX[3][sx] = t
                        if (x === 0) {
                            x = xi = 1
                        } else {
                            x = x2 ^ d[d[d[x8 ^ x2]]]
                            xi ^= d[d[xi]]
                        }
                    }
                    return true
                }
                
                var G = new Global()
                
                AES.blockSize = 4 * 4
                
                AES.prototype.blockSize = AES.blockSize
                
                AES.keySize = 256 / 8
                
                AES.prototype.keySize = AES.keySize
                
                function bufferToArray(buf) {
                    var len = buf.length / 4
                    var out = new Array(len)
                    var i = -1
                    while (++i < len) {
                        out[i] = buf.readUInt32BE(i * 4)
                    }
                    return out
                }
                function AES(key) {
                    this._key = bufferToArray(key)
                    this._doReset()
                }
                
                AES.prototype._doReset = function () {
                    var invKsRow, keySize, keyWords, ksRow, ksRows, t
                    keyWords = this._key
                    keySize = keyWords.length
                    this._nRounds = keySize + 6
                    ksRows = (this._nRounds + 1) * 4
                    this._keySchedule = []
                    for (ksRow = 0; ksRow < ksRows; ksRow++) {
                        this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
                    }
                    this._invKeySchedule = []
                    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                        ksRow = ksRows - invKsRow
                        t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
                        this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
                    }
                    return true
                }
                
                AES.prototype.encryptBlock = function (M) {
                    M = bufferToArray(new Buffer(M))
                    var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
                    var buf = new Buffer(16)
                    buf.writeUInt32BE(out[0], 0)
                    buf.writeUInt32BE(out[1], 4)
                    buf.writeUInt32BE(out[2], 8)
                    buf.writeUInt32BE(out[3], 12)
                    return buf
                }
                
                AES.prototype.decryptBlock = function (M) {
                    M = bufferToArray(new Buffer(M))
                    var temp = [M[3], M[1]]
                    M[1] = temp[0]
                    M[3] = temp[1]
                    var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
                    var buf = new Buffer(16)
                    buf.writeUInt32BE(out[0], 0)
                    buf.writeUInt32BE(out[3], 4)
                    buf.writeUInt32BE(out[2], 8)
                    buf.writeUInt32BE(out[1], 12)
                    return buf
                }
                
                AES.prototype.scrub = function () {
                    scrub_vec(this._keySchedule)
                    scrub_vec(this._invKeySchedule)
                    scrub_vec(this._key)
                }
                
                AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
                    var ksRow, s0, s1, s2, s3, t0, t1, t2, t3
                    
                    s0 = M[0] ^ keySchedule[0]
                    s1 = M[1] ^ keySchedule[1]
                    s2 = M[2] ^ keySchedule[2]
                    s3 = M[3] ^ keySchedule[3]
                    ksRow = 4
                    for (var round = 1; round < this._nRounds; round++) {
                        t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
                        t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
                        t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
                        t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
                        s0 = t0
                        s1 = t1
                        s2 = t2
                        s3 = t3
                    }
                    t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
                    t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
                    t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
                    t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
                    return [
                        fixup_uint32(t0),
                        fixup_uint32(t1),
                        fixup_uint32(t2),
                        fixup_uint32(t3)
                    ]
                }
                
                exports.AES = AES

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 179: [function (require, module, exports) {
            (function (Buffer) {
                var aes = require('./aes')
                var Transform = require('./cipherBase')
                var inherits = require('inherits')
                var GHASH = require('./ghash')
                var xor = require('./xor')
                inherits(StreamCipher, Transform)
                module.exports = StreamCipher
                
                function StreamCipher(mode, key, iv, decrypt) {
                    if (!(this instanceof StreamCipher)) {
                        return new StreamCipher(mode, key, iv)
                    }
                    Transform.call(this)
                    this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
                    iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
                    this._cipher = new aes.AES(key)
                    this._prev = new Buffer(iv.length)
                    this._cache = new Buffer('')
                    this._secCache = new Buffer('')
                    this._decrypt = decrypt
                    this._alen = 0
                    this._len = 0
                    iv.copy(this._prev)
                    this._mode = mode
                    var h = new Buffer(4)
                    h.fill(0)
                    this._ghash = new GHASH(this._cipher.encryptBlock(h))
                    this._authTag = null
                    this._called = false
                }
                StreamCipher.prototype._update = function (chunk) {
                    if (!this._called && this._alen) {
                        var rump = 16 - (this._alen % 16)
                        if (rump < 16) {
                            rump = new Buffer(rump)
                            rump.fill(0)
                            this._ghash.update(rump)
                        }
                    }
                    this._called = true
                    var out = this._mode.encrypt(this, chunk)
                    if (this._decrypt) {
                        this._ghash.update(chunk)
                    } else {
                        this._ghash.update(out)
                    }
                    this._len += chunk.length
                    return out
                }
                StreamCipher.prototype._final = function () {
                    if (this._decrypt && !this._authTag) {
                        throw new Error('Unsupported state or unable to authenticate data')
                    }
                    var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
                    if (this._decrypt) {
                        if (xorTest(tag, this._authTag)) {
                            throw new Error('Unsupported state or unable to authenticate data')
                        }
                    } else {
                        this._authTag = tag
                    }
                    this._cipher.scrub()
                }
                StreamCipher.prototype.getAuthTag = function getAuthTag() {
                    if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
                        return this._authTag
                    } else {
                        throw new Error('Attempting to get auth tag in unsupported state')
                    }
                }
                StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
                    if (this._decrypt) {
                        this._authTag = tag
                    } else {
                        throw new Error('Attempting to set auth tag in unsupported state')
                    }
                }
                StreamCipher.prototype.setAAD = function setAAD(buf) {
                    if (!this._called) {
                        this._ghash.update(buf)
                        this._alen += buf.length
                    } else {
                        throw new Error('Attempting to set AAD in unsupported state')
                    }
                }
                function xorTest(a, b) {
                    var out = 0
                    if (a.length !== b.length) {
                        out++
                    }
                    var len = Math.min(a.length, b.length)
                    var i = -1
                    while (++i < len) {
                        out += (a[i] ^ b[i])
                    }
                    return out
                }

            }).call(this, require("buffer").Buffer)
        }, { "./aes": 178, "./cipherBase": 181, "./ghash": 184, "./xor": 194, "buffer": 172, "inherits": 318 }], 180: [function (require, module, exports) {
            var ciphers = require('./encrypter')
            exports.createCipher = exports.Cipher = ciphers.createCipher
            exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
            var deciphers = require('./decrypter')
            exports.createDecipher = exports.Decipher = deciphers.createDecipher
            exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
            var modes = require('./modes')
            function getCiphers() {
                return Object.keys(modes)
            }
            exports.listCiphers = exports.getCiphers = getCiphers

        }, { "./decrypter": 182, "./encrypter": 183, "./modes": 185 }], 181: [function (require, module, exports) {
            (function (Buffer) {
                var Transform = require('stream').Transform
                var inherits = require('inherits')
                
                module.exports = CipherBase
                inherits(CipherBase, Transform)
                function CipherBase() {
                    Transform.call(this)
                }
                CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
                    if (typeof data === 'string') {
                        data = new Buffer(data, inputEnc)
                    }
                    var outData = this._update(data)
                    if (outputEnc) {
                        outData = outData.toString(outputEnc)
                    }
                    return outData
                }
                CipherBase.prototype._transform = function (data, _, next) {
                    this.push(this._update(data))
                    next()
                }
                CipherBase.prototype._flush = function (next) {
                    try {
                        this.push(this._final())
                    } catch (e) {
                        return next(e)
                    }
                    next()
                }
                CipherBase.prototype.final = function (outputEnc) {
                    var outData = this._final() || new Buffer('')
                    if (outputEnc) {
                        outData = outData.toString(outputEnc)
                    }
                    return outData
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172, "inherits": 318, "stream": 338 }], 182: [function (require, module, exports) {
            (function (Buffer) {
                var aes = require('./aes')
                var Transform = require('./cipherBase')
                var inherits = require('inherits')
                var modes = require('./modes')
                var StreamCipher = require('./streamCipher')
                var AuthCipher = require('./authCipher')
                var ebtk = require('./EVP_BytesToKey')
                
                inherits(Decipher, Transform)
                function Decipher(mode, key, iv) {
                    if (!(this instanceof Decipher)) {
                        return new Decipher(mode, key, iv)
                    }
                    Transform.call(this)
                    this._cache = new Splitter()
                    this._last = void 0
                    this._cipher = new aes.AES(key)
                    this._prev = new Buffer(iv.length)
                    iv.copy(this._prev)
                    this._mode = mode
                    this._autopadding = true
                }
                Decipher.prototype._update = function (data) {
                    this._cache.add(data)
                    var chunk
                    var thing
                    var out = []
                    while ((chunk = this._cache.get(this._autopadding))) {
                        thing = this._mode.decrypt(this, chunk)
                        out.push(thing)
                    }
                    return Buffer.concat(out)
                }
                Decipher.prototype._final = function () {
                    var chunk = this._cache.flush()
                    if (this._autopadding) {
                        return unpad(this._mode.decrypt(this, chunk))
                    } else if (chunk) {
                        throw new Error('data not multiple of block length')
                    }
                }
                Decipher.prototype.setAutoPadding = function (setTo) {
                    this._autopadding = !!setTo
                }
                function Splitter() {
                    if (!(this instanceof Splitter)) {
                        return new Splitter()
                    }
                    this.cache = new Buffer('')
                }
                Splitter.prototype.add = function (data) {
                    this.cache = Buffer.concat([this.cache, data])
                }
                
                Splitter.prototype.get = function (autoPadding) {
                    var out
                    if (autoPadding) {
                        if (this.cache.length > 16) {
                            out = this.cache.slice(0, 16)
                            this.cache = this.cache.slice(16)
                            return out
                        }
                    } else {
                        if (this.cache.length >= 16) {
                            out = this.cache.slice(0, 16)
                            this.cache = this.cache.slice(16)
                            return out
                        }
                    }
                    return null
                }
                Splitter.prototype.flush = function () {
                    if (this.cache.length) {
                        return this.cache
                    }
                }
                function unpad(last) {
                    var padded = last[15]
                    var i = -1
                    while (++i < padded) {
                        if (last[(i + (16 - padded))] !== padded) {
                            throw new Error('unable to decrypt data')
                        }
                    }
                    if (padded === 16) {
                        return
                    }
                    return last.slice(0, 16 - padded)
                }
                
                var modelist = {
                    ECB: require('./modes/ecb'),
                    CBC: require('./modes/cbc'),
                    CFB: require('./modes/cfb'),
                    CFB8: require('./modes/cfb8'),
                    CFB1: require('./modes/cfb1'),
                    OFB: require('./modes/ofb'),
                    CTR: require('./modes/ctr'),
                    GCM: require('./modes/ctr')
                }
                
                function createDecipheriv(suite, password, iv) {
                    var config = modes[suite.toLowerCase()]
                    if (!config) {
                        throw new TypeError('invalid suite type')
                    }
                    if (typeof iv === 'string') {
                        iv = new Buffer(iv)
                    }
                    if (typeof password === 'string') {
                        password = new Buffer(password)
                    }
                    if (password.length !== config.key / 8) {
                        throw new TypeError('invalid key length ' + password.length)
                    }
                    if (iv.length !== config.iv) {
                        throw new TypeError('invalid iv length ' + iv.length)
                    }
                    if (config.type === 'stream') {
                        return new StreamCipher(modelist[config.mode], password, iv, true)
                    } else if (config.type === 'auth') {
                        return new AuthCipher(modelist[config.mode], password, iv, true)
                    }
                    return new Decipher(modelist[config.mode], password, iv)
                }
                
                function createDecipher(suite, password) {
                    var config = modes[suite.toLowerCase()]
                    if (!config) {
                        throw new TypeError('invalid suite type')
                    }
                    var keys = ebtk(password, config.key, config.iv)
                    return createDecipheriv(suite, keys.key, keys.iv)
                }
                exports.createDecipher = createDecipher
                exports.createDecipheriv = createDecipheriv

            }).call(this, require("buffer").Buffer)
        }, { "./EVP_BytesToKey": 177, "./aes": 178, "./authCipher": 179, "./cipherBase": 181, "./modes": 185, "./modes/cbc": 186, "./modes/cfb": 187, "./modes/cfb1": 188, "./modes/cfb8": 189, "./modes/ctr": 190, "./modes/ecb": 191, "./modes/ofb": 192, "./streamCipher": 193, "buffer": 172, "inherits": 318 }], 183: [function (require, module, exports) {
            (function (Buffer) {
                var aes = require('./aes')
                var Transform = require('./cipherBase')
                var inherits = require('inherits')
                var modes = require('./modes')
                var ebtk = require('./EVP_BytesToKey')
                var StreamCipher = require('./streamCipher')
                var AuthCipher = require('./authCipher')
                inherits(Cipher, Transform)
                function Cipher(mode, key, iv) {
                    if (!(this instanceof Cipher)) {
                        return new Cipher(mode, key, iv)
                    }
                    Transform.call(this)
                    this._cache = new Splitter()
                    this._cipher = new aes.AES(key)
                    this._prev = new Buffer(iv.length)
                    iv.copy(this._prev)
                    this._mode = mode
                    this._autopadding = true
                }
                Cipher.prototype._update = function (data) {
                    this._cache.add(data)
                    var chunk
                    var thing
                    var out = []
                    while ((chunk = this._cache.get())) {
                        thing = this._mode.encrypt(this, chunk)
                        out.push(thing)
                    }
                    return Buffer.concat(out)
                }
                Cipher.prototype._final = function () {
                    var chunk = this._cache.flush()
                    if (this._autopadding) {
                        chunk = this._mode.encrypt(this, chunk)
                        this._cipher.scrub()
                        return chunk
                    } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
                        this._cipher.scrub()
                        throw new Error('data not multiple of block length')
                    }
                }
                Cipher.prototype.setAutoPadding = function (setTo) {
                    this._autopadding = !!setTo
                }
                
                function Splitter() {
                    if (!(this instanceof Splitter)) {
                        return new Splitter()
                    }
                    this.cache = new Buffer('')
                }
                Splitter.prototype.add = function (data) {
                    this.cache = Buffer.concat([this.cache, data])
                }
                
                Splitter.prototype.get = function () {
                    if (this.cache.length > 15) {
                        var out = this.cache.slice(0, 16)
                        this.cache = this.cache.slice(16)
                        return out
                    }
                    return null
                }
                Splitter.prototype.flush = function () {
                    var len = 16 - this.cache.length
                    var padBuff = new Buffer(len)
                    
                    var i = -1
                    while (++i < len) {
                        padBuff.writeUInt8(len, i)
                    }
                    var out = Buffer.concat([this.cache, padBuff])
                    return out
                }
                var modelist = {
                    ECB: require('./modes/ecb'),
                    CBC: require('./modes/cbc'),
                    CFB: require('./modes/cfb'),
                    CFB8: require('./modes/cfb8'),
                    CFB1: require('./modes/cfb1'),
                    OFB: require('./modes/ofb'),
                    CTR: require('./modes/ctr'),
                    GCM: require('./modes/ctr')
                }
                
                function createCipheriv(suite, password, iv) {
                    var config = modes[suite.toLowerCase()]
                    if (!config) {
                        throw new TypeError('invalid suite type')
                    }
                    if (typeof iv === 'string') {
                        iv = new Buffer(iv)
                    }
                    if (typeof password === 'string') {
                        password = new Buffer(password)
                    }
                    if (password.length !== config.key / 8) {
                        throw new TypeError('invalid key length ' + password.length)
                    }
                    if (iv.length !== config.iv) {
                        throw new TypeError('invalid iv length ' + iv.length)
                    }
                    if (config.type === 'stream') {
                        return new StreamCipher(modelist[config.mode], password, iv)
                    } else if (config.type === 'auth') {
                        return new AuthCipher(modelist[config.mode], password, iv)
                    }
                    return new Cipher(modelist[config.mode], password, iv)
                }
                function createCipher(suite, password) {
                    var config = modes[suite.toLowerCase()]
                    if (!config) {
                        throw new TypeError('invalid suite type')
                    }
                    var keys = ebtk(password, config.key, config.iv)
                    return createCipheriv(suite, keys.key, keys.iv)
                }
                
                exports.createCipheriv = createCipheriv
                exports.createCipher = createCipher

            }).call(this, require("buffer").Buffer)
        }, { "./EVP_BytesToKey": 177, "./aes": 178, "./authCipher": 179, "./cipherBase": 181, "./modes": 185, "./modes/cbc": 186, "./modes/cfb": 187, "./modes/cfb1": 188, "./modes/cfb8": 189, "./modes/ctr": 190, "./modes/ecb": 191, "./modes/ofb": 192, "./streamCipher": 193, "buffer": 172, "inherits": 318 }], 184: [function (require, module, exports) {
            (function (Buffer) {
                var zeros = new Buffer(16)
                zeros.fill(0)
                module.exports = GHASH
                function GHASH(key) {
                    this.h = key
                    this.state = new Buffer(16)
                    this.state.fill(0)
                    this.cache = new Buffer('')
                }
                // from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
                // by Juho VÃ¤hÃ¤-Herttua
                GHASH.prototype.ghash = function (block) {
                    var i = -1
                    while (++i < block.length) {
                        this.state[i] ^= block[i]
                    }
                    this._multiply()
                }
                
                GHASH.prototype._multiply = function () {
                    var Vi = toArray(this.h)
                    var Zi = [0, 0, 0, 0]
                    var j, xi, lsb_Vi
                    var i = -1
                    while (++i < 128) {
                        xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
                        if (xi) {
                            // Z_i+1 = Z_i ^ V_i
                            Zi = xor(Zi, Vi)
                        }
                        
                        // Store the value of LSB(V_i)
                        lsb_Vi = (Vi[3] & 1) !== 0
                        
                        // V_i+1 = V_i >> 1
                        for (j = 3; j > 0; j--) {
                            Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
                        }
                        Vi[0] = Vi[0] >>> 1
                        
                        // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
                        if (lsb_Vi) {
                            Vi[0] = Vi[0] ^ (0xe1 << 24)
                        }
                    }
                    this.state = fromArray(Zi)
                }
                GHASH.prototype.update = function (buf) {
                    this.cache = Buffer.concat([this.cache, buf])
                    var chunk
                    while (this.cache.length >= 16) {
                        chunk = this.cache.slice(0, 16)
                        this.cache = this.cache.slice(16)
                        this.ghash(chunk)
                    }
                }
                GHASH.prototype.final = function (abl, bl) {
                    if (this.cache.length) {
                        this.ghash(Buffer.concat([this.cache, zeros], 16))
                    }
                    this.ghash(fromArray([
                        0, abl,
                        0, bl
                    ]))
                    return this.state
                }
                
                function toArray(buf) {
                    return [
                        buf.readUInt32BE(0),
                        buf.readUInt32BE(4),
                        buf.readUInt32BE(8),
                        buf.readUInt32BE(12)
                    ]
                }
                function fromArray(out) {
                    out = out.map(fixup_uint32)
                    var buf = new Buffer(16)
                    buf.writeUInt32BE(out[0], 0)
                    buf.writeUInt32BE(out[1], 4)
                    buf.writeUInt32BE(out[2], 8)
                    buf.writeUInt32BE(out[3], 12)
                    return buf
                }
                var uint_max = Math.pow(2, 32)
                function fixup_uint32(x) {
                    var ret, x_pos
                    ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
                    return ret
                }
                function xor(a, b) {
                    return [
                        a[0] ^ b[0],
                        a[1] ^ b[1],
                        a[2] ^ b[2],
                        a[3] ^ b[3]
                    ]
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 185: [function (require, module, exports) {
            exports['aes-128-ecb'] = {
                cipher: 'AES',
                key: 128,
                iv: 0,
                mode: 'ECB',
                type: 'block'
            }
            exports['aes-192-ecb'] = {
                cipher: 'AES',
                key: 192,
                iv: 0,
                mode: 'ECB',
                type: 'block'
            }
            exports['aes-256-ecb'] = {
                cipher: 'AES',
                key: 256,
                iv: 0,
                mode: 'ECB',
                type: 'block'
            }
            exports['aes-128-cbc'] = {
                cipher: 'AES',
                key: 128,
                iv: 16,
                mode: 'CBC',
                type: 'block'
            }
            exports['aes-192-cbc'] = {
                cipher: 'AES',
                key: 192,
                iv: 16,
                mode: 'CBC',
                type: 'block'
            }
            exports['aes-256-cbc'] = {
                cipher: 'AES',
                key: 256,
                iv: 16,
                mode: 'CBC',
                type: 'block'
            }
            exports['aes128'] = exports['aes-128-cbc']
            exports['aes192'] = exports['aes-192-cbc']
            exports['aes256'] = exports['aes-256-cbc']
            exports['aes-128-cfb'] = {
                cipher: 'AES',
                key: 128,
                iv: 16,
                mode: 'CFB',
                type: 'stream'
            }
            exports['aes-192-cfb'] = {
                cipher: 'AES',
                key: 192,
                iv: 16,
                mode: 'CFB',
                type: 'stream'
            }
            exports['aes-256-cfb'] = {
                cipher: 'AES',
                key: 256,
                iv: 16,
                mode: 'CFB',
                type: 'stream'
            }
            exports['aes-128-cfb8'] = {
                cipher: 'AES',
                key: 128,
                iv: 16,
                mode: 'CFB8',
                type: 'stream'
            }
            exports['aes-192-cfb8'] = {
                cipher: 'AES',
                key: 192,
                iv: 16,
                mode: 'CFB8',
                type: 'stream'
            }
            exports['aes-256-cfb8'] = {
                cipher: 'AES',
                key: 256,
                iv: 16,
                mode: 'CFB8',
                type: 'stream'
            }
            exports['aes-128-cfb1'] = {
                cipher: 'AES',
                key: 128,
                iv: 16,
                mode: 'CFB1',
                type: 'stream'
            }
            exports['aes-192-cfb1'] = {
                cipher: 'AES',
                key: 192,
                iv: 16,
                mode: 'CFB1',
                type: 'stream'
            }
            exports['aes-256-cfb1'] = {
                cipher: 'AES',
                key: 256,
                iv: 16,
                mode: 'CFB1',
                type: 'stream'
            }
            exports['aes-128-ofb'] = {
                cipher: 'AES',
                key: 128,
                iv: 16,
                mode: 'OFB',
                type: 'stream'
            }
            exports['aes-192-ofb'] = {
                cipher: 'AES',
                key: 192,
                iv: 16,
                mode: 'OFB',
                type: 'stream'
            }
            exports['aes-256-ofb'] = {
                cipher: 'AES',
                key: 256,
                iv: 16,
                mode: 'OFB',
                type: 'stream'
            }
            exports['aes-128-ctr'] = {
                cipher: 'AES',
                key: 128,
                iv: 16,
                mode: 'CTR',
                type: 'stream'
            }
            exports['aes-192-ctr'] = {
                cipher: 'AES',
                key: 192,
                iv: 16,
                mode: 'CTR',
                type: 'stream'
            }
            exports['aes-256-ctr'] = {
                cipher: 'AES',
                key: 256,
                iv: 16,
                mode: 'CTR',
                type: 'stream'
            }
            exports['aes-128-gcm'] = {
                cipher: 'AES',
                key: 128,
                iv: 12,
                mode: 'GCM',
                type: 'auth'
            }
            exports['aes-192-gcm'] = {
                cipher: 'AES',
                key: 192,
                iv: 12,
                mode: 'GCM',
                type: 'auth'
            }
            exports['aes-256-gcm'] = {
                cipher: 'AES',
                key: 256,
                iv: 12,
                mode: 'GCM',
                type: 'auth'
            }

        }, {}], 186: [function (require, module, exports) {
            var xor = require('../xor')
            exports.encrypt = function (self, block) {
                var data = xor(block, self._prev)
                self._prev = self._cipher.encryptBlock(data)
                return self._prev
            }
            exports.decrypt = function (self, block) {
                var pad = self._prev
                self._prev = block
                var out = self._cipher.decryptBlock(block)
                return xor(out, pad)
            }

        }, { "../xor": 194 }], 187: [function (require, module, exports) {
            (function (Buffer) {
                var xor = require('../xor')
                exports.encrypt = function (self, data, decrypt) {
                    var out = new Buffer('')
                    var len
                    while (data.length) {
                        if (self._cache.length === 0) {
                            self._cache = self._cipher.encryptBlock(self._prev)
                            self._prev = new Buffer('')
                        }
                        if (self._cache.length <= data.length) {
                            len = self._cache.length
                            out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
                            data = data.slice(len)
                        } else {
                            out = Buffer.concat([out, encryptStart(self, data, decrypt)])
                            break
                        }
                    }
                    return out
                }
                function encryptStart(self, data, decrypt) {
                    var len = data.length
                    var out = xor(data, self._cache)
                    self._cache = self._cache.slice(len)
                    self._prev = Buffer.concat([self._prev, decrypt ? data : out])
                    return out
                }

            }).call(this, require("buffer").Buffer)
        }, { "../xor": 194, "buffer": 172 }], 188: [function (require, module, exports) {
            (function (Buffer) {
                function encryptByte(self, byteParam, decrypt) {
                    var pad
                    var i = -1
                    var len = 8
                    var out = 0
                    var bit, value
                    while (++i < len) {
                        pad = self._cipher.encryptBlock(self._prev)
                        bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
                        value = pad[0] ^ bit
                        out += ((value & 0x80) >> (i % 8))
                        self._prev = shiftIn(self._prev, decrypt ? bit : value)
                    }
                    return out
                }
                exports.encrypt = function (self, chunk, decrypt) {
                    var len = chunk.length
                    var out = new Buffer(len)
                    var i = -1
                    while (++i < len) {
                        out[i] = encryptByte(self, chunk[i], decrypt)
                    }
                    return out
                }
                function shiftIn(buffer, value) {
                    var len = buffer.length
                    var i = -1
                    var out = new Buffer(buffer.length)
                    buffer = Buffer.concat([buffer, new Buffer([value])])
                    while (++i < len) {
                        out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
                    }
                    return out
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 189: [function (require, module, exports) {
            (function (Buffer) {
                function encryptByte(self, byteParam, decrypt) {
                    var pad = self._cipher.encryptBlock(self._prev)
                    var out = pad[0] ^ byteParam
                    self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
                    return out
                }
                exports.encrypt = function (self, chunk, decrypt) {
                    var len = chunk.length
                    var out = new Buffer(len)
                    var i = -1
                    while (++i < len) {
                        out[i] = encryptByte(self, chunk[i], decrypt)
                    }
                    return out
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 190: [function (require, module, exports) {
            (function (Buffer) {
                var xor = require('../xor')
                function getBlock(self) {
                    var out = self._cipher.encryptBlock(self._prev)
                    incr32(self._prev)
                    return out
                }
                exports.encrypt = function (self, chunk) {
                    while (self._cache.length < chunk.length) {
                        self._cache = Buffer.concat([self._cache, getBlock(self)])
                    }
                    var pad = self._cache.slice(0, chunk.length)
                    self._cache = self._cache.slice(chunk.length)
                    return xor(chunk, pad)
                }
                function incr32(iv) {
                    var len = iv.length
                    var item
                    while (len--) {
                        item = iv.readUInt8(len)
                        if (item === 255) {
                            iv.writeUInt8(0, len)
                        } else {
                            item++
                            iv.writeUInt8(item, len)
                            break
                        }
                    }
                }

            }).call(this, require("buffer").Buffer)
        }, { "../xor": 194, "buffer": 172 }], 191: [function (require, module, exports) {
            exports.encrypt = function (self, block) {
                return self._cipher.encryptBlock(block)
            }
            exports.decrypt = function (self, block) {
                return self._cipher.decryptBlock(block)
            }

        }, {}], 192: [function (require, module, exports) {
            (function (Buffer) {
                var xor = require('../xor')
                function getBlock(self) {
                    self._prev = self._cipher.encryptBlock(self._prev)
                    return self._prev
                }
                exports.encrypt = function (self, chunk) {
                    while (self._cache.length < chunk.length) {
                        self._cache = Buffer.concat([self._cache, getBlock(self)])
                    }
                    var pad = self._cache.slice(0, chunk.length)
                    self._cache = self._cache.slice(chunk.length)
                    return xor(chunk, pad)
                }

            }).call(this, require("buffer").Buffer)
        }, { "../xor": 194, "buffer": 172 }], 193: [function (require, module, exports) {
            (function (Buffer) {
                var aes = require('./aes')
                var Transform = require('./cipherBase')
                var inherits = require('inherits')
                
                inherits(StreamCipher, Transform)
                module.exports = StreamCipher
                function StreamCipher(mode, key, iv, decrypt) {
                    if (!(this instanceof StreamCipher)) {
                        return new StreamCipher(mode, key, iv)
                    }
                    Transform.call(this)
                    this._cipher = new aes.AES(key)
                    this._prev = new Buffer(iv.length)
                    this._cache = new Buffer('')
                    this._secCache = new Buffer('')
                    this._decrypt = decrypt
                    iv.copy(this._prev)
                    this._mode = mode
                }
                StreamCipher.prototype._update = function (chunk) {
                    return this._mode.encrypt(this, chunk, this._decrypt)
                }
                StreamCipher.prototype._final = function () {
                    this._cipher.scrub()
                }

            }).call(this, require("buffer").Buffer)
        }, { "./aes": 178, "./cipherBase": 181, "buffer": 172, "inherits": 318 }], 194: [function (require, module, exports) {
            (function (Buffer) {
                module.exports = xor
                function xor(a, b) {
                    var len = Math.min(a.length, b.length)
                    var out = new Buffer(len)
                    var i = -1
                    while (++i < len) {
                        out.writeUInt8(a[i] ^ b[i], i)
                    }
                    return out
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 195: [function (require, module, exports) {
            (function (Buffer) {
                'use strict'
                exports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {
                    sign: 'rsa',
                    hash: 'sha224',
                    id: new Buffer('302d300d06096086480165030402040500041c', 'hex')
                }
                exports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {
                    sign: 'rsa',
                    hash: 'sha256',
                    id: new Buffer('3031300d060960864801650304020105000420', 'hex')
                }
                exports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {
                    sign: 'rsa',
                    hash: 'sha384',
                    id: new Buffer('3041300d060960864801650304020205000430', 'hex')
                }
                exports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {
                    sign: 'rsa',
                    hash: 'sha512',
                    id: new Buffer('3051300d060960864801650304020305000440', 'hex')
                }
                exports['RSA-SHA1'] = {
                    sign: 'rsa',
                    hash: 'sha1',
                    id: new Buffer('3021300906052b0e03021a05000414', 'hex')
                }
                exports['ecdsa-with-SHA1'] = {
                    sign: 'ecdsa',
                    hash: 'sha1',
                    id: new Buffer('', 'hex')
                }
                exports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {
                    sign: 'dsa',
                    hash: 'sha1',
                    id: new Buffer('', 'hex')
                }
                exports['DSA-SHA224'] = exports['DSA-WITH-SHA224'] = {
                    sign: 'dsa',
                    hash: 'sha224',
                    id: new Buffer('', 'hex')
                }
                exports['DSA-SHA256'] = exports['DSA-WITH-SHA256'] = {
                    sign: 'dsa',
                    hash: 'sha256',
                    id: new Buffer('', 'hex')
                }
                exports['DSA-SHA384'] = exports['DSA-WITH-SHA384'] = {
                    sign: 'dsa',
                    hash: 'sha384',
                    id: new Buffer('', 'hex')
                }
                exports['DSA-SHA512'] = exports['DSA-WITH-SHA512'] = {
                    sign: 'dsa',
                    hash: 'sha512',
                    id: new Buffer('', 'hex')
                }
                exports['DSA-RIPEMD160'] = {
                    sign: 'dsa',
                    hash: 'rmd160',
                    id: new Buffer('', 'hex')
                }
                exports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {
                    sign: 'rsa',
                    hash: 'rmd160',
                    id: new Buffer('3021300906052b2403020105000414', 'hex')
                }
                exports['RSA-MD5'] = exports.md5WithRSAEncryption = {
                    sign: 'rsa',
                    hash: 'md5',
                    id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 196: [function (require, module, exports) {
            (function (Buffer) {
                'use strict'
                var sign = require('./sign')
                var verify = require('./verify')
                var stream = require('stream')
                var inherits = require('inherits')
                var _algos = require('./algos')
                var createHash = require('create-hash')
                var algos = {}
                Object.keys(_algos).forEach(function (key) {
                    algos[key] = algos[key.toLowerCase()] = _algos[key]
                })
                
                exports.createSign = exports.Sign = createSign
                
                function createSign(algorithm) {
                    return new Sign(algorithm)
                }
                
                exports.createVerify = exports.Verify = createVerify
                
                function createVerify(algorithm) {
                    return new Verify(algorithm)
                }
                
                inherits(Sign, stream.Writable)
                
                function Sign(algorithm) {
                    stream.Writable.call(this)
                    var data = algos[algorithm]
                    if (!data)
                        throw new Error('Unknown message digest')
                    
                    this._hashType = data.hash
                    this._hash = createHash(data.hash)
                    this._tag = data.id
                    this._signType = data.sign
                }
                
                Sign.prototype._write = function _write(data, _, done) {
                    this._hash.update(data)
                    done()
                }
                
                Sign.prototype.update = function update(data, enc) {
                    if (typeof data === 'string')
                        data = new Buffer(data, enc)
                    this._hash.update(data)
                    return this
                }
                
                Sign.prototype.sign = function signMethod(key, enc) {
                    this.end()
                    var hash = this._hash.digest()
                    var sig = sign(Buffer.concat([this._tag, hash]), key, this._hashType, this._signType)
                    if (enc) {
                        sig = sig.toString(enc)
                    }
                    return sig
                }
                
                inherits(Verify, stream.Writable)
                function Verify(algorithm) {
                    stream.Writable.call(this)
                    var data = algos[algorithm]
                    if (!data)
                        throw new Error('Unknown message digest')
                    
                    this._hash = createHash(data.hash)
                    this._tag = data.id
                    this._signType = data.sign
                }
                
                Verify.prototype._write = function _write(data, _, done) {
                    this._hash.update(data)
                    done()
                }
                
                Verify.prototype.update = function update(data, enc) {
                    if (typeof data === 'string')
                        data = new Buffer(data, enc)
                    
                    this._hash.update(data)
                    return this
                }
                
                Verify.prototype.verify = function verifyMethod(key, sig, enc) {
                    this.end()
                    var hash = this._hash.digest()
                    if (typeof sig === 'string')
                        sig = new Buffer(sig, enc)
                    
                    return verify(sig, Buffer.concat([this._tag, hash]), key, this._signType)
                }

            }).call(this, require("buffer").Buffer)
        }, { "./algos": 195, "./sign": 241, "./verify": 242, "buffer": 172, "create-hash": 267, "inherits": 318, "stream": 338 }], 197: [function (require, module, exports) {
            'use strict'
            exports['1.3.132.0.10'] = 'secp256k1'
            
            exports['1.3.132.0.33'] = 'p224'
            
            exports['1.2.840.10045.3.1.1'] = 'p192'
            
            exports['1.2.840.10045.3.1.7'] = 'p256'

        }, {}], 198: [function (require, module, exports) {
            (function (module, exports) {
                
                'use strict';
                
                // Utils
                
                function assert(val, msg) {
                    if (!val)
                        throw new Error(msg || 'Assertion failed');
                }
                
                // Could use `inherits` module, but don't want to move from single file
                // architecture yet.
                function inherits(ctor, superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function () { };
                    TempCtor.prototype = superCtor.prototype;
                    ctor.prototype = new TempCtor();
                    ctor.prototype.constructor = ctor;
                }
                
                // BN
                
                function BN(number, base, endian) {
                    // May be `new BN(bn)` ?
                    if (number !== null &&
      typeof number === 'object' &&
      Array.isArray(number.words)) {
                        return number;
                    }
                    
                    this.sign = false;
                    this.words = null;
                    this.length = 0;
                    
                    // Reduction context
                    this.red = null;
                    
                    if (base === 'le' || base === 'be') {
                        endian = base;
                        base = 10;
                    }
                    
                    if (number !== null)
                        this._init(number || 0, base || 10, endian || 'be');
                }
                if (typeof module === 'object')
                    module.exports = BN;
                else
                    exports.BN = BN;
                
                BN.BN = BN;
                BN.wordSize = 26;
                
                BN.prototype._init = function init(number, base, endian) {
                    if (typeof number === 'number') {
                        return this._initNumber(number, base, endian);
                    } else if (typeof number === 'object') {
                        return this._initArray(number, base, endian);
                    }
                    if (base === 'hex')
                        base = 16;
                    assert(base === (base | 0) && base >= 2 && base <= 36);
                    
                    number = number.toString().replace(/\s+/g, '');
                    var start = 0;
                    if (number[0] === '-')
                        start++;
                    
                    if (base === 16)
                        this._parseHex(number, start);
                    else
                        this._parseBase(number, base, start);
                    
                    if (number[0] === '-')
                        this.sign = true;
                    
                    this.strip();
                    
                    if (endian !== 'le')
                        return;
                    
                    this._initArray(this.toArray(), base, endian);
                };
                
                BN.prototype._initNumber = function _initNumber(number, base, endian) {
                    if (number < 0) {
                        this.sign = true;
                        number = -number;
                    }
                    if (number < 0x4000000) {
                        this.words = [number & 0x3ffffff];
                        this.length = 1;
                    } else if (number < 0x10000000000000) {
                        this.words = [
                            number & 0x3ffffff,
                            (number / 0x4000000) & 0x3ffffff
                        ];
                        this.length = 2;
                    } else {
                        assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
                        this.words = [
                            number & 0x3ffffff,
                            (number / 0x4000000) & 0x3ffffff,
                            1
                        ];
                        this.length = 3;
                    }
                    
                    if (endian !== 'le')
                        return;
                    
                    // Reverse the bytes
                    this._initArray(this.toArray(), base, endian);
                };
                
                BN.prototype._initArray = function _initArray(number, base, endian) {
                    // Perhaps a Uint8Array
                    assert(typeof number.length === 'number');
                    if (number.length <= 0) {
                        this.words = [0];
                        this.length = 1;
                        return this;
                    }
                    
                    this.length = Math.ceil(number.length / 3);
                    this.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++)
                        this.words[i] = 0;
                    
                    var off = 0;
                    if (endian === 'be') {
                        for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
                            var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
                            this.words[j] |= (w << off) & 0x3ffffff;
                            this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
                            off += 24;
                            if (off >= 26) {
                                off -= 26;
                                j++;
                            }
                        }
                    } else if (endian === 'le') {
                        for (var i = 0, j = 0; i < number.length; i += 3) {
                            var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
                            this.words[j] |= (w << off) & 0x3ffffff;
                            this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
                            off += 24;
                            if (off >= 26) {
                                off -= 26;
                                j++;
                            }
                        }
                    }
                    return this.strip();
                };
                
                function parseHex(str, start, end) {
                    var r = 0;
                    var len = Math.min(str.length, end);
                    for (var i = start; i < len; i++) {
                        var c = str.charCodeAt(i) - 48;
                        
                        r <<= 4;
                        
                        // 'a' - 'f'
                        if (c >= 49 && c <= 54)
                            r |= c - 49 + 0xa;

    // 'A' - 'F'
                        else if (c >= 17 && c <= 22)
                            r |= c - 17 + 0xa;

    // '0' - '9'
                        else
                            r |= c & 0xf;
                    }
                    return r;
                }
                
                BN.prototype._parseHex = function _parseHex(number, start) {
                    // Create possibly bigger array to ensure that it fits the number
                    this.length = Math.ceil((number.length - start) / 6);
                    this.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++)
                        this.words[i] = 0;
                    
                    // Scan 24-bit chunks and add them to the number
                    var off = 0;
                    for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
                        var w = parseHex(number, i, i + 6);
                        this.words[j] |= (w << off) & 0x3ffffff;
                        this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
                        off += 24;
                        if (off >= 26) {
                            off -= 26;
                            j++;
                        }
                    }
                    if (i + 6 !== start) {
                        var w = parseHex(number, start, i + 6);
                        this.words[j] |= (w << off) & 0x3ffffff;
                        this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
                    }
                    this.strip();
                };
                
                function parseBase(str, start, end, mul) {
                    var r = 0;
                    var len = Math.min(str.length, end);
                    for (var i = start; i < len; i++) {
                        var c = str.charCodeAt(i) - 48;
                        
                        r *= mul;
                        
                        // 'a'
                        if (c >= 49)
                            r += c - 49 + 0xa;

    // 'A'
                        else if (c >= 17)
                            r += c - 17 + 0xa;

    // '0' - '9'
                        else
                            r += c;
                    }
                    return r;
                }
                
                BN.prototype._parseBase = function _parseBase(number, base, start) {
                    // Initialize as zero
                    this.words = [0];
                    this.length = 1;
                    
                    // Find length of limb in base
                    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
                        limbLen++;
                    limbLen--;
                    limbPow = (limbPow / base) | 0;
                    
                    var total = number.length - start;
                    var mod = total % limbLen;
                    var end = Math.min(total, total - mod) + start;
                    
                    var word = 0;
                    for (var i = start; i < end; i += limbLen) {
                        word = parseBase(number, i, i + limbLen, base);
                        
                        this.imuln(limbPow);
                        if (this.words[0] + word < 0x4000000)
                            this.words[0] += word;
                        else
                            this._iaddn(word);
                    }
                    
                    if (mod !== 0) {
                        var pow = 1;
                        var word = parseBase(number, i, number.length, base);
                        
                        for (var i = 0; i < mod; i++)
                            pow *= base;
                        this.imuln(pow);
                        if (this.words[0] + word < 0x4000000)
                            this.words[0] += word;
                        else
                            this._iaddn(word);
                    }
                };
                
                BN.prototype.copy = function copy(dest) {
                    dest.words = new Array(this.length);
                    for (var i = 0; i < this.length; i++)
                        dest.words[i] = this.words[i];
                    dest.length = this.length;
                    dest.sign = this.sign;
                    dest.red = this.red;
                };
                
                BN.prototype.clone = function clone() {
                    var r = new BN(null);
                    this.copy(r);
                    return r;
                };
                
                // Remove leading `0` from `this`
                BN.prototype.strip = function strip() {
                    while (this.length > 1 && this.words[this.length - 1] === 0)
                        this.length--;
                    return this._normSign();
                };
                
                BN.prototype._normSign = function _normSign() {
                    // -0 = 0
                    if (this.length === 1 && this.words[0] === 0)
                        this.sign = false;
                    return this;
                };
                
                BN.prototype.inspect = function inspect() {
                    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
                };
                
                /*

var zeros = [];
var groupSizes = [];
var groupBases = [];

var s = '';
var i = -1;
while (++i < BN.wordSize) {
  zeros[i] = s;
  s += '0';
}
groupSizes[0] = 0;
groupSizes[1] = 0;
groupBases[0] = 0;
groupBases[1] = 0;
var base = 2 - 1;
while (++base < 36 + 1) {
  var groupSize = 0;
  var groupBase = 1;
  while (groupBase < (1 << BN.wordSize) / base) {
    groupBase *= base;
    groupSize += 1;
  }
  groupSizes[base] = groupSize;
  groupBases[base] = groupBase;
}

*/

var zeros = [
                    '',
                    '0',
                    '00',
                    '000',
                    '0000',
                    '00000',
                    '000000',
                    '0000000',
                    '00000000',
                    '000000000',
                    '0000000000',
                    '00000000000',
                    '000000000000',
                    '0000000000000',
                    '00000000000000',
                    '000000000000000',
                    '0000000000000000',
                    '00000000000000000',
                    '000000000000000000',
                    '0000000000000000000',
                    '00000000000000000000',
                    '000000000000000000000',
                    '0000000000000000000000',
                    '00000000000000000000000',
                    '000000000000000000000000',
                    '0000000000000000000000000'
                ];
                
                var groupSizes = [
                    0, 0,
                    25, 16, 12, 11, 10, 9, 8,
                    8, 7, 7, 7, 7, 6, 6,
                    6, 6, 6, 6, 6, 5, 5,
                    5, 5, 5, 5, 5, 5, 5,
                    5, 5, 5, 5, 5, 5, 5
                ];
                
                var groupBases = [
                    0, 0,
                    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
                    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
                    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
                    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
                    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
                ];
                
                BN.prototype.toString = function toString(base, padding) {
                    base = base || 10;
                    if (base === 16 || base === 'hex') {
                        var out = '';
                        var off = 0;
                        var padding = padding | 0 || 1;
                        var carry = 0;
                        for (var i = 0; i < this.length; i++) {
                            var w = this.words[i];
                            var word = (((w << off) | carry) & 0xffffff).toString(16);
                            carry = (w >>> (24 - off)) & 0xffffff;
                            if (carry !== 0 || i !== this.length - 1)
                                out = zeros[6 - word.length] + word + out;
                            else
                                out = word + out;
                            off += 2;
                            if (off >= 26) {
                                off -= 26;
                                i--;
                            }
                        }
                        if (carry !== 0)
                            out = carry.toString(16) + out;
                        while (out.length % padding !== 0)
                            out = '0' + out;
                        if (this.sign)
                            out = '-' + out;
                        return out;
                    } else if (base === (base | 0) && base >= 2 && base <= 36) {
                        // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
                        var groupSize = groupSizes[base];
                        // var groupBase = Math.pow(base, groupSize);
                        var groupBase = groupBases[base];
                        var out = '';
                        var c = this.clone();
                        c.sign = false;
                        while (c.cmpn(0) !== 0) {
                            var r = c.modn(groupBase).toString(base);
                            c = c.idivn(groupBase);
                            
                            if (c.cmpn(0) !== 0)
                                out = zeros[groupSize - r.length] + r + out;
                            else
                                out = r + out;
                        }
                        if (this.cmpn(0) === 0)
                            out = '0' + out;
                        if (this.sign)
                            out = '-' + out;
                        return out;
                    } else {
                        assert(false, 'Base should be between 2 and 36');
                    }
                };
                
                BN.prototype.toJSON = function toJSON() {
                    return this.toString(16);
                };
                
                BN.prototype.toArray = function toArray(endian) {
                    this.strip();
                    var res = new Array(this.byteLength());
                    res[0] = 0;
                    
                    var q = this.clone();
                    if (endian !== 'le') {
                        // Assume big-endian
                        for (var i = 0; q.cmpn(0) !== 0; i++) {
                            var b = q.andln(0xff);
                            q.ishrn(8);
                            
                            res[res.length - i - 1] = b;
                        }
                    } else {
                        // Assume little-endian
                        for (var i = 0; q.cmpn(0) !== 0; i++) {
                            var b = q.andln(0xff);
                            q.ishrn(8);
                            
                            res[i] = b;
                        }
                    }
                    
                    return res;
                };
                
                if (Math.clz32) {
                    BN.prototype._countBits = function _countBits(w) {
                        return 32 - Math.clz32(w);
                    };
                } else {
                    BN.prototype._countBits = function _countBits(w) {
                        var t = w;
                        var r = 0;
                        if (t >= 0x1000) {
                            r += 13;
                            t >>>= 13;
                        }
                        if (t >= 0x40) {
                            r += 7;
                            t >>>= 7;
                        }
                        if (t >= 0x8) {
                            r += 4;
                            t >>>= 4;
                        }
                        if (t >= 0x02) {
                            r += 2;
                            t >>>= 2;
                        }
                        return r + t;
                    };
                }
                
                BN.prototype._zeroBits = function _zeroBits(w) {
                    // Short-cut
                    if (w === 0)
                        return 26;
                    
                    var t = w;
                    var r = 0;
                    if ((t & 0x1fff) === 0) {
                        r += 13;
                        t >>>= 13;
                    }
                    if ((t & 0x7f) === 0) {
                        r += 7;
                        t >>>= 7;
                    }
                    if ((t & 0xf) === 0) {
                        r += 4;
                        t >>>= 4;
                    }
                    if ((t & 0x3) === 0) {
                        r += 2;
                        t >>>= 2;
                    }
                    if ((t & 0x1) === 0)
                        r++;
                    return r;
                };
                
                // Return number of used bits in a BN
                BN.prototype.bitLength = function bitLength() {
                    var hi = 0;
                    var w = this.words[this.length - 1];
                    var hi = this._countBits(w);
                    return (this.length - 1) * 26 + hi;
                };
                
                // Number of trailing zero bits
                BN.prototype.zeroBits = function zeroBits() {
                    if (this.cmpn(0) === 0)
                        return 0;
                    
                    var r = 0;
                    for (var i = 0; i < this.length; i++) {
                        var b = this._zeroBits(this.words[i]);
                        r += b;
                        if (b !== 26)
                            break;
                    }
                    return r;
                };
                
                BN.prototype.byteLength = function byteLength() {
                    return Math.ceil(this.bitLength() / 8);
                };
                
                // Return negative clone of `this`
                BN.prototype.neg = function neg() {
                    if (this.cmpn(0) === 0)
                        return this.clone();
                    
                    var r = this.clone();
                    r.sign = !this.sign;
                    return r;
                };
                
                
                // Or `num` with `this` in-place
                BN.prototype.ior = function ior(num) {
                    this.sign = this.sign || num.sign;
                    
                    while (this.length < num.length)
                        this.words[this.length++] = 0;
                    
                    for (var i = 0; i < num.length; i++)
                        this.words[i] = this.words[i] | num.words[i];
                    
                    return this.strip();
                };
                
                
                // Or `num` with `this`
                BN.prototype.or = function or(num) {
                    if (this.length > num.length)
                        return this.clone().ior(num);
                    else
                        return num.clone().ior(this);
                };
                
                
                // And `num` with `this` in-place
                BN.prototype.iand = function iand(num) {
                    this.sign = this.sign && num.sign;
                    
                    // b = min-length(num, this)
                    var b;
                    if (this.length > num.length)
                        b = num;
                    else
                        b = this;
                    
                    for (var i = 0; i < b.length; i++)
                        this.words[i] = this.words[i] & num.words[i];
                    
                    this.length = b.length;
                    
                    return this.strip();
                };
                
                
                // And `num` with `this`
                BN.prototype.and = function and(num) {
                    if (this.length > num.length)
                        return this.clone().iand(num);
                    else
                        return num.clone().iand(this);
                };
                
                
                // Xor `num` with `this` in-place
                BN.prototype.ixor = function ixor(num) {
                    this.sign = this.sign || num.sign;
                    
                    // a.length > b.length
                    var a;
                    var b;
                    if (this.length > num.length) {
                        a = this;
                        b = num;
                    } else {
                        a = num;
                        b = this;
                    }
                    
                    for (var i = 0; i < b.length; i++)
                        this.words[i] = a.words[i] ^ b.words[i];
                    
                    if (this !== a)
                        for (; i < a.length; i++)
                            this.words[i] = a.words[i];
                    
                    this.length = a.length;
                    
                    return this.strip();
                };
                
                
                // Xor `num` with `this`
                BN.prototype.xor = function xor(num) {
                    if (this.length > num.length)
                        return this.clone().ixor(num);
                    else
                        return num.clone().ixor(this);
                };
                
                
                // Set `bit` of `this`
                BN.prototype.setn = function setn(bit, val) {
                    assert(typeof bit === 'number' && bit >= 0);
                    
                    var off = (bit / 26) | 0;
                    var wbit = bit % 26;
                    
                    while (this.length <= off)
                        this.words[this.length++] = 0;
                    
                    if (val)
                        this.words[off] = this.words[off] | (1 << wbit);
                    else
                        this.words[off] = this.words[off] & ~(1 << wbit);
                    
                    return this.strip();
                };
                
                
                // Add `num` to `this` in-place
                BN.prototype.iadd = function iadd(num) {
                    // negative + positive
                    if (this.sign && !num.sign) {
                        this.sign = false;
                        var r = this.isub(num);
                        this.sign = !this.sign;
                        return this._normSign();

  // positive + negative
                    } else if (!this.sign && num.sign) {
                        num.sign = false;
                        var r = this.isub(num);
                        num.sign = true;
                        return r._normSign();
                    }
                    
                    // a.length > b.length
                    var a;
                    var b;
                    if (this.length > num.length) {
                        a = this;
                        b = num;
                    } else {
                        a = num;
                        b = this;
                    }
                    
                    var carry = 0;
                    for (var i = 0; i < b.length; i++) {
                        var r = a.words[i] + b.words[i] + carry;
                        this.words[i] = r & 0x3ffffff;
                        carry = r >>> 26;
                    }
                    for (; carry !== 0 && i < a.length; i++) {
                        var r = a.words[i] + carry;
                        this.words[i] = r & 0x3ffffff;
                        carry = r >>> 26;
                    }
                    
                    this.length = a.length;
                    if (carry !== 0) {
                        this.words[this.length] = carry;
                        this.length++;
  // Copy the rest of the words
                    } else if (a !== this) {
                        for (; i < a.length; i++)
                            this.words[i] = a.words[i];
                    }
                    
                    return this;
                };
                
                // Add `num` to `this`
                BN.prototype.add = function add(num) {
                    if (num.sign && !this.sign) {
                        num.sign = false;
                        var res = this.sub(num);
                        num.sign = true;
                        return res;
                    } else if (!num.sign && this.sign) {
                        this.sign = false;
                        var res = num.sub(this);
                        this.sign = true;
                        return res;
                    }
                    
                    if (this.length > num.length)
                        return this.clone().iadd(num);
                    else
                        return num.clone().iadd(this);
                };
                
                // Subtract `num` from `this` in-place
                BN.prototype.isub = function isub(num) {
                    // this - (-num) = this + num
                    if (num.sign) {
                        num.sign = false;
                        var r = this.iadd(num);
                        num.sign = true;
                        return r._normSign();

  // -this - num = -(this + num)
                    } else if (this.sign) {
                        this.sign = false;
                        this.iadd(num);
                        this.sign = true;
                        return this._normSign();
                    }
                    
                    // At this point both numbers are positive
                    var cmp = this.cmp(num);
                    
                    // Optimization - zeroify
                    if (cmp === 0) {
                        this.sign = false;
                        this.length = 1;
                        this.words[0] = 0;
                        return this;
                    }
                    
                    // a > b
                    var a;
                    var b;
                    if (cmp > 0) {
                        a = this;
                        b = num;
                    } else {
                        a = num;
                        b = this;
                    }
                    
                    var carry = 0;
                    for (var i = 0; i < b.length; i++) {
                        var r = a.words[i] - b.words[i] + carry;
                        carry = r >> 26;
                        this.words[i] = r & 0x3ffffff;
                    }
                    for (; carry !== 0 && i < a.length; i++) {
                        var r = a.words[i] + carry;
                        carry = r >> 26;
                        this.words[i] = r & 0x3ffffff;
                    }
                    
                    // Copy rest of the words
                    if (carry === 0 && i < a.length && a !== this)
                        for (; i < a.length; i++)
                            this.words[i] = a.words[i];
                    this.length = Math.max(this.length, i);
                    
                    if (a !== this)
                        this.sign = true;
                    
                    return this.strip();
                };
                
                // Subtract `num` from `this`
                BN.prototype.sub = function sub(num) {
                    return this.clone().isub(num);
                };
                
                /*
// NOTE: This could be potentionally used to generate loop-less multiplications
function _genCombMulTo(alen, blen) {
  var len = alen + blen - 1;
  var src = [
    'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
        'mask = 0x3ffffff, shift = 0x4000000;',
    'out.length = ' + len + ';'
  ];
  for (var k = 0; k < len; k++) {
    var minJ = Math.max(0, k - alen + 1);
    var maxJ = Math.min(k, blen - 1);

    for (var j = minJ; j <= maxJ; j++) {
      var i = k - j;
      var mul = 'a[' + i + '] * b[' + j + ']';

      if (j === minJ) {
        src.push('w = ' + mul + ' + c;');
        src.push('c = (w / shift) | 0;');
      } else {
        src.push('w += ' + mul + ';');
        src.push('c += (w / shift) | 0;');
      }
      src.push('w &= mask;');
    }
    src.push('o[' + k + '] = w;');
  }
  src.push('if (c !== 0) {',
           '  o[' + k + '] = c;',
           '  out.length++;',
           '}',
           'return out;');

  return src.join('\n');
}
*/

BN.prototype._smallMulTo = function _smallMulTo(num, out) {
                    out.sign = num.sign !== this.sign;
                    out.length = this.length + num.length;
                    
                    var carry = 0;
                    for (var k = 0; k < out.length - 1; k++) {
                        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
                        // note that ncarry could be >= 0x3ffffff
                        var ncarry = carry >>> 26;
                        var rword = carry & 0x3ffffff;
                        var maxJ = Math.min(k, num.length - 1);
                        for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                            var i = k - j;
                            var a = this.words[i] | 0;
                            var b = num.words[j] | 0;
                            var r = a * b;
                            
                            var lo = r & 0x3ffffff;
                            ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
                            lo = (lo + rword) | 0;
                            rword = lo & 0x3ffffff;
                            ncarry = (ncarry + (lo >>> 26)) | 0;
                        }
                        out.words[k] = rword;
                        carry = ncarry;
                    }
                    if (carry !== 0) {
                        out.words[k] = carry;
                    } else {
                        out.length--;
                    }
                    
                    return out.strip();
                };
                
                BN.prototype._bigMulTo = function _bigMulTo(num, out) {
                    out.sign = num.sign !== this.sign;
                    out.length = this.length + num.length;
                    
                    var carry = 0;
                    var hncarry = 0;
                    for (var k = 0; k < out.length - 1; k++) {
                        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
                        // note that ncarry could be >= 0x3ffffff
                        var ncarry = hncarry;
                        hncarry = 0;
                        var rword = carry & 0x3ffffff;
                        var maxJ = Math.min(k, num.length - 1);
                        for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                            var i = k - j;
                            var a = this.words[i] | 0;
                            var b = num.words[j] | 0;
                            var r = a * b;
                            
                            var lo = r & 0x3ffffff;
                            ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
                            lo = (lo + rword) | 0;
                            rword = lo & 0x3ffffff;
                            ncarry = (ncarry + (lo >>> 26)) | 0;
                            
                            hncarry += ncarry >>> 26;
                            ncarry &= 0x3ffffff;
                        }
                        out.words[k] = rword;
                        carry = ncarry;
                        ncarry = hncarry;
                    }
                    if (carry !== 0) {
                        out.words[k] = carry;
                    } else {
                        out.length--;
                    }
                    
                    return out.strip();
                };
                
                BN.prototype.mulTo = function mulTo(num, out) {
                    var res;
                    if (this.length + num.length < 63)
                        res = this._smallMulTo(num, out);
                    else
                        res = this._bigMulTo(num, out);
                    return res;
                };
                
                // Multiply `this` by `num`
                BN.prototype.mul = function mul(num) {
                    var out = new BN(null);
                    out.words = new Array(this.length + num.length);
                    return this.mulTo(num, out);
                };
                
                // In-place Multiplication
                BN.prototype.imul = function imul(num) {
                    if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
                        this.words[0] = 0;
                        this.length = 1;
                        return this;
                    }
                    
                    var tlen = this.length;
                    var nlen = num.length;
                    
                    this.sign = num.sign !== this.sign;
                    this.length = this.length + num.length;
                    this.words[this.length - 1] = 0;
                    
                    for (var k = this.length - 2; k >= 0; k--) {
                        // Sum all words with the same `i + j = k` and accumulate `carry`,
                        // note that carry could be >= 0x3ffffff
                        var carry = 0;
                        var rword = 0;
                        var maxJ = Math.min(k, nlen - 1);
                        for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
                            var i = k - j;
                            var a = this.words[i];
                            var b = num.words[j];
                            var r = a * b;
                            
                            var lo = r & 0x3ffffff;
                            carry += (r / 0x4000000) | 0;
                            lo += rword;
                            rword = lo & 0x3ffffff;
                            carry += lo >>> 26;
                        }
                        this.words[k] = rword;
                        this.words[k + 1] += carry;
                        carry = 0;
                    }
                    
                    // Propagate overflows
                    var carry = 0;
                    for (var i = 1; i < this.length; i++) {
                        var w = this.words[i] + carry;
                        this.words[i] = w & 0x3ffffff;
                        carry = w >>> 26;
                    }
                    
                    return this.strip();
                };
                
                BN.prototype.imuln = function imuln(num) {
                    assert(typeof num === 'number');
                    
                    // Carry
                    var carry = 0;
                    for (var i = 0; i < this.length; i++) {
                        var w = this.words[i] * num;
                        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
                        carry >>= 26;
                        carry += (w / 0x4000000) | 0;
                        // NOTE: lo is 27bit maximum
                        carry += lo >>> 26;
                        this.words[i] = lo & 0x3ffffff;
                    }
                    
                    if (carry !== 0) {
                        this.words[i] = carry;
                        this.length++;
                    }
                    
                    return this;
                };
                
                // `this` * `this`
                BN.prototype.sqr = function sqr() {
                    return this.mul(this);
                };
                
                // `this` * `this` in-place
                BN.prototype.isqr = function isqr() {
                    return this.mul(this);
                };
                
                // Shift-left in-place
                BN.prototype.ishln = function ishln(bits) {
                    assert(typeof bits === 'number' && bits >= 0);
                    var r = bits % 26;
                    var s = (bits - r) / 26;
                    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
                    
                    if (r !== 0) {
                        var carry = 0;
                        for (var i = 0; i < this.length; i++) {
                            var newCarry = this.words[i] & carryMask;
                            var c = (this.words[i] - newCarry) << r;
                            this.words[i] = c | carry;
                            carry = newCarry >>> (26 - r);
                        }
                        if (carry) {
                            this.words[i] = carry;
                            this.length++;
                        }
                    }
                    
                    if (s !== 0) {
                        for (var i = this.length - 1; i >= 0; i--)
                            this.words[i + s] = this.words[i];
                        for (var i = 0; i < s; i++)
                            this.words[i] = 0;
                        this.length += s;
                    }
                    
                    return this.strip();
                };
                
                // Shift-right in-place
                // NOTE: `hint` is a lowest bit before trailing zeroes
                // NOTE: if `extended` is present - it will be filled with destroyed bits
                BN.prototype.ishrn = function ishrn(bits, hint, extended) {
                    assert(typeof bits === 'number' && bits >= 0);
                    var h;
                    if (hint)
                        h = (hint - (hint % 26)) / 26;
                    else
                        h = 0;
                    
                    var r = bits % 26;
                    var s = Math.min((bits - r) / 26, this.length);
                    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
                    var maskedWords = extended;
                    
                    h -= s;
                    h = Math.max(0, h);
                    
                    // Extended mode, copy masked part
                    if (maskedWords) {
                        for (var i = 0; i < s; i++)
                            maskedWords.words[i] = this.words[i];
                        maskedWords.length = s;
                    }
                    
                    if (s === 0) {
    // No-op, we should not move anything at all
                    } else if (this.length > s) {
                        this.length -= s;
                        for (var i = 0; i < this.length; i++)
                            this.words[i] = this.words[i + s];
                    } else {
                        this.words[0] = 0;
                        this.length = 1;
                    }
                    
                    var carry = 0;
                    for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
                        var word = this.words[i];
                        this.words[i] = (carry << (26 - r)) | (word >>> r);
                        carry = word & mask;
                    }
                    
                    // Push carried bits as a mask
                    if (maskedWords && carry !== 0)
                        maskedWords.words[maskedWords.length++] = carry;
                    
                    if (this.length === 0) {
                        this.words[0] = 0;
                        this.length = 1;
                    }
                    
                    this.strip();
                    
                    return this;
                };
                
                // Shift-left
                BN.prototype.shln = function shln(bits) {
                    return this.clone().ishln(bits);
                };
                
                // Shift-right
                BN.prototype.shrn = function shrn(bits) {
                    return this.clone().ishrn(bits);
                };
                
                // Test if n bit is set
                BN.prototype.testn = function testn(bit) {
                    assert(typeof bit === 'number' && bit >= 0);
                    var r = bit % 26;
                    var s = (bit - r) / 26;
                    var q = 1 << r;
                    
                    // Fast case: bit is much higher than all existing words
                    if (this.length <= s) {
                        return false;
                    }
                    
                    // Check bit and return
                    var w = this.words[s];
                    
                    return !!(w & q);
                };
                
                // Return only lowers bits of number (in-place)
                BN.prototype.imaskn = function imaskn(bits) {
                    assert(typeof bits === 'number' && bits >= 0);
                    var r = bits % 26;
                    var s = (bits - r) / 26;
                    
                    assert(!this.sign, 'imaskn works only with positive numbers');
                    
                    if (r !== 0)
                        s++;
                    this.length = Math.min(s, this.length);
                    
                    if (r !== 0) {
                        var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
                        this.words[this.length - 1] &= mask;
                    }
                    
                    return this.strip();
                };
                
                // Return only lowers bits of number
                BN.prototype.maskn = function maskn(bits) {
                    return this.clone().imaskn(bits);
                };
                
                // Add plain number `num` to `this`
                BN.prototype.iaddn = function iaddn(num) {
                    assert(typeof num === 'number');
                    if (num < 0)
                        return this.isubn(-num);
                    
                    // Possible sign change
                    if (this.sign) {
                        if (this.length === 1 && this.words[0] < num) {
                            this.words[0] = num - this.words[0];
                            this.sign = false;
                            return this;
                        }
                        
                        this.sign = false;
                        this.isubn(num);
                        this.sign = true;
                        return this;
                    }
                    
                    // Add without checks
                    return this._iaddn(num);
                };
                
                BN.prototype._iaddn = function _iaddn(num) {
                    this.words[0] += num;
                    
                    // Carry
                    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
                        this.words[i] -= 0x4000000;
                        if (i === this.length - 1)
                            this.words[i + 1] = 1;
                        else
                            this.words[i + 1]++;
                    }
                    this.length = Math.max(this.length, i + 1);
                    
                    return this;
                };
                
                // Subtract plain number `num` from `this`
                BN.prototype.isubn = function isubn(num) {
                    assert(typeof num === 'number');
                    if (num < 0)
                        return this.iaddn(-num);
                    
                    if (this.sign) {
                        this.sign = false;
                        this.iaddn(num);
                        this.sign = true;
                        return this;
                    }
                    
                    this.words[0] -= num;
                    
                    // Carry
                    for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                        this.words[i] += 0x4000000;
                        this.words[i + 1] -= 1;
                    }
                    
                    return this.strip();
                };
                
                BN.prototype.addn = function addn(num) {
                    return this.clone().iaddn(num);
                };
                
                BN.prototype.subn = function subn(num) {
                    return this.clone().isubn(num);
                };
                
                BN.prototype.iabs = function iabs() {
                    this.sign = false;
                    
                    return this;
                };
                
                BN.prototype.abs = function abs() {
                    return this.clone().iabs();
                };
                
                BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
                    // Bigger storage is needed
                    var len = num.length + shift;
                    var i;
                    if (this.words.length < len) {
                        var t = new Array(len);
                        for (var i = 0; i < this.length; i++)
                            t[i] = this.words[i];
                        this.words = t;
                    } else {
                        i = this.length;
                    }
                    
                    // Zeroify rest
                    this.length = Math.max(this.length, len);
                    for (; i < this.length; i++)
                        this.words[i] = 0;
                    
                    var carry = 0;
                    for (var i = 0; i < num.length; i++) {
                        var w = this.words[i + shift] + carry;
                        var right = num.words[i] * mul;
                        w -= right & 0x3ffffff;
                        carry = (w >> 26) - ((right / 0x4000000) | 0);
                        this.words[i + shift] = w & 0x3ffffff;
                    }
                    for (; i < this.length - shift; i++) {
                        var w = this.words[i + shift] + carry;
                        carry = w >> 26;
                        this.words[i + shift] = w & 0x3ffffff;
                    }
                    
                    if (carry === 0)
                        return this.strip();
                    
                    // Subtraction overflow
                    assert(carry === -1);
                    carry = 0;
                    for (var i = 0; i < this.length; i++) {
                        var w = -this.words[i] + carry;
                        carry = w >> 26;
                        this.words[i] = w & 0x3ffffff;
                    }
                    this.sign = true;
                    
                    return this.strip();
                };
                
                BN.prototype._wordDiv = function _wordDiv(num, mode) {
                    var shift = this.length - num.length;
                    
                    var a = this.clone();
                    var b = num;
                    
                    // Normalize
                    var bhi = b.words[b.length - 1];
                    var bhiBits = this._countBits(bhi);
                    shift = 26 - bhiBits;
                    if (shift !== 0) {
                        b = b.shln(shift);
                        a.ishln(shift);
                        bhi = b.words[b.length - 1];
                    }
                    
                    // Initialize quotient
                    var m = a.length - b.length;
                    var q;
                    
                    if (mode !== 'mod') {
                        q = new BN(null);
                        q.length = m + 1;
                        q.words = new Array(q.length);
                        for (var i = 0; i < q.length; i++)
                            q.words[i] = 0;
                    }
                    
                    var diff = a.clone()._ishlnsubmul(b, 1, m);
                    if (!diff.sign) {
                        a = diff;
                        if (q)
                            q.words[m] = 1;
                    }
                    
                    for (var j = m - 1; j >= 0; j--) {
                        var qj = a.words[b.length + j] * 0x4000000 + a.words[b.length + j - 1];
                        
                        // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
                        // (0x7ffffff)
                        qj = Math.min((qj / bhi) | 0, 0x3ffffff);
                        
                        a._ishlnsubmul(b, qj, j);
                        while (a.sign) {
                            qj--;
                            a.sign = false;
                            a._ishlnsubmul(b, 1, j);
                            if (a.cmpn(0) !== 0)
                                a.sign = !a.sign;
                        }
                        if (q)
                            q.words[j] = qj;
                    }
                    if (q)
                        q.strip();
                    a.strip();
                    
                    // Denormalize
                    if (mode !== 'div' && shift !== 0)
                        a.ishrn(shift);
                    return { div: q ? q : null, mod: a };
                };
                
                BN.prototype.divmod = function divmod(num, mode) {
                    assert(num.cmpn(0) !== 0);
                    
                    if (this.sign && !num.sign) {
                        var res = this.neg().divmod(num, mode);
                        var div;
                        var mod;
                        if (mode !== 'mod')
                            div = res.div.neg();
                        if (mode !== 'div')
                            mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
                        return {
                            div: div,
                            mod: mod
                        };
                    } else if (!this.sign && num.sign) {
                        var res = this.divmod(num.neg(), mode);
                        var div;
                        if (mode !== 'mod')
                            div = res.div.neg();
                        return { div: div, mod: res.mod };
                    } else if (this.sign && num.sign) {
                        return this.neg().divmod(num.neg(), mode);
                    }
                    
                    // Both numbers are positive at this point
                    
                    // Strip both numbers to approximate shift value
                    if (num.length > this.length || this.cmp(num) < 0)
                        return { div: new BN(0), mod: this };
                    
                    // Very short reduction
                    if (num.length === 1) {
                        if (mode === 'div')
                            return { div: this.divn(num.words[0]), mod: null };
                        else if (mode === 'mod')
                            return { div: null, mod: new BN(this.modn(num.words[0])) };
                        return {
                            div: this.divn(num.words[0]),
                            mod: new BN(this.modn(num.words[0]))
                        };
                    }
                    
                    return this._wordDiv(num, mode);
                };
                
                // Find `this` / `num`
                BN.prototype.div = function div(num) {
                    return this.divmod(num, 'div').div;
                };
                
                // Find `this` % `num`
                BN.prototype.mod = function mod(num) {
                    return this.divmod(num, 'mod').mod;
                };
                
                // Find Round(`this` / `num`)
                BN.prototype.divRound = function divRound(num) {
                    var dm = this.divmod(num);
                    
                    // Fast case - exact division
                    if (dm.mod.cmpn(0) === 0)
                        return dm.div;
                    
                    var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;
                    
                    var half = num.shrn(1);
                    var r2 = num.andln(1);
                    var cmp = mod.cmp(half);
                    
                    // Round down
                    if (cmp < 0 || r2 === 1 && cmp === 0)
                        return dm.div;
                    
                    // Round up
                    return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
                };
                
                BN.prototype.modn = function modn(num) {
                    assert(num <= 0x3ffffff);
                    var p = (1 << 26) % num;
                    
                    var acc = 0;
                    for (var i = this.length - 1; i >= 0; i--)
                        acc = (p * acc + this.words[i]) % num;
                    
                    return acc;
                };
                
                // In-place division by number
                BN.prototype.idivn = function idivn(num) {
                    assert(num <= 0x3ffffff);
                    
                    var carry = 0;
                    for (var i = this.length - 1; i >= 0; i--) {
                        var w = this.words[i] + carry * 0x4000000;
                        this.words[i] = (w / num) | 0;
                        carry = w % num;
                    }
                    
                    return this.strip();
                };
                
                BN.prototype.divn = function divn(num) {
                    return this.clone().idivn(num);
                };
                
                BN.prototype.egcd = function egcd(p) {
                    assert(!p.sign);
                    assert(p.cmpn(0) !== 0);
                    
                    var x = this;
                    var y = p.clone();
                    
                    if (x.sign)
                        x = x.mod(p);
                    else
                        x = x.clone();
                    
                    // A * x + B * y = x
                    var A = new BN(1);
                    var B = new BN(0);
                    
                    // C * x + D * y = y
                    var C = new BN(0);
                    var D = new BN(1);
                    
                    var g = 0;
                    
                    while (x.isEven() && y.isEven()) {
                        x.ishrn(1);
                        y.ishrn(1);
                        ++g;
                    }
                    
                    var yp = y.clone();
                    var xp = x.clone();
                    
                    while (x.cmpn(0) !== 0) {
                        while (x.isEven()) {
                            x.ishrn(1);
                            if (A.isEven() && B.isEven()) {
                                A.ishrn(1);
                                B.ishrn(1);
                            } else {
                                A.iadd(yp).ishrn(1);
                                B.isub(xp).ishrn(1);
                            }
                        }
                        
                        while (y.isEven()) {
                            y.ishrn(1);
                            if (C.isEven() && D.isEven()) {
                                C.ishrn(1);
                                D.ishrn(1);
                            } else {
                                C.iadd(yp).ishrn(1);
                                D.isub(xp).ishrn(1);
                            }
                        }
                        
                        if (x.cmp(y) >= 0) {
                            x.isub(y);
                            A.isub(C);
                            B.isub(D);
                        } else {
                            y.isub(x);
                            C.isub(A);
                            D.isub(B);
                        }
                    }
                    
                    return {
                        a: C,
                        b: D,
                        gcd: y.ishln(g)
                    };
                };
                
                // This is reduced incarnation of the binary EEA
                // above, designated to invert members of the
                // _prime_ fields F(p) at a maximal speed
                BN.prototype._invmp = function _invmp(p) {
                    assert(!p.sign);
                    assert(p.cmpn(0) !== 0);
                    
                    var a = this;
                    var b = p.clone();
                    
                    if (a.sign)
                        a = a.mod(p);
                    else
                        a = a.clone();
                    
                    var x1 = new BN(1);
                    var x2 = new BN(0);
                    
                    var delta = b.clone();
                    
                    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
                        while (a.isEven()) {
                            a.ishrn(1);
                            if (x1.isEven())
                                x1.ishrn(1);
                            else
                                x1.iadd(delta).ishrn(1);
                        }
                        while (b.isEven()) {
                            b.ishrn(1);
                            if (x2.isEven())
                                x2.ishrn(1);
                            else
                                x2.iadd(delta).ishrn(1);
                        }
                        if (a.cmp(b) >= 0) {
                            a.isub(b);
                            x1.isub(x2);
                        } else {
                            b.isub(a);
                            x2.isub(x1);
                        }
                    }
                    if (a.cmpn(1) === 0)
                        return x1;
                    else
                        return x2;
                };
                
                BN.prototype.gcd = function gcd(num) {
                    if (this.cmpn(0) === 0)
                        return num.clone();
                    if (num.cmpn(0) === 0)
                        return this.clone();
                    
                    var a = this.clone();
                    var b = num.clone();
                    a.sign = false;
                    b.sign = false;
                    
                    // Remove common factor of two
                    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
                        a.ishrn(1);
                        b.ishrn(1);
                    }
                    
                    do {
                        while (a.isEven())
                            a.ishrn(1);
                        while (b.isEven())
                            b.ishrn(1);
                        
                        var r = a.cmp(b);
                        if (r < 0) {
                            // Swap `a` and `b` to make `a` always bigger than `b`
                            var t = a;
                            a = b;
                            b = t;
                        } else if (r === 0 || b.cmpn(1) === 0) {
                            break;
                        }
                        
                        a.isub(b);
                    } while (true);
                    
                    return b.ishln(shift);
                };
                
                // Invert number in the field F(num)
                BN.prototype.invm = function invm(num) {
                    return this.egcd(num).a.mod(num);
                };
                
                BN.prototype.isEven = function isEven() {
                    return (this.words[0] & 1) === 0;
                };
                
                BN.prototype.isOdd = function isOdd() {
                    return (this.words[0] & 1) === 1;
                };
                
                // And first word and num
                BN.prototype.andln = function andln(num) {
                    return this.words[0] & num;
                };
                
                // Increment at the bit position in-line
                BN.prototype.bincn = function bincn(bit) {
                    assert(typeof bit === 'number');
                    var r = bit % 26;
                    var s = (bit - r) / 26;
                    var q = 1 << r;
                    
                    // Fast case: bit is much higher than all existing words
                    if (this.length <= s) {
                        for (var i = this.length; i < s + 1; i++)
                            this.words[i] = 0;
                        this.words[s] |= q;
                        this.length = s + 1;
                        return this;
                    }
                    
                    // Add bit and propagate, if needed
                    var carry = q;
                    for (var i = s; carry !== 0 && i < this.length; i++) {
                        var w = this.words[i];
                        w += carry;
                        carry = w >>> 26;
                        w &= 0x3ffffff;
                        this.words[i] = w;
                    }
                    if (carry !== 0) {
                        this.words[i] = carry;
                        this.length++;
                    }
                    return this;
                };
                
                BN.prototype.cmpn = function cmpn(num) {
                    var sign = num < 0;
                    if (sign)
                        num = -num;
                    
                    if (this.sign && !sign)
                        return -1;
                    else if (!this.sign && sign)
                        return 1;
                    
                    num &= 0x3ffffff;
                    this.strip();
                    
                    var res;
                    if (this.length > 1) {
                        res = 1;
                    } else {
                        var w = this.words[0];
                        res = w === num ? 0 : w < num ? -1 : 1;
                    }
                    if (this.sign)
                        res = -res;
                    return res;
                };
                
                // Compare two numbers and return:
                // 1 - if `this` > `num`
                // 0 - if `this` == `num`
                // -1 - if `this` < `num`
                BN.prototype.cmp = function cmp(num) {
                    if (this.sign && !num.sign)
                        return -1;
                    else if (!this.sign && num.sign)
                        return 1;
                    
                    var res = this.ucmp(num);
                    if (this.sign)
                        return -res;
                    else
                        return res;
                };
                
                // Unsigned comparison
                BN.prototype.ucmp = function ucmp(num) {
                    // At this point both numbers have the same sign
                    if (this.length > num.length)
                        return 1;
                    else if (this.length < num.length)
                        return -1;
                    
                    var res = 0;
                    for (var i = this.length - 1; i >= 0; i--) {
                        var a = this.words[i];
                        var b = num.words[i];
                        
                        if (a === b)
                            continue;
                        if (a < b)
                            res = -1;
                        else if (a > b)
                            res = 1;
                        break;
                    }
                    return res;
                };
                
                //
                // A reduce context, could be using montgomery or something better, depending
                // on the `m` itself.
                //
                BN.red = function red(num) {
                    return new Red(num);
                };
                
                BN.prototype.toRed = function toRed(ctx) {
                    assert(!this.red, 'Already a number in reduction context');
                    assert(!this.sign, 'red works only with positives');
                    return ctx.convertTo(this)._forceRed(ctx);
                };
                
                BN.prototype.fromRed = function fromRed() {
                    assert(this.red, 'fromRed works only with numbers in reduction context');
                    return this.red.convertFrom(this);
                };
                
                BN.prototype._forceRed = function _forceRed(ctx) {
                    this.red = ctx;
                    return this;
                };
                
                BN.prototype.forceRed = function forceRed(ctx) {
                    assert(!this.red, 'Already a number in reduction context');
                    return this._forceRed(ctx);
                };
                
                BN.prototype.redAdd = function redAdd(num) {
                    assert(this.red, 'redAdd works only with red numbers');
                    return this.red.add(this, num);
                };
                
                BN.prototype.redIAdd = function redIAdd(num) {
                    assert(this.red, 'redIAdd works only with red numbers');
                    return this.red.iadd(this, num);
                };
                
                BN.prototype.redSub = function redSub(num) {
                    assert(this.red, 'redSub works only with red numbers');
                    return this.red.sub(this, num);
                };
                
                BN.prototype.redISub = function redISub(num) {
                    assert(this.red, 'redISub works only with red numbers');
                    return this.red.isub(this, num);
                };
                
                BN.prototype.redShl = function redShl(num) {
                    assert(this.red, 'redShl works only with red numbers');
                    return this.red.shl(this, num);
                };
                
                BN.prototype.redMul = function redMul(num) {
                    assert(this.red, 'redMul works only with red numbers');
                    this.red._verify2(this, num);
                    return this.red.mul(this, num);
                };
                
                BN.prototype.redIMul = function redIMul(num) {
                    assert(this.red, 'redMul works only with red numbers');
                    this.red._verify2(this, num);
                    return this.red.imul(this, num);
                };
                
                BN.prototype.redSqr = function redSqr() {
                    assert(this.red, 'redSqr works only with red numbers');
                    this.red._verify1(this);
                    return this.red.sqr(this);
                };
                
                BN.prototype.redISqr = function redISqr() {
                    assert(this.red, 'redISqr works only with red numbers');
                    this.red._verify1(this);
                    return this.red.isqr(this);
                };
                
                // Square root over p
                BN.prototype.redSqrt = function redSqrt() {
                    assert(this.red, 'redSqrt works only with red numbers');
                    this.red._verify1(this);
                    return this.red.sqrt(this);
                };
                
                BN.prototype.redInvm = function redInvm() {
                    assert(this.red, 'redInvm works only with red numbers');
                    this.red._verify1(this);
                    return this.red.invm(this);
                };
                
                // Return negative clone of `this` % `red modulo`
                BN.prototype.redNeg = function redNeg() {
                    assert(this.red, 'redNeg works only with red numbers');
                    this.red._verify1(this);
                    return this.red.neg(this);
                };
                
                BN.prototype.redPow = function redPow(num) {
                    assert(this.red && !num.red, 'redPow(normalNum)');
                    this.red._verify1(this);
                    return this.red.pow(this, num);
                };
                
                // Prime numbers with efficient reduction
                var primes = {
                    k256: null,
                    p224: null,
                    p192: null,
                    p25519: null
                };
                
                // Pseudo-Mersenne prime
                function MPrime(name, p) {
                    // P = 2 ^ N - K
                    this.name = name;
                    this.p = new BN(p, 16);
                    this.n = this.p.bitLength();
                    this.k = new BN(1).ishln(this.n).isub(this.p);
                    
                    this.tmp = this._tmp();
                }
                
                MPrime.prototype._tmp = function _tmp() {
                    var tmp = new BN(null);
                    tmp.words = new Array(Math.ceil(this.n / 13));
                    return tmp;
                };
                
                MPrime.prototype.ireduce = function ireduce(num) {
                    // Assumes that `num` is less than `P^2`
                    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
                    var r = num;
                    var rlen;
                    
                    do {
                        this.split(r, this.tmp);
                        r = this.imulK(r);
                        r = r.iadd(this.tmp);
                        rlen = r.bitLength();
                    } while (rlen > this.n);
                    
                    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
                    if (cmp === 0) {
                        r.words[0] = 0;
                        r.length = 1;
                    } else if (cmp > 0) {
                        r.isub(this.p);
                    } else {
                        r.strip();
                    }
                    
                    return r;
                };
                
                MPrime.prototype.split = function split(input, out) {
                    input.ishrn(this.n, 0, out);
                };
                
                MPrime.prototype.imulK = function imulK(num) {
                    return num.imul(this.k);
                };
                
                function K256() {
                    MPrime.call(
                        this,
    'k256',
    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
                }
                inherits(K256, MPrime);
                
                K256.prototype.split = function split(input, output) {
                    // 256 = 9 * 26 + 22
                    var mask = 0x3fffff;
                    
                    var outLen = Math.min(input.length, 9);
                    for (var i = 0; i < outLen; i++)
                        output.words[i] = input.words[i];
                    output.length = outLen;
                    
                    if (input.length <= 9) {
                        input.words[0] = 0;
                        input.length = 1;
                        return;
                    }
                    
                    // Shift by 9 limbs
                    var prev = input.words[9];
                    output.words[output.length++] = prev & mask;
                    
                    for (var i = 10; i < input.length; i++) {
                        var next = input.words[i];
                        input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
                        prev = next;
                    }
                    input.words[i - 10] = prev >>> 22;
                    input.length -= 9;
                };
                
                K256.prototype.imulK = function imulK(num) {
                    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
                    num.words[num.length] = 0;
                    num.words[num.length + 1] = 0;
                    num.length += 2;
                    
                    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
                    var hi;
                    var lo = 0;
                    for (var i = 0; i < num.length; i++) {
                        var w = num.words[i];
                        hi = w * 0x40;
                        lo += w * 0x3d1;
                        hi += (lo / 0x4000000) | 0;
                        lo &= 0x3ffffff;
                        
                        num.words[i] = lo;
                        
                        lo = hi;
                    }
                    
                    // Fast length reduction
                    if (num.words[num.length - 1] === 0) {
                        num.length--;
                        if (num.words[num.length - 1] === 0)
                            num.length--;
                    }
                    return num;
                };
                
                function P224() {
                    MPrime.call(
                        this,
    'p224',
    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
                }
                inherits(P224, MPrime);
                
                function P192() {
                    MPrime.call(
                        this,
    'p192',
    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
                }
                inherits(P192, MPrime);
                
                function P25519() {
                    // 2 ^ 255 - 19
                    MPrime.call(
                        this,
    '25519',
    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
                }
                inherits(P25519, MPrime);
                
                P25519.prototype.imulK = function imulK(num) {
                    // K = 0x13
                    var carry = 0;
                    for (var i = 0; i < num.length; i++) {
                        var hi = num.words[i] * 0x13 + carry;
                        var lo = hi & 0x3ffffff;
                        hi >>>= 26;
                        
                        num.words[i] = lo;
                        carry = hi;
                    }
                    if (carry !== 0)
                        num.words[num.length++] = carry;
                    return num;
                };
                
                // Exported mostly for testing purposes, use plain name instead
                BN._prime = function prime(name) {
                    // Cached version of prime
                    if (primes[name])
                        return primes[name];
                    
                    var prime;
                    if (name === 'k256')
                        prime = new K256();
                    else if (name === 'p224')
                        prime = new P224();
                    else if (name === 'p192')
                        prime = new P192();
                    else if (name === 'p25519')
                        prime = new P25519();
                    else
                        throw new Error('Unknown prime ' + name);
                    primes[name] = prime;
                    
                    return prime;
                };
                
                //
                // Base reduction engine
                //
                function Red(m) {
                    if (typeof m === 'string') {
                        var prime = BN._prime(m);
                        this.m = prime.p;
                        this.prime = prime;
                    } else {
                        this.m = m;
                        this.prime = null;
                    }
                }
                
                Red.prototype._verify1 = function _verify1(a) {
                    assert(!a.sign, 'red works only with positives');
                    assert(a.red, 'red works only with red numbers');
                };
                
                Red.prototype._verify2 = function _verify2(a, b) {
                    assert(!a.sign && !b.sign, 'red works only with positives');
                    assert(a.red && a.red === b.red,
         'red works only with red numbers');
                };
                
                Red.prototype.imod = function imod(a) {
                    if (this.prime)
                        return this.prime.ireduce(a)._forceRed(this);
                    return a.mod(this.m)._forceRed(this);
                };
                
                Red.prototype.neg = function neg(a) {
                    var r = a.clone();
                    r.sign = !r.sign;
                    return r.iadd(this.m)._forceRed(this);
                };
                
                Red.prototype.add = function add(a, b) {
                    this._verify2(a, b);
                    
                    var res = a.add(b);
                    if (res.cmp(this.m) >= 0)
                        res.isub(this.m);
                    return res._forceRed(this);
                };
                
                Red.prototype.iadd = function iadd(a, b) {
                    this._verify2(a, b);
                    
                    var res = a.iadd(b);
                    if (res.cmp(this.m) >= 0)
                        res.isub(this.m);
                    return res;
                };
                
                Red.prototype.sub = function sub(a, b) {
                    this._verify2(a, b);
                    
                    var res = a.sub(b);
                    if (res.cmpn(0) < 0)
                        res.iadd(this.m);
                    return res._forceRed(this);
                };
                
                Red.prototype.isub = function isub(a, b) {
                    this._verify2(a, b);
                    
                    var res = a.isub(b);
                    if (res.cmpn(0) < 0)
                        res.iadd(this.m);
                    return res;
                };
                
                Red.prototype.shl = function shl(a, num) {
                    this._verify1(a);
                    return this.imod(a.shln(num));
                };
                
                Red.prototype.imul = function imul(a, b) {
                    this._verify2(a, b);
                    return this.imod(a.imul(b));
                };
                
                Red.prototype.mul = function mul(a, b) {
                    this._verify2(a, b);
                    return this.imod(a.mul(b));
                };
                
                Red.prototype.isqr = function isqr(a) {
                    return this.imul(a, a);
                };
                
                Red.prototype.sqr = function sqr(a) {
                    return this.mul(a, a);
                };
                
                Red.prototype.sqrt = function sqrt(a) {
                    if (a.cmpn(0) === 0)
                        return a.clone();
                    
                    var mod3 = this.m.andln(3);
                    assert(mod3 % 2 === 1);
                    
                    // Fast case
                    if (mod3 === 3) {
                        var pow = this.m.add(new BN(1)).ishrn(2);
                        var r = this.pow(a, pow);
                        return r;
                    }
                    
                    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
                    //
                    // Find Q and S, that Q * 2 ^ S = (P - 1)
                    var q = this.m.subn(1);
                    var s = 0;
                    while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
                        s++;
                        q.ishrn(1);
                    }
                    assert(q.cmpn(0) !== 0);
                    
                    var one = new BN(1).toRed(this);
                    var nOne = one.redNeg();
                    
                    // Find quadratic non-residue
                    // NOTE: Max is such because of generalized Riemann hypothesis.
                    var lpow = this.m.subn(1).ishrn(1);
                    var z = this.m.bitLength();
                    z = new BN(2 * z * z).toRed(this);
                    while (this.pow(z, lpow).cmp(nOne) !== 0)
                        z.redIAdd(nOne);
                    
                    var c = this.pow(z, q);
                    var r = this.pow(a, q.addn(1).ishrn(1));
                    var t = this.pow(a, q);
                    var m = s;
                    while (t.cmp(one) !== 0) {
                        var tmp = t;
                        for (var i = 0; tmp.cmp(one) !== 0; i++)
                            tmp = tmp.redSqr();
                        assert(i < m);
                        var b = this.pow(c, new BN(1).ishln(m - i - 1));
                        
                        r = r.redMul(b);
                        c = b.redSqr();
                        t = t.redMul(c);
                        m = i;
                    }
                    
                    return r;
                };
                
                Red.prototype.invm = function invm(a) {
                    var inv = a._invmp(this.m);
                    if (inv.sign) {
                        inv.sign = false;
                        return this.imod(inv).redNeg();
                    } else {
                        return this.imod(inv);
                    }
                };
                
                Red.prototype.pow = function pow(a, num) {
                    var w = [];
                    
                    if (num.cmpn(0) === 0)
                        return new BN(1);
                    
                    var q = num.clone();
                    
                    while (q.cmpn(0) !== 0) {
                        w.push(q.andln(1));
                        q.ishrn(1);
                    }
                    
                    // Skip leading zeroes
                    var res = a;
                    for (var i = 0; i < w.length; i++, res = this.sqr(res))
                        if (w[i] !== 0)
                            break;
                    
                    if (++i < w.length) {
                        for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
                            if (w[i] === 0)
                                continue;
                            res = this.mul(res, q);
                        }
                    }
                    
                    return res;
                };
                
                Red.prototype.convertTo = function convertTo(num) {
                    var r = num.mod(this.m);
                    if (r === num)
                        return r.clone();
                    else
                        return r;
                };
                
                Red.prototype.convertFrom = function convertFrom(num) {
                    var res = num.clone();
                    res.red = null;
                    return res;
                };
                
                //
                // Montgomery method engine
                //
                
                BN.mont = function mont(num) {
                    return new Mont(num);
                };
                
                function Mont(m) {
                    Red.call(this, m);
                    
                    this.shift = this.m.bitLength();
                    if (this.shift % 26 !== 0)
                        this.shift += 26 - (this.shift % 26);
                    this.r = new BN(1).ishln(this.shift);
                    this.r2 = this.imod(this.r.sqr());
                    this.rinv = this.r._invmp(this.m);
                    
                    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
                    this.minv.sign = true;
                    this.minv = this.minv.mod(this.r);
                }
                inherits(Mont, Red);
                
                Mont.prototype.convertTo = function convertTo(num) {
                    return this.imod(num.shln(this.shift));
                };
                
                Mont.prototype.convertFrom = function convertFrom(num) {
                    var r = this.imod(num.mul(this.rinv));
                    r.red = null;
                    return r;
                };
                
                Mont.prototype.imul = function imul(a, b) {
                    if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
                        a.words[0] = 0;
                        a.length = 1;
                        return a;
                    }
                    
                    var t = a.imul(b);
                    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                    var u = t.isub(c).ishrn(this.shift);
                    var res = u;
                    if (u.cmp(this.m) >= 0)
                        res = u.isub(this.m);
                    else if (u.cmpn(0) < 0)
                        res = u.iadd(this.m);
                    
                    return res._forceRed(this);
                };
                
                Mont.prototype.mul = function mul(a, b) {
                    if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
                        return new BN(0)._forceRed(this);
                    
                    var t = a.mul(b);
                    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
                    var u = t.isub(c).ishrn(this.shift);
                    var res = u;
                    if (u.cmp(this.m) >= 0)
                        res = u.isub(this.m);
                    else if (u.cmpn(0) < 0)
                        res = u.iadd(this.m);
                    
                    return res._forceRed(this);
                };
                
                Mont.prototype.invm = function invm(a) {
                    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
                    var res = this.imod(a._invmp(this.m).mul(this.r2));
                    return res._forceRed(this);
                };

            })(typeof module === 'undefined' || module, this);

        }, {}], 199: [function (require, module, exports) {
            (function (Buffer) {
                var bn = require('bn.js');
                var randomBytes = require('randombytes');
                module.exports = crt;
                function blind(priv) {
                    var r = getr(priv);
                    var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
                    return {
                        blinder: blinder,
                        unblinder: r.invm(priv.modulus)
                    };
                }
                function crt(msg, priv) {
                    var blinds = blind(priv);
                    var len = priv.modulus.byteLength();
                    var mod = bn.mont(priv.modulus);
                    var blinded = new bn(msg).mul(blinds.blinder).mod(priv.modulus);
                    var c1 = blinded.toRed(bn.mont(priv.prime1));
                    var c2 = blinded.toRed(bn.mont(priv.prime2));
                    var qinv = priv.coefficient;
                    var p = priv.prime1;
                    var q = priv.prime2;
                    var m1 = c1.redPow(priv.exponent1);
                    var m2 = c2.redPow(priv.exponent2);
                    m1 = m1.fromRed();
                    m2 = m2.fromRed();
                    var h = m1.isub(m2).imul(qinv).mod(p);
                    h.imul(q);
                    m2.iadd(h);
                    var out = new Buffer(m2.imul(blinds.unblinder).mod(priv.modulus).toArray());
                    if (out.length < len) {
                        var prefix = new Buffer(len - out.length);
                        prefix.fill(0);
                        out = Buffer.concat([prefix, out], len);
                    }
                    return out;
                }
                crt.getr = getr;
                function getr(priv) {
                    var len = priv.modulus.byteLength();
                    var r = new bn(randomBytes(len));
                    while (r.cmp(priv.modulus) >= 0 || !r.mod(priv.prime1) || !r.mod(priv.prime2)) {
                        r = new bn(randomBytes(len));
                    }
                    return r;
                }
            }).call(this, require("buffer").Buffer)
        }, { "bn.js": 198, "buffer": 172, "randombytes": 316 }], 200: [function (require, module, exports) {
            'use strict';
            
            var elliptic = exports;
            
            elliptic.version = require('../package.json').version;
            elliptic.utils = require('./elliptic/utils');
            elliptic.rand = require('brorand');
            elliptic.hmacDRBG = require('./elliptic/hmac-drbg');
            elliptic.curve = require('./elliptic/curve');
            elliptic.curves = require('./elliptic/curves');
            
            // Protocols
            elliptic.ec = require('./elliptic/ec');

        }, { "../package.json": 220, "./elliptic/curve": 203, "./elliptic/curves": 206, "./elliptic/ec": 207, "./elliptic/hmac-drbg": 210, "./elliptic/utils": 212, "brorand": 213 }], 201: [function (require, module, exports) {
            'use strict';
            
            var bn = require('bn.js');
            var elliptic = require('../../elliptic');
            
            var getNAF = elliptic.utils.getNAF;
            var getJSF = elliptic.utils.getJSF;
            var assert = elliptic.utils.assert;
            
            function BaseCurve(type, conf) {
                this.type = type;
                this.p = new bn(conf.p, 16);
                
                // Use Montgomery, when there is no fast reduction for the prime
                this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);
                
                // Useful for many curves
                this.zero = new bn(0).toRed(this.red);
                this.one = new bn(1).toRed(this.red);
                this.two = new bn(2).toRed(this.red);
                
                // Curve configuration, optional
                this.n = conf.n && new bn(conf.n, 16);
                this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
                
                // Temporary arrays
                this._wnafT1 = new Array(4);
                this._wnafT2 = new Array(4);
                this._wnafT3 = new Array(4);
                this._wnafT4 = new Array(4);
            }
            module.exports = BaseCurve;
            
            BaseCurve.prototype.point = function point() {
                throw new Error('Not implemented');
            };
            
            BaseCurve.prototype.validate = function validate() {
                throw new Error('Not implemented');
            };
            
            BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
                assert(p.precomputed);
                var doubles = p._getDoubles();
                
                var naf = getNAF(k, 1);
                var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
                I /= 3;
                
                // Translate into more windowed form
                var repr = [];
                for (var j = 0; j < naf.length; j += doubles.step) {
                    var nafW = 0;
                    for (var k = j + doubles.step - 1; k >= j; k--)
                        nafW = (nafW << 1) + naf[k];
                    repr.push(nafW);
                }
                
                var a = this.jpoint(null, null, null);
                var b = this.jpoint(null, null, null);
                for (var i = I; i > 0; i--) {
                    for (var j = 0; j < repr.length; j++) {
                        var nafW = repr[j];
                        if (nafW === i)
                            b = b.mixedAdd(doubles.points[j]);
                        else if (nafW === -i)
                            b = b.mixedAdd(doubles.points[j].neg());
                    }
                    a = a.add(b);
                }
                return a.toP();
            };
            
            BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
                var w = 4;
                
                // Precompute window
                var nafPoints = p._getNAFPoints(w);
                w = nafPoints.wnd;
                var wnd = nafPoints.points;
                
                // Get NAF form
                var naf = getNAF(k, w);
                
                // Add `this`*(N+1) for every w-NAF index
                var acc = this.jpoint(null, null, null);
                for (var i = naf.length - 1; i >= 0; i--) {
                    // Count zeroes
                    for (var k = 0; i >= 0 && naf[i] === 0; i--)
                        k++;
                    if (i >= 0)
                        k++;
                    acc = acc.dblp(k);
                    
                    if (i < 0)
                        break;
                    var z = naf[i];
                    assert(z !== 0);
                    if (p.type === 'affine') {
                        // J +- P
                        if (z > 0)
                            acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
                        else
                            acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
                    } else {
                        // J +- J
                        if (z > 0)
                            acc = acc.add(wnd[(z - 1) >> 1]);
                        else
                            acc = acc.add(wnd[(-z - 1) >> 1].neg());
                    }
                }
                return p.type === 'affine' ? acc.toP() : acc;
            };
            
            BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len) {
                var wndWidth = this._wnafT1;
                var wnd = this._wnafT2;
                var naf = this._wnafT3;
                
                // Fill all arrays
                var max = 0;
                for (var i = 0; i < len; i++) {
                    var p = points[i];
                    var nafPoints = p._getNAFPoints(defW);
                    wndWidth[i] = nafPoints.wnd;
                    wnd[i] = nafPoints.points;
                }
                
                // Comb small window NAFs
                for (var i = len - 1; i >= 1; i -= 2) {
                    var a = i - 1;
                    var b = i;
                    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
                        naf[a] = getNAF(coeffs[a], wndWidth[a]);
                        naf[b] = getNAF(coeffs[b], wndWidth[b]);
                        max = Math.max(naf[a].length, max);
                        max = Math.max(naf[b].length, max);
                        continue;
                    }
                    
                    var comb = [
                        points[a], /* 1 */
                        null, /* 3 */
                        null, /* 5 */
                        points[b] /* 7 */
                    ];
                    
                    // Try to avoid Projective points, if possible
                    if (points[a].y.cmp(points[b].y) === 0) {
                        comb[1] = points[a].add(points[b]);
                        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
                    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
                        comb[1] = points[a].toJ().mixedAdd(points[b]);
                        comb[2] = points[a].add(points[b].neg());
                    } else {
                        comb[1] = points[a].toJ().mixedAdd(points[b]);
                        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
                    }
                    
                    var index = [
                        -3, /* -1 -1 */
                        -1, /* -1 0 */
                        -5, /* -1 1 */
                        -7, /* 0 -1 */
                        0, /* 0 0 */
                        7, /* 0 1 */
                        5, /* 1 -1 */
                        1, /* 1 0 */
                        3  /* 1 1 */
                    ];
                    
                    var jsf = getJSF(coeffs[a], coeffs[b]);
                    max = Math.max(jsf[0].length, max);
                    naf[a] = new Array(max);
                    naf[b] = new Array(max);
                    for (var j = 0; j < max; j++) {
                        var ja = jsf[0][j] | 0;
                        var jb = jsf[1][j] | 0;
                        
                        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
                        naf[b][j] = 0;
                        wnd[a] = comb;
                    }
                }
                
                var acc = this.jpoint(null, null, null);
                var tmp = this._wnafT4;
                for (var i = max; i >= 0; i--) {
                    var k = 0;
                    
                    while (i >= 0) {
                        var zero = true;
                        for (var j = 0; j < len; j++) {
                            tmp[j] = naf[j][i] | 0;
                            if (tmp[j] !== 0)
                                zero = false;
                        }
                        if (!zero)
                            break;
                        k++;
                        i--;
                    }
                    if (i >= 0)
                        k++;
                    acc = acc.dblp(k);
                    if (i < 0)
                        break;
                    
                    for (var j = 0; j < len; j++) {
                        var z = tmp[j];
                        var p;
                        if (z === 0)
                            continue;
                        else if (z > 0)
                            p = wnd[j][(z - 1) >> 1];
                        else if (z < 0)
                            p = wnd[j][(-z - 1) >> 1].neg();
                        
                        if (p.type === 'affine')
                            acc = acc.mixedAdd(p);
                        else
                            acc = acc.add(p);
                    }
                }
                // Zeroify references
                for (var i = 0; i < len; i++)
                    wnd[i] = null;
                return acc.toP();
            };
            
            function BasePoint(curve, type) {
                this.curve = curve;
                this.type = type;
                this.precomputed = null;
            }
            BaseCurve.BasePoint = BasePoint;
            
            BasePoint.prototype.validate = function validate() {
                return this.curve.validate(this);
            };
            
            BasePoint.prototype.precompute = function precompute(power) {
                if (this.precomputed)
                    return this;
                
                var precomputed = {
                    doubles: null,
                    naf: null,
                    beta: null
                };
                precomputed.naf = this._getNAFPoints(8);
                precomputed.doubles = this._getDoubles(4, power);
                precomputed.beta = this._getBeta();
                this.precomputed = precomputed;
                
                return this;
            };
            
            BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
                if (!this.precomputed)
                    return false;
                
                var doubles = this.precomputed.doubles;
                if (!doubles)
                    return false;
                
                return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
            };
            
            BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
                if (this.precomputed && this.precomputed.doubles)
                    return this.precomputed.doubles;
                
                var doubles = [this];
                var acc = this;
                for (var i = 0; i < power; i += step) {
                    for (var j = 0; j < step; j++)
                        acc = acc.dbl();
                    doubles.push(acc);
                }
                return {
                    step: step,
                    points: doubles
                };
            };
            
            BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
                if (this.precomputed && this.precomputed.naf)
                    return this.precomputed.naf;
                
                var res = [this];
                var max = (1 << wnd) - 1;
                var dbl = max === 1 ? null : this.dbl();
                for (var i = 1; i < max; i++)
                    res[i] = res[i - 1].add(dbl);
                return {
                    wnd: wnd,
                    points: res
                };
            };
            
            BasePoint.prototype._getBeta = function _getBeta() {
                return null;
            };
            
            BasePoint.prototype.dblp = function dblp(k) {
                var r = this;
                for (var i = 0; i < k; i++)
                    r = r.dbl();
                return r;
            };

        }, { "../../elliptic": 200, "bn.js": 198 }], 202: [function (require, module, exports) {
            'use strict';
            
            var curve = require('../curve');
            var elliptic = require('../../elliptic');
            var bn = require('bn.js');
            var inherits = require('inherits');
            var Base = curve.base;
            
            var assert = elliptic.utils.assert;
            
            function EdwardsCurve(conf) {
                // NOTE: Important as we are creating point in Base.call()
                this.twisted = (conf.a | 0) !== 1;
                this.mOneA = this.twisted && (conf.a | 0) === -1;
                this.extended = this.mOneA;
                
                Base.call(this, 'edwards', conf);
                
                this.a = new bn(conf.a, 16).mod(this.red.m).toRed(this.red);
                this.c = new bn(conf.c, 16).toRed(this.red);
                this.c2 = this.c.redSqr();
                this.d = new bn(conf.d, 16).toRed(this.red);
                this.dd = this.d.redAdd(this.d);
                
                assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
                this.oneC = (conf.c | 0) === 1;
            }
            inherits(EdwardsCurve, Base);
            module.exports = EdwardsCurve;
            
            EdwardsCurve.prototype._mulA = function _mulA(num) {
                if (this.mOneA)
                    return num.redNeg();
                else
                    return this.a.redMul(num);
            };
            
            EdwardsCurve.prototype._mulC = function _mulC(num) {
                if (this.oneC)
                    return num;
                else
                    return this.c.redMul(num);
            };
            
            // Just for compatibility with Short curve
            EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
                return this.point(x, y, z, t);
            };
            
            EdwardsCurve.prototype.pointFromX = function pointFromX(odd, x) {
                x = new bn(x, 16);
                if (!x.red)
                    x = x.toRed(this.red);
                
                var x2 = x.redSqr();
                var rhs = this.c2.redSub(this.a.redMul(x2));
                var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
                
                var y = rhs.redMul(lhs.redInvm()).redSqrt();
                var isOdd = y.fromRed().isOdd();
                if (odd && !isOdd || !odd && isOdd)
                    y = y.redNeg();
                
                return this.point(x, y, curve.one);
            };
            
            EdwardsCurve.prototype.validate = function validate(point) {
                if (point.isInfinity())
                    return true;
                
                // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
                point.normalize();
                
                var x2 = point.x.redSqr();
                var y2 = point.y.redSqr();
                var lhs = x2.redMul(this.a).redAdd(y2);
                var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
                
                return lhs.cmp(rhs) === 0;
            };
            
            function Point(curve, x, y, z, t) {
                Base.BasePoint.call(this, curve, 'projective');
                if (x === null && y === null && z === null) {
                    this.x = this.curve.zero;
                    this.y = this.curve.one;
                    this.z = this.curve.one;
                    this.t = this.curve.zero;
                    this.zOne = true;
                } else {
                    this.x = new bn(x, 16);
                    this.y = new bn(y, 16);
                    this.z = z ? new bn(z, 16) : this.curve.one;
                    this.t = t && new bn(t, 16);
                    if (!this.x.red)
                        this.x = this.x.toRed(this.curve.red);
                    if (!this.y.red)
                        this.y = this.y.toRed(this.curve.red);
                    if (!this.z.red)
                        this.z = this.z.toRed(this.curve.red);
                    if (this.t && !this.t.red)
                        this.t = this.t.toRed(this.curve.red);
                    this.zOne = this.z === this.curve.one;
                    
                    // Use extended coordinates
                    if (this.curve.extended && !this.t) {
                        this.t = this.x.redMul(this.y);
                        if (!this.zOne)
                            this.t = this.t.redMul(this.z.redInvm());
                    }
                }
            }
            inherits(Point, Base.BasePoint);
            
            EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
                return Point.fromJSON(this, obj);
            };
            
            EdwardsCurve.prototype.point = function point(x, y, z, t) {
                return new Point(this, x, y, z, t);
            };
            
            Point.fromJSON = function fromJSON(curve, obj) {
                return new Point(curve, obj[0], obj[1], obj[2]);
            };
            
            Point.prototype.inspect = function inspect() {
                if (this.isInfinity())
                    return '<EC Point Infinity>';
                return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
            };
            
            Point.prototype.isInfinity = function isInfinity() {
                // XXX This code assumes that zero is always zero in red
                return this.x.cmpn(0) === 0 &&
         this.y.cmp(this.z) === 0;
            };
            
            Point.prototype._extDbl = function _extDbl() {
                // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
                //     #doubling-dbl-2008-hwcd
                // 4M + 4S
                
                // A = X1^2
                var a = this.x.redSqr();
                // B = Y1^2
                var b = this.y.redSqr();
                // C = 2 * Z1^2
                var c = this.z.redSqr();
                c = c.redIAdd(c);
                // D = a * A
                var d = this.curve._mulA(a);
                // E = (X1 + Y1)^2 - A - B
                var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
                // G = D + B
                var g = d.redAdd(b);
                // F = G - C
                var f = g.redSub(c);
                // H = D - B
                var h = d.redSub(b);
                // X3 = E * F
                var nx = e.redMul(f);
                // Y3 = G * H
                var ny = g.redMul(h);
                // T3 = E * H
                var nt = e.redMul(h);
                // Z3 = F * G
                var nz = f.redMul(g);
                return this.curve.point(nx, ny, nz, nt);
            };
            
            Point.prototype._projDbl = function _projDbl() {
                // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
                //     #doubling-dbl-2008-bbjlp
                //     #doubling-dbl-2007-bl
                // and others
                // Generally 3M + 4S or 2M + 4S
                
                // B = (X1 + Y1)^2
                var b = this.x.redAdd(this.y).redSqr();
                // C = X1^2
                var c = this.x.redSqr();
                // D = Y1^2
                var d = this.y.redSqr();
                
                var nx;
                var ny;
                var nz;
                if (this.curve.twisted) {
                    // E = a * C
                    var e = this.curve._mulA(c);
                    // F = E + D
                    var f = e.redAdd(d);
                    if (this.zOne) {
                        // X3 = (B - C - D) * (F - 2)
                        nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
                        // Y3 = F * (E - D)
                        ny = f.redMul(e.redSub(d));
                        // Z3 = F^2 - 2 * F
                        nz = f.redSqr().redSub(f).redSub(f);
                    } else {
                        // H = Z1^2
                        var h = this.z.redSqr();
                        // J = F - 2 * H
                        var j = f.redSub(h).redISub(h);
                        // X3 = (B-C-D)*J
                        nx = b.redSub(c).redISub(d).redMul(j);
                        // Y3 = F * (E - D)
                        ny = f.redMul(e.redSub(d));
                        // Z3 = F * J
                        nz = f.redMul(j);
                    }
                } else {
                    // E = C + D
                    var e = c.redAdd(d);
                    // H = (c * Z1)^2
                    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
                    // J = E - 2 * H
                    var j = e.redSub(h).redSub(h);
                    // X3 = c * (B - E) * J
                    nx = this.curve._mulC(b.redISub(e)).redMul(j);
                    // Y3 = c * E * (C - D)
                    ny = this.curve._mulC(e).redMul(c.redISub(d));
                    // Z3 = E * J
                    nz = e.redMul(j);
                }
                return this.curve.point(nx, ny, nz);
            };
            
            Point.prototype.dbl = function dbl() {
                if (this.isInfinity())
                    return this;
                
                // Double in extended coordinates
                if (this.curve.extended)
                    return this._extDbl();
                else
                    return this._projDbl();
            };
            
            Point.prototype._extAdd = function _extAdd(p) {
                // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
                //     #addition-add-2008-hwcd-3
                // 8M
                
                // A = (Y1 - X1) * (Y2 - X2)
                var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
                // B = (Y1 + X1) * (Y2 + X2)
                var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
                // C = T1 * k * T2
                var c = this.t.redMul(this.curve.dd).redMul(p.t);
                // D = Z1 * 2 * Z2
                var d = this.z.redMul(p.z.redAdd(p.z));
                // E = B - A
                var e = b.redSub(a);
                // F = D - C
                var f = d.redSub(c);
                // G = D + C
                var g = d.redAdd(c);
                // H = B + A
                var h = b.redAdd(a);
                // X3 = E * F
                var nx = e.redMul(f);
                // Y3 = G * H
                var ny = g.redMul(h);
                // T3 = E * H
                var nt = e.redMul(h);
                // Z3 = F * G
                var nz = f.redMul(g);
                return this.curve.point(nx, ny, nz, nt);
            };
            
            Point.prototype._projAdd = function _projAdd(p) {
                // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
                //     #addition-add-2008-bbjlp
                //     #addition-add-2007-bl
                // 10M + 1S
                
                // A = Z1 * Z2
                var a = this.z.redMul(p.z);
                // B = A^2
                var b = a.redSqr();
                // C = X1 * X2
                var c = this.x.redMul(p.x);
                // D = Y1 * Y2
                var d = this.y.redMul(p.y);
                // E = d * C * D
                var e = this.curve.d.redMul(c).redMul(d);
                // F = B - E
                var f = b.redSub(e);
                // G = B + E
                var g = b.redAdd(e);
                // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
                var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
                var nx = a.redMul(f).redMul(tmp);
                var ny;
                var nz;
                if (this.curve.twisted) {
                    // Y3 = A * G * (D - a * C)
                    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
                    // Z3 = F * G
                    nz = f.redMul(g);
                } else {
                    // Y3 = A * G * (D - C)
                    ny = a.redMul(g).redMul(d.redSub(c));
                    // Z3 = c * F * G
                    nz = this.curve._mulC(f).redMul(g);
                }
                return this.curve.point(nx, ny, nz);
            };
            
            Point.prototype.add = function add(p) {
                if (this.isInfinity())
                    return p;
                if (p.isInfinity())
                    return this;
                
                if (this.curve.extended)
                    return this._extAdd(p);
                else
                    return this._projAdd(p);
            };
            
            Point.prototype.mul = function mul(k) {
                if (this._hasDoubles(k))
                    return this.curve._fixedNafMul(this, k);
                else
                    return this.curve._wnafMul(this, k);
            };
            
            Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
                return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2);
            };
            
            Point.prototype.normalize = function normalize() {
                if (this.zOne)
                    return this;
                
                // Normalize coordinates
                var zi = this.z.redInvm();
                this.x = this.x.redMul(zi);
                this.y = this.y.redMul(zi);
                if (this.t)
                    this.t = this.t.redMul(zi);
                this.z = this.curve.one;
                this.zOne = true;
                return this;
            };
            
            Point.prototype.neg = function neg() {
                return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
            };
            
            Point.prototype.getX = function getX() {
                this.normalize();
                return this.x.fromRed();
            };
            
            Point.prototype.getY = function getY() {
                this.normalize();
                return this.y.fromRed();
            };
            
            // Compatibility with BaseCurve
            Point.prototype.toP = Point.prototype.normalize;
            Point.prototype.mixedAdd = Point.prototype.add;

        }, { "../../elliptic": 200, "../curve": 203, "bn.js": 198, "inherits": 318 }], 203: [function (require, module, exports) {
            'use strict';
            
            var curve = exports;
            
            curve.base = require('./base');
            curve.short = require('./short');
            curve.mont = require('./mont');
            curve.edwards = require('./edwards');

        }, { "./base": 201, "./edwards": 202, "./mont": 204, "./short": 205 }], 204: [function (require, module, exports) {
            'use strict';
            
            var curve = require('../curve');
            var bn = require('bn.js');
            var inherits = require('inherits');
            var Base = curve.base;
            
            function MontCurve(conf) {
                Base.call(this, 'mont', conf);
                
                this.a = new bn(conf.a, 16).toRed(this.red);
                this.b = new bn(conf.b, 16).toRed(this.red);
                this.i4 = new bn(4).toRed(this.red).redInvm();
                this.two = new bn(2).toRed(this.red);
                this.a24 = this.i4.redMul(this.a.redAdd(this.two));
            }
            inherits(MontCurve, Base);
            module.exports = MontCurve;
            
            MontCurve.prototype.validate = function validate(point) {
                var x = point.normalize().x;
                var x2 = x.redSqr();
                var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
                var y = rhs.redSqrt();
                
                return y.redSqr().cmp(rhs) === 0;
            };
            
            function Point(curve, x, z) {
                Base.BasePoint.call(this, curve, 'projective');
                if (x === null && z === null) {
                    this.x = this.curve.one;
                    this.z = this.curve.zero;
                } else {
                    this.x = new bn(x, 16);
                    this.z = new bn(z, 16);
                    if (!this.x.red)
                        this.x = this.x.toRed(this.curve.red);
                    if (!this.z.red)
                        this.z = this.z.toRed(this.curve.red);
                }
            }
            inherits(Point, Base.BasePoint);
            
            MontCurve.prototype.point = function point(x, z) {
                return new Point(this, x, z);
            };
            
            MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
                return Point.fromJSON(this, obj);
            };
            
            Point.prototype.precompute = function precompute() {
  // No-op
            };
            
            Point.fromJSON = function fromJSON(curve, obj) {
                return new Point(curve, obj[0], obj[1] || curve.one);
            };
            
            Point.prototype.inspect = function inspect() {
                if (this.isInfinity())
                    return '<EC Point Infinity>';
                return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
            };
            
            Point.prototype.isInfinity = function isInfinity() {
                // XXX This code assumes that zero is always zero in red
                return this.z.cmpn(0) === 0;
            };
            
            Point.prototype.dbl = function dbl() {
                // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
                // 2M + 2S + 4A
                
                // A = X1 + Z1
                var a = this.x.redAdd(this.z);
                // AA = A^2
                var aa = a.redSqr();
                // B = X1 - Z1
                var b = this.x.redSub(this.z);
                // BB = B^2
                var bb = b.redSqr();
                // C = AA - BB
                var c = aa.redSub(bb);
                // X3 = AA * BB
                var nx = aa.redMul(bb);
                // Z3 = C * (BB + A24 * C)
                var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
                return this.curve.point(nx, nz);
            };
            
            Point.prototype.add = function add() {
                throw new Error('Not supported on Montgomery curve');
            };
            
            Point.prototype.diffAdd = function diffAdd(p, diff) {
                // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
                // 4M + 2S + 6A
                
                // A = X2 + Z2
                var a = this.x.redAdd(this.z);
                // B = X2 - Z2
                var b = this.x.redSub(this.z);
                // C = X3 + Z3
                var c = p.x.redAdd(p.z);
                // D = X3 - Z3
                var d = p.x.redSub(p.z);
                // DA = D * A
                var da = d.redMul(a);
                // CB = C * B
                var cb = c.redMul(b);
                // X5 = Z1 * (DA + CB)^2
                var nx = diff.z.redMul(da.redAdd(cb).redSqr());
                // Z5 = X1 * (DA - CB)^2
                var nz = diff.x.redMul(da.redISub(cb).redSqr());
                return this.curve.point(nx, nz);
            };
            
            Point.prototype.mul = function mul(k) {
                var t = k.clone();
                var a = this; // (N / 2) * Q + Q
                var b = this.curve.point(null, null); // (N / 2) * Q
                var c = this; // Q
                
                for (var bits = []; t.cmpn(0) !== 0; t.ishrn(1))
                    bits.push(t.andln(1));
                
                for (var i = bits.length - 1; i >= 0; i--) {
                    if (bits[i] === 0) {
                        // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
                        a = a.diffAdd(b, c);
                        // N * Q = 2 * ((N / 2) * Q + Q))
                        b = b.dbl();
                    } else {
                        // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
                        b = a.diffAdd(b, c);
                        // N * Q + Q = 2 * ((N / 2) * Q + Q)
                        a = a.dbl();
                    }
                }
                return b;
            };
            
            Point.prototype.mulAdd = function mulAdd() {
                throw new Error('Not supported on Montgomery curve');
            };
            
            Point.prototype.normalize = function normalize() {
                this.x = this.x.redMul(this.z.redInvm());
                this.z = this.curve.one;
                return this;
            };
            
            Point.prototype.getX = function getX() {
                // Normalize coordinates
                this.normalize();
                
                return this.x.fromRed();
            };

        }, { "../curve": 203, "bn.js": 198, "inherits": 318 }], 205: [function (require, module, exports) {
            'use strict';
            
            var curve = require('../curve');
            var elliptic = require('../../elliptic');
            var bn = require('bn.js');
            var inherits = require('inherits');
            var Base = curve.base;
            
            var assert = elliptic.utils.assert;
            
            function ShortCurve(conf) {
                Base.call(this, 'short', conf);
                
                this.a = new bn(conf.a, 16).toRed(this.red);
                this.b = new bn(conf.b, 16).toRed(this.red);
                this.tinv = this.two.redInvm();
                
                this.zeroA = this.a.fromRed().cmpn(0) === 0;
                this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
                
                // If the curve is endomorphic, precalculate beta and lambda
                this.endo = this._getEndomorphism(conf);
                this._endoWnafT1 = new Array(4);
                this._endoWnafT2 = new Array(4);
            }
            inherits(ShortCurve, Base);
            module.exports = ShortCurve;
            
            ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
                // No efficient endomorphism
                if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
                    return;
                
                // Compute beta and lambda, that lambda * P = (beta * Px; Py)
                var beta;
                var lambda;
                if (conf.beta) {
                    beta = new bn(conf.beta, 16).toRed(this.red);
                } else {
                    var betas = this._getEndoRoots(this.p);
                    // Choose the smallest beta
                    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
                    beta = beta.toRed(this.red);
                }
                if (conf.lambda) {
                    lambda = new bn(conf.lambda, 16);
                } else {
                    // Choose the lambda that is matching selected beta
                    var lambdas = this._getEndoRoots(this.n);
                    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
                        lambda = lambdas[0];
                    } else {
                        lambda = lambdas[1];
                        assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
                    }
                }
                
                // Get basis vectors, used for balanced length-two representation
                var basis;
                if (conf.basis) {
                    basis = conf.basis.map(function (vec) {
                        return {
                            a: new bn(vec.a, 16),
                            b: new bn(vec.b, 16)
                        };
                    });
                } else {
                    basis = this._getEndoBasis(lambda);
                }
                
                return {
                    beta: beta,
                    lambda: lambda,
                    basis: basis
                };
            };
            
            ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
                // Find roots of for x^2 + x + 1 in F
                // Root = (-1 +- Sqrt(-3)) / 2
                //
                var red = num === this.p ? this.red : bn.mont(num);
                var tinv = new bn(2).toRed(red).redInvm();
                var ntinv = tinv.redNeg();
                
                var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);
                
                var l1 = ntinv.redAdd(s).fromRed();
                var l2 = ntinv.redSub(s).fromRed();
                return [l1, l2];
            };
            
            ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
                // aprxSqrt >= sqrt(this.n)
                var aprxSqrt = this.n.shrn(Math.floor(this.n.bitLength() / 2));
                
                // 3.74
                // Run EGCD, until r(L + 1) < aprxSqrt
                var u = lambda;
                var v = this.n.clone();
                var x1 = new bn(1);
                var y1 = new bn(0);
                var x2 = new bn(0);
                var y2 = new bn(1);
                
                // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
                var a0;
                var b0;
                // First vector
                var a1;
                var b1;
                // Second vector
                var a2;
                var b2;
                
                var prevR;
                var i = 0;
                var r;
                var x;
                while (u.cmpn(0) !== 0) {
                    var q = v.div(u);
                    r = v.sub(q.mul(u));
                    x = x2.sub(q.mul(x1));
                    var y = y2.sub(q.mul(y1));
                    
                    if (!a1 && r.cmp(aprxSqrt) < 0) {
                        a0 = prevR.neg();
                        b0 = x1;
                        a1 = r.neg();
                        b1 = x;
                    } else if (a1 && ++i === 2) {
                        break;
                    }
                    prevR = r;
                    
                    v = u;
                    u = r;
                    x2 = x1;
                    x1 = x;
                    y2 = y1;
                    y1 = y;
                }
                a2 = r.neg();
                b2 = x;
                
                var len1 = a1.sqr().add(b1.sqr());
                var len2 = a2.sqr().add(b2.sqr());
                if (len2.cmp(len1) >= 0) {
                    a2 = a0;
                    b2 = b0;
                }
                
                // Normalize signs
                if (a1.sign) {
                    a1 = a1.neg();
                    b1 = b1.neg();
                }
                if (a2.sign) {
                    a2 = a2.neg();
                    b2 = b2.neg();
                }
                
                return [
                    { a: a1, b: b1 },
                    { a: a2, b: b2 }
                ];
            };
            
            ShortCurve.prototype._endoSplit = function _endoSplit(k) {
                var basis = this.endo.basis;
                var v1 = basis[0];
                var v2 = basis[1];
                
                var c1 = v2.b.mul(k).divRound(this.n);
                var c2 = v1.b.neg().mul(k).divRound(this.n);
                
                var p1 = c1.mul(v1.a);
                var p2 = c2.mul(v2.a);
                var q1 = c1.mul(v1.b);
                var q2 = c2.mul(v2.b);
                
                // Calculate answer
                var k1 = k.sub(p1).sub(p2);
                var k2 = q1.add(q2).neg();
                return { k1: k1, k2: k2 };
            };
            
            ShortCurve.prototype.pointFromX = function pointFromX(odd, x) {
                x = new bn(x, 16);
                if (!x.red)
                    x = x.toRed(this.red);
                
                var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
                var y = y2.redSqrt();
                
                // XXX Is there any way to tell if the number is odd without converting it
                // to non-red form?
                var isOdd = y.fromRed().isOdd();
                if (odd && !isOdd || !odd && isOdd)
                    y = y.redNeg();
                
                return this.point(x, y);
            };
            
            ShortCurve.prototype.validate = function validate(point) {
                if (point.inf)
                    return true;
                
                var x = point.x;
                var y = point.y;
                
                var ax = this.a.redMul(x);
                var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
                return y.redSqr().redISub(rhs).cmpn(0) === 0;
            };
            
            ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs) {
                var npoints = this._endoWnafT1;
                var ncoeffs = this._endoWnafT2;
                for (var i = 0; i < points.length; i++) {
                    var split = this._endoSplit(coeffs[i]);
                    var p = points[i];
                    var beta = p._getBeta();
                    
                    if (split.k1.sign) {
                        split.k1.sign = !split.k1.sign;
                        p = p.neg(true);
                    }
                    if (split.k2.sign) {
                        split.k2.sign = !split.k2.sign;
                        beta = beta.neg(true);
                    }
                    
                    npoints[i * 2] = p;
                    npoints[i * 2 + 1] = beta;
                    ncoeffs[i * 2] = split.k1;
                    ncoeffs[i * 2 + 1] = split.k2;
                }
                var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);
                
                // Clean-up references to points and coefficients
                for (var j = 0; j < i * 2; j++) {
                    npoints[j] = null;
                    ncoeffs[j] = null;
                }
                return res;
            };
            
            function Point(curve, x, y, isRed) {
                Base.BasePoint.call(this, curve, 'affine');
                if (x === null && y === null) {
                    this.x = null;
                    this.y = null;
                    this.inf = true;
                } else {
                    this.x = new bn(x, 16);
                    this.y = new bn(y, 16);
                    // Force redgomery representation when loading from JSON
                    if (isRed) {
                        this.x.forceRed(this.curve.red);
                        this.y.forceRed(this.curve.red);
                    }
                    if (!this.x.red)
                        this.x = this.x.toRed(this.curve.red);
                    if (!this.y.red)
                        this.y = this.y.toRed(this.curve.red);
                    this.inf = false;
                }
            }
            inherits(Point, Base.BasePoint);
            
            ShortCurve.prototype.point = function point(x, y, isRed) {
                return new Point(this, x, y, isRed);
            };
            
            ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
                return Point.fromJSON(this, obj, red);
            };
            
            Point.prototype._getBeta = function _getBeta() {
                if (!this.curve.endo)
                    return;
                
                var pre = this.precomputed;
                if (pre && pre.beta)
                    return pre.beta;
                
                var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                if (pre) {
                    var curve = this.curve;
                    var endoMul = function (p) {
                        return curve.point(p.x.redMul(curve.endo.beta), p.y);
                    };
                    pre.beta = beta;
                    beta.precomputed = {
                        beta: null,
                        naf: pre.naf && {
                            wnd: pre.naf.wnd,
                            points: pre.naf.points.map(endoMul)
                        },
                        doubles: pre.doubles && {
                            step: pre.doubles.step,
                            points: pre.doubles.points.map(endoMul)
                        }
                    };
                }
                return beta;
            };
            
            Point.prototype.toJSON = function toJSON() {
                if (!this.precomputed)
                    return [this.x, this.y];
                
                return [this.x, this.y, this.precomputed && {
                        doubles: this.precomputed.doubles && {
                            step: this.precomputed.doubles.step,
                            points: this.precomputed.doubles.points.slice(1)
                        },
                        naf: this.precomputed.naf && {
                            wnd: this.precomputed.naf.wnd,
                            points: this.precomputed.naf.points.slice(1)
                        }
                    }];
            };
            
            Point.fromJSON = function fromJSON(curve, obj, red) {
                if (typeof obj === 'string')
                    obj = JSON.parse(obj);
                var res = curve.point(obj[0], obj[1], red);
                if (!obj[2])
                    return res;
                
                function obj2point(obj) {
                    return curve.point(obj[0], obj[1], red);
                }
                
                var pre = obj[2];
                res.precomputed = {
                    beta: null,
                    doubles: pre.doubles && {
                        step: pre.doubles.step,
                        points: [res].concat(pre.doubles.points.map(obj2point))
                    },
                    naf: pre.naf && {
                        wnd: pre.naf.wnd,
                        points: [res].concat(pre.naf.points.map(obj2point))
                    }
                };
                return res;
            };
            
            Point.prototype.inspect = function inspect() {
                if (this.isInfinity())
                    return '<EC Point Infinity>';
                return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
            };
            
            Point.prototype.isInfinity = function isInfinity() {
                return this.inf;
            };
            
            Point.prototype.add = function add(p) {
                // O + P = P
                if (this.inf)
                    return p;
                
                // P + O = P
                if (p.inf)
                    return this;
                
                // P + P = 2P
                if (this.eq(p))
                    return this.dbl();
                
                // P + (-P) = O
                if (this.neg().eq(p))
                    return this.curve.point(null, null);
                
                // P + Q = O
                if (this.x.cmp(p.x) === 0)
                    return this.curve.point(null, null);
                
                var c = this.y.redSub(p.y);
                if (c.cmpn(0) !== 0)
                    c = c.redMul(this.x.redSub(p.x).redInvm());
                var nx = c.redSqr().redISub(this.x).redISub(p.x);
                var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
                return this.curve.point(nx, ny);
            };
            
            Point.prototype.dbl = function dbl() {
                if (this.inf)
                    return this;
                
                // 2P = O
                var ys1 = this.y.redAdd(this.y);
                if (ys1.cmpn(0) === 0)
                    return this.curve.point(null, null);
                
                var a = this.curve.a;
                
                var x2 = this.x.redSqr();
                var dyinv = ys1.redInvm();
                var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
                
                var nx = c.redSqr().redISub(this.x.redAdd(this.x));
                var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
                return this.curve.point(nx, ny);
            };
            
            Point.prototype.getX = function getX() {
                return this.x.fromRed();
            };
            
            Point.prototype.getY = function getY() {
                return this.y.fromRed();
            };
            
            Point.prototype.mul = function mul(k) {
                k = new bn(k, 16);
                
                if (this._hasDoubles(k))
                    return this.curve._fixedNafMul(this, k);
                else if (this.curve.endo)
                    return this.curve._endoWnafMulAdd([this], [k]);
                else
                    return this.curve._wnafMul(this, k);
            };
            
            Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
                var points = [this, p2];
                var coeffs = [k1, k2];
                if (this.curve.endo)
                    return this.curve._endoWnafMulAdd(points, coeffs);
                else
                    return this.curve._wnafMulAdd(1, points, coeffs, 2);
            };
            
            Point.prototype.eq = function eq(p) {
                return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
            };
            
            Point.prototype.neg = function neg(_precompute) {
                if (this.inf)
                    return this;
                
                var res = this.curve.point(this.x, this.y.redNeg());
                if (_precompute && this.precomputed) {
                    var pre = this.precomputed;
                    var negate = function (p) {
                        return p.neg();
                    };
                    res.precomputed = {
                        naf: pre.naf && {
                            wnd: pre.naf.wnd,
                            points: pre.naf.points.map(negate)
                        },
                        doubles: pre.doubles && {
                            step: pre.doubles.step,
                            points: pre.doubles.points.map(negate)
                        }
                    };
                }
                return res;
            };
            
            Point.prototype.toJ = function toJ() {
                if (this.inf)
                    return this.curve.jpoint(null, null, null);
                
                var res = this.curve.jpoint(this.x, this.y, this.curve.one);
                return res;
            };
            
            function JPoint(curve, x, y, z) {
                Base.BasePoint.call(this, curve, 'jacobian');
                if (x === null && y === null && z === null) {
                    this.x = this.curve.one;
                    this.y = this.curve.one;
                    this.z = new bn(0);
                } else {
                    this.x = new bn(x, 16);
                    this.y = new bn(y, 16);
                    this.z = new bn(z, 16);
                }
                if (!this.x.red)
                    this.x = this.x.toRed(this.curve.red);
                if (!this.y.red)
                    this.y = this.y.toRed(this.curve.red);
                if (!this.z.red)
                    this.z = this.z.toRed(this.curve.red);
                
                this.zOne = this.z === this.curve.one;
            }
            inherits(JPoint, Base.BasePoint);
            
            ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
                return new JPoint(this, x, y, z);
            };
            
            JPoint.prototype.toP = function toP() {
                if (this.isInfinity())
                    return this.curve.point(null, null);
                
                var zinv = this.z.redInvm();
                var zinv2 = zinv.redSqr();
                var ax = this.x.redMul(zinv2);
                var ay = this.y.redMul(zinv2).redMul(zinv);
                
                return this.curve.point(ax, ay);
            };
            
            JPoint.prototype.neg = function neg() {
                return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
            };
            
            JPoint.prototype.add = function add(p) {
                // O + P = P
                if (this.isInfinity())
                    return p;
                
                // P + O = P
                if (p.isInfinity())
                    return this;
                
                // 12M + 4S + 7A
                var pz2 = p.z.redSqr();
                var z2 = this.z.redSqr();
                var u1 = this.x.redMul(pz2);
                var u2 = p.x.redMul(z2);
                var s1 = this.y.redMul(pz2.redMul(p.z));
                var s2 = p.y.redMul(z2.redMul(this.z));
                
                var h = u1.redSub(u2);
                var r = s1.redSub(s2);
                if (h.cmpn(0) === 0) {
                    if (r.cmpn(0) !== 0)
                        return this.curve.jpoint(null, null, null);
                    else
                        return this.dbl();
                }
                
                var h2 = h.redSqr();
                var h3 = h2.redMul(h);
                var v = u1.redMul(h2);
                
                var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
                var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
                var nz = this.z.redMul(p.z).redMul(h);
                
                return this.curve.jpoint(nx, ny, nz);
            };
            
            JPoint.prototype.mixedAdd = function mixedAdd(p) {
                // O + P = P
                if (this.isInfinity())
                    return p.toJ();
                
                // P + O = P
                if (p.isInfinity())
                    return this;
                
                // 8M + 3S + 7A
                var z2 = this.z.redSqr();
                var u1 = this.x;
                var u2 = p.x.redMul(z2);
                var s1 = this.y;
                var s2 = p.y.redMul(z2).redMul(this.z);
                
                var h = u1.redSub(u2);
                var r = s1.redSub(s2);
                if (h.cmpn(0) === 0) {
                    if (r.cmpn(0) !== 0)
                        return this.curve.jpoint(null, null, null);
                    else
                        return this.dbl();
                }
                
                var h2 = h.redSqr();
                var h3 = h2.redMul(h);
                var v = u1.redMul(h2);
                
                var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
                var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
                var nz = this.z.redMul(h);
                
                return this.curve.jpoint(nx, ny, nz);
            };
            
            JPoint.prototype.dblp = function dblp(pow) {
                if (pow === 0)
                    return this;
                if (this.isInfinity())
                    return this;
                if (!pow)
                    return this.dbl();
                
                if (this.curve.zeroA || this.curve.threeA) {
                    var r = this;
                    for (var i = 0; i < pow; i++)
                        r = r.dbl();
                    return r;
                }
                
                // 1M + 2S + 1A + N * (4S + 5M + 8A)
                // N = 1 => 6M + 6S + 9A
                var a = this.curve.a;
                var tinv = this.curve.tinv;
                
                var jx = this.x;
                var jy = this.y;
                var jz = this.z;
                var jz4 = jz.redSqr().redSqr();
                
                // Reuse results
                var jyd = jy.redAdd(jy);
                for (var i = 0; i < pow; i++) {
                    var jx2 = jx.redSqr();
                    var jyd2 = jyd.redSqr();
                    var jyd4 = jyd2.redSqr();
                    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
                    
                    var t1 = jx.redMul(jyd2);
                    var nx = c.redSqr().redISub(t1.redAdd(t1));
                    var t2 = t1.redISub(nx);
                    var dny = c.redMul(t2);
                    dny = dny.redIAdd(dny).redISub(jyd4);
                    var nz = jyd.redMul(jz);
                    if (i + 1 < pow)
                        jz4 = jz4.redMul(jyd4);
                    
                    jx = nx;
                    jz = nz;
                    jyd = dny;
                }
                
                return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
            };
            
            JPoint.prototype.dbl = function dbl() {
                if (this.isInfinity())
                    return this;
                
                if (this.curve.zeroA)
                    return this._zeroDbl();
                else if (this.curve.threeA)
                    return this._threeDbl();
                else
                    return this._dbl();
            };
            
            JPoint.prototype._zeroDbl = function _zeroDbl() {
                var nx;
                var ny;
                var nz;
                // Z = 1
                if (this.zOne) {
                    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
                    //     #doubling-mdbl-2007-bl
                    // 1M + 5S + 14A
                    
                    // XX = X1^2
                    var xx = this.x.redSqr();
                    // YY = Y1^2
                    var yy = this.y.redSqr();
                    // YYYY = YY^2
                    var yyyy = yy.redSqr();
                    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
                    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                    s = s.redIAdd(s);
                    // M = 3 * XX + a; a = 0
                    var m = xx.redAdd(xx).redIAdd(xx);
                    // T = M ^ 2 - 2*S
                    var t = m.redSqr().redISub(s).redISub(s);
                    
                    // 8 * YYYY
                    var yyyy8 = yyyy.redIAdd(yyyy);
                    yyyy8 = yyyy8.redIAdd(yyyy8);
                    yyyy8 = yyyy8.redIAdd(yyyy8);
                    
                    // X3 = T
                    nx = t;
                    // Y3 = M * (S - T) - 8 * YYYY
                    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
                    // Z3 = 2*Y1
                    nz = this.y.redAdd(this.y);
                } else {
                    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
                    //     #doubling-dbl-2009-l
                    // 2M + 5S + 13A
                    
                    // A = X1^2
                    var a = this.x.redSqr();
                    // B = Y1^2
                    var b = this.y.redSqr();
                    // C = B^2
                    var c = b.redSqr();
                    // D = 2 * ((X1 + B)^2 - A - C)
                    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
                    d = d.redIAdd(d);
                    // E = 3 * A
                    var e = a.redAdd(a).redIAdd(a);
                    // F = E^2
                    var f = e.redSqr();
                    
                    // 8 * C
                    var c8 = c.redIAdd(c);
                    c8 = c8.redIAdd(c8);
                    c8 = c8.redIAdd(c8);
                    
                    // X3 = F - 2 * D
                    nx = f.redISub(d).redISub(d);
                    // Y3 = E * (D - X3) - 8 * C
                    ny = e.redMul(d.redISub(nx)).redISub(c8);
                    // Z3 = 2 * Y1 * Z1
                    nz = this.y.redMul(this.z);
                    nz = nz.redIAdd(nz);
                }
                
                return this.curve.jpoint(nx, ny, nz);
            };
            
            JPoint.prototype._threeDbl = function _threeDbl() {
                var nx;
                var ny;
                var nz;
                // Z = 1
                if (this.zOne) {
                    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
                    //     #doubling-mdbl-2007-bl
                    // 1M + 5S + 15A
                    
                    // XX = X1^2
                    var xx = this.x.redSqr();
                    // YY = Y1^2
                    var yy = this.y.redSqr();
                    // YYYY = YY^2
                    var yyyy = yy.redSqr();
                    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
                    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                    s = s.redIAdd(s);
                    // M = 3 * XX + a
                    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
                    // T = M^2 - 2 * S
                    var t = m.redSqr().redISub(s).redISub(s);
                    // X3 = T
                    nx = t;
                    // Y3 = M * (S - T) - 8 * YYYY
                    var yyyy8 = yyyy.redIAdd(yyyy);
                    yyyy8 = yyyy8.redIAdd(yyyy8);
                    yyyy8 = yyyy8.redIAdd(yyyy8);
                    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
                    // Z3 = 2 * Y1
                    nz = this.y.redAdd(this.y);
                } else {
                    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
                    // 3M + 5S
                    
                    // delta = Z1^2
                    var delta = this.z.redSqr();
                    // gamma = Y1^2
                    var gamma = this.y.redSqr();
                    // beta = X1 * gamma
                    var beta = this.x.redMul(gamma);
                    // alpha = 3 * (X1 - delta) * (X1 + delta)
                    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
                    alpha = alpha.redAdd(alpha).redIAdd(alpha);
                    // X3 = alpha^2 - 8 * beta
                    var beta4 = beta.redIAdd(beta);
                    beta4 = beta4.redIAdd(beta4);
                    var beta8 = beta4.redAdd(beta4);
                    nx = alpha.redSqr().redISub(beta8);
                    // Z3 = (Y1 + Z1)^2 - gamma - delta
                    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
                    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
                    var ggamma8 = gamma.redSqr();
                    ggamma8 = ggamma8.redIAdd(ggamma8);
                    ggamma8 = ggamma8.redIAdd(ggamma8);
                    ggamma8 = ggamma8.redIAdd(ggamma8);
                    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
                }
                
                return this.curve.jpoint(nx, ny, nz);
            };
            
            JPoint.prototype._dbl = function _dbl() {
                var a = this.curve.a;
                
                // 4M + 6S + 10A
                var jx = this.x;
                var jy = this.y;
                var jz = this.z;
                var jz4 = jz.redSqr().redSqr();
                
                var jx2 = jx.redSqr();
                var jy2 = jy.redSqr();
                
                var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
                
                var jxd4 = jx.redAdd(jx);
                jxd4 = jxd4.redIAdd(jxd4);
                var t1 = jxd4.redMul(jy2);
                var nx = c.redSqr().redISub(t1.redAdd(t1));
                var t2 = t1.redISub(nx);
                
                var jyd8 = jy2.redSqr();
                jyd8 = jyd8.redIAdd(jyd8);
                jyd8 = jyd8.redIAdd(jyd8);
                jyd8 = jyd8.redIAdd(jyd8);
                var ny = c.redMul(t2).redISub(jyd8);
                var nz = jy.redAdd(jy).redMul(jz);
                
                return this.curve.jpoint(nx, ny, nz);
            };
            
            JPoint.prototype.trpl = function trpl() {
                if (!this.curve.zeroA)
                    return this.dbl().add(this);
                
                // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
                // 5M + 10S + ...
                
                // XX = X1^2
                var xx = this.x.redSqr();
                // YY = Y1^2
                var yy = this.y.redSqr();
                // ZZ = Z1^2
                var zz = this.z.redSqr();
                // YYYY = YY^2
                var yyyy = yy.redSqr();
                // M = 3 * XX + a * ZZ2; a = 0
                var m = xx.redAdd(xx).redIAdd(xx);
                // MM = M^2
                var mm = m.redSqr();
                // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
                var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
                e = e.redIAdd(e);
                e = e.redAdd(e).redIAdd(e);
                e = e.redISub(mm);
                // EE = E^2
                var ee = e.redSqr();
                // T = 16*YYYY
                var t = yyyy.redIAdd(yyyy);
                t = t.redIAdd(t);
                t = t.redIAdd(t);
                t = t.redIAdd(t);
                // U = (M + E)^2 - MM - EE - T
                var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
                // X3 = 4 * (X1 * EE - 4 * YY * U)
                var yyu4 = yy.redMul(u);
                yyu4 = yyu4.redIAdd(yyu4);
                yyu4 = yyu4.redIAdd(yyu4);
                var nx = this.x.redMul(ee).redISub(yyu4);
                nx = nx.redIAdd(nx);
                nx = nx.redIAdd(nx);
                // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
                var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
                ny = ny.redIAdd(ny);
                ny = ny.redIAdd(ny);
                ny = ny.redIAdd(ny);
                // Z3 = (Z1 + E)^2 - ZZ - EE
                var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
                
                return this.curve.jpoint(nx, ny, nz);
            };
            
            JPoint.prototype.mul = function mul(k, kbase) {
                k = new bn(k, kbase);
                
                return this.curve._wnafMul(this, k);
            };
            
            JPoint.prototype.eq = function eq(p) {
                if (p.type === 'affine')
                    return this.eq(p.toJ());
                
                if (this === p)
                    return true;
                
                // x1 * z2^2 == x2 * z1^2
                var z2 = this.z.redSqr();
                var pz2 = p.z.redSqr();
                if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
                    return false;
                
                // y1 * z2^3 == y2 * z1^3
                var z3 = z2.redMul(this.z);
                var pz3 = pz2.redMul(p.z);
                return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
            };
            
            JPoint.prototype.inspect = function inspect() {
                if (this.isInfinity())
                    return '<EC JPoint Infinity>';
                return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
            };
            
            JPoint.prototype.isInfinity = function isInfinity() {
                // XXX This code assumes that zero is always zero in red
                return this.z.cmpn(0) === 0;
            };

        }, { "../../elliptic": 200, "../curve": 203, "bn.js": 198, "inherits": 318 }], 206: [function (require, module, exports) {
            'use strict';
            
            var curves = exports;
            
            var hash = require('hash.js');
            var elliptic = require('../elliptic');
            
            var assert = elliptic.utils.assert;
            
            function PresetCurve(options) {
                if (options.type === 'short')
                    this.curve = new elliptic.curve.short(options);
                else if (options.type === 'edwards')
                    this.curve = new elliptic.curve.edwards(options);
                else
                    this.curve = new elliptic.curve.mont(options);
                this.g = this.curve.g;
                this.n = this.curve.n;
                this.hash = options.hash;
                
                assert(this.g.validate(), 'Invalid curve');
                assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
            }
            curves.PresetCurve = PresetCurve;
            
            function defineCurve(name, options) {
                Object.defineProperty(curves, name, {
                    configurable: true,
                    enumerable: true,
                    get: function () {
                        var curve = new PresetCurve(options);
                        Object.defineProperty(curves, name, {
                            configurable: true,
                            enumerable: true,
                            value: curve
                        });
                        return curve;
                    }
                });
            }
            
            defineCurve('p192', {
                type: 'short',
                prime: 'p192',
                p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
                a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
                b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
                n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
                hash: hash.sha256,
                gRed: false,
                g: [
                    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
                    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
                ]
            });
            
            defineCurve('p224', {
                type: 'short',
                prime: 'p224',
                p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
                a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
                b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
                n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
                hash: hash.sha256,
                gRed: false,
                g: [
                    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
                    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
                ]
            });
            
            defineCurve('p256', {
                type: 'short',
                prime: null,
                p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
                a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
                b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
                n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
                hash: hash.sha256,
                gRed: false,
                g: [
                    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
                    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
                ]
            });
            
            defineCurve('curve25519', {
                type: 'mont',
                prime: 'p25519',
                p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                a: '76d06',
                b: '0',
                n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
                hash: hash.sha256,
                gRed: false,
                g: [
                    '9'
                ]
            });
            
            defineCurve('ed25519', {
                type: 'edwards',
                prime: 'p25519',
                p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
                a: '-1',
                c: '1',
                // -121665 * (121666^(-1)) (mod P)
                d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
                n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
                hash: hash.sha256,
                gRed: false,
                g: [
                    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
                    '6666666666666666666666666666666666666666666666666666666666666658'
                ]
            });
            
            var pre;
            try {
                pre = require('./precomputed/secp256k1');
            } catch (e) {
                pre = undefined;
            }
            
            defineCurve('secp256k1', {
                type: 'short',
                prime: 'k256',
                p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
                a: '0',
                b: '7',
                n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
                h: '1',
                hash: hash.sha256,
                
                // Precomputed endomorphism
                beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
                lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
                basis: [
                    {
                        a: '3086d221a7d46bcde86c90e49284eb15',
                        b: '-e4437ed6010e88286f547fa90abfe4c3'
                    },
                    {
                        a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
                        b: '3086d221a7d46bcde86c90e49284eb15'
                    }
                ],
                
                gRed: false,
                g: [
                    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
                    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
                    pre
                ]
            });

        }, { "../elliptic": 200, "./precomputed/secp256k1": 211, "hash.js": 214 }], 207: [function (require, module, exports) {
            'use strict';
            
            var bn = require('bn.js');
            var elliptic = require('../../elliptic');
            var utils = elliptic.utils;
            var assert = utils.assert;
            
            var KeyPair = require('./key');
            var Signature = require('./signature');
            
            function EC(options) {
                if (!(this instanceof EC))
                    return new EC(options);
                
                // Shortcut `elliptic.ec(curve-name)`
                if (typeof options === 'string') {
                    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);
                    
                    options = elliptic.curves[options];
                }
                
                // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
                if (options instanceof elliptic.curves.PresetCurve)
                    options = { curve: options };
                
                this.curve = options.curve.curve;
                this.n = this.curve.n;
                this.nh = this.n.shrn(1);
                this.g = this.curve.g;
                
                // Point on curve
                this.g = options.curve.g;
                this.g.precompute(options.curve.n.bitLength() + 1);
                
                // Hash for function for DRBG
                this.hash = options.hash || options.curve.hash;
            }
            module.exports = EC;
            
            EC.prototype.keyPair = function keyPair(options) {
                return new KeyPair(this, options);
            };
            
            EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
                return KeyPair.fromPrivate(this, priv, enc);
            };
            
            EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
                return KeyPair.fromPublic(this, pub, enc);
            };
            
            EC.prototype.genKeyPair = function genKeyPair(options) {
                if (!options)
                    options = {};
                
                // Instantiate Hmac_DRBG
                var drbg = new elliptic.hmacDRBG({
                    hash: this.hash,
                    pers: options.pers,
                    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
                    nonce: this.n.toArray()
                });
                
                var bytes = this.n.byteLength();
                var ns2 = this.n.sub(new bn(2));
                do {
                    var priv = new bn(drbg.generate(bytes));
                    if (priv.cmp(ns2) > 0)
                        continue;
                    
                    priv.iaddn(1);
                    return this.keyFromPrivate(priv);
                } while (true);
            };
            
            EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
                var delta = msg.byteLength() * 8 - this.n.bitLength();
                if (delta > 0)
                    msg = msg.shrn(delta);
                if (!truncOnly && msg.cmp(this.n) >= 0)
                    return msg.sub(this.n);
                else
                    return msg;
            };
            
            EC.prototype.sign = function sign(msg, key, enc, options) {
                if (typeof enc === 'object') {
                    options = enc;
                    enc = null;
                }
                if (!options)
                    options = {};
                
                key = this.keyFromPrivate(key, enc);
                msg = this._truncateToN(new bn(msg, 16));
                
                // Zero-extend key to provide enough entropy
                var bytes = this.n.byteLength();
                var bkey = key.getPrivate().toArray();
                for (var i = bkey.length; i < 21; i++)
                    bkey.unshift(0);
                
                // Zero-extend nonce to have the same byte size as N
                var nonce = msg.toArray();
                for (var i = nonce.length; i < bytes; i++)
                    nonce.unshift(0);
                
                // Instantiate Hmac_DRBG
                var drbg = new elliptic.hmacDRBG({
                    hash: this.hash,
                    entropy: bkey,
                    nonce: nonce
                });
                
                // Number of bytes to generate
                var ns1 = this.n.sub(new bn(1));
                do {
                    var k = new bn(drbg.generate(this.n.byteLength()));
                    k = this._truncateToN(k, true);
                    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
                        continue;
                    
                    var kp = this.g.mul(k);
                    if (kp.isInfinity())
                        continue;
                    
                    var kpX = kp.getX();
                    var r = kpX.mod(this.n);
                    if (r.cmpn(0) === 0)
                        continue;
                    
                    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg)).mod(this.n);
                    if (s.cmpn(0) === 0)
                        continue;
                    
                    // Use complement of `s`, if it is > `n / 2`
                    if (options.canonical && s.cmp(this.nh) > 0)
                        s = this.n.sub(s);
                    
                    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);
                    
                    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
                } while (true);
            };
            
            EC.prototype.verify = function verify(msg, signature, key, enc) {
                msg = this._truncateToN(new bn(msg, 16));
                key = this.keyFromPublic(key, enc);
                signature = new Signature(signature, 'hex');
                
                // Perform primitive values validation
                var r = signature.r;
                var s = signature.s;
                if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
                    return false;
                if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
                    return false;
                
                // Validate signature
                var sinv = s.invm(this.n);
                var u1 = sinv.mul(msg).mod(this.n);
                var u2 = sinv.mul(r).mod(this.n);
                
                var p = this.g.mulAdd(u1, key.getPublic(), u2);
                if (p.isInfinity())
                    return false;
                
                return p.getX().mod(this.n).cmp(r) === 0;
            };
            
            EC.prototype.recoverPubKey = function (msg, signature, j, enc) {
                assert((3 & j) === j, 'The recovery param is more than two bits');
                signature = new Signature(signature, enc);
                
                var n = this.n;
                var e = new bn(msg);
                var r = signature.r;
                var s = signature.s;
                
                // A set LSB signifies that the y-coordinate is odd
                var isYOdd = j & 1;
                var isSecondKey = j >> 1;
                if (r.cmp(this.curve.p.mod(this.curve.n)) >= 0 && isSecondKey)
                    throw new Error('Unable to find sencond key candinate');
                
                // 1.1. Let x = r + jn.
                r = this.curve.pointFromX(isYOdd, r);
                var eNeg = e.neg().mod(n);
                
                // 1.6.1 Compute Q = r^-1 (sR -  eG)
                //               Q = r^-1 (sR + -eG)
                var rInv = signature.r.invm(n);
                return r.mul(s).add(this.g.mul(eNeg)).mul(rInv);
            };
            
            EC.prototype.getKeyRecoveryParam = function (e, signature, Q, enc) {
                signature = new Signature(signature, enc);
                if (signature.recoveryParam !== null)
                    return signature.recoveryParam;
                
                for (var i = 0; i < 4; i++) {
                    var Qprime = this.recoverPubKey(e, signature, i);
                    
                    if (Qprime.eq(Q))
                        return i;
                }
                throw new Error('Unable to find valid recovery factor');
            };

        }, { "../../elliptic": 200, "./key": 208, "./signature": 209, "bn.js": 198 }], 208: [function (require, module, exports) {
            'use strict';
            
            var bn = require('bn.js');
            
            var elliptic = require('../../elliptic');
            var utils = elliptic.utils;
            
            function KeyPair(ec, options) {
                this.ec = ec;
                this.priv = null;
                this.pub = null;
                
                // KeyPair(ec, { priv: ..., pub: ... })
                if (options.priv)
                    this._importPrivate(options.priv, options.privEnc);
                if (options.pub)
                    this._importPublic(options.pub, options.pubEnc);
            }
            module.exports = KeyPair;
            
            KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
                if (pub instanceof KeyPair)
                    return pub;
                
                return new KeyPair(ec, {
                    pub: pub,
                    pubEnc: enc
                });
            };
            
            KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
                if (priv instanceof KeyPair)
                    return priv;
                
                return new KeyPair(ec, {
                    priv: priv,
                    privEnc: enc
                });
            };
            
            KeyPair.prototype.validate = function validate() {
                var pub = this.getPublic();
                
                if (pub.isInfinity())
                    return { result: false, reason: 'Invalid public key' };
                if (!pub.validate())
                    return { result: false, reason: 'Public key is not a point' };
                if (!pub.mul(this.ec.curve.n).isInfinity())
                    return { result: false, reason: 'Public key * N != O' };
                
                return { result: true, reason: null };
            };
            
            KeyPair.prototype.getPublic = function getPublic(compact, enc) {
                if (!this.pub)
                    this.pub = this.ec.g.mul(this.priv);
                
                // compact is optional argument
                if (typeof compact === 'string') {
                    enc = compact;
                    compact = null;
                }
                
                if (!enc)
                    return this.pub;
                
                var len = this.ec.curve.p.byteLength();
                var x = this.pub.getX().toArray();
                
                for (var i = x.length; i < len; i++)
                    x.unshift(0);
                
                var res;
                if (this.ec.curve.type !== 'mont') {
                    if (compact) {
                        res = [this.pub.getY().isEven() ? 0x02 : 0x03].concat(x);
                    } else {
                        var y = this.pub.getY().toArray();
                        for (var i = y.length; i < len; i++)
                            y.unshift(0);
                        var res = [0x04].concat(x, y);
                    }
                } else {
                    res = x;
                }
                
                return utils.encode(res, enc);
            };
            
            KeyPair.prototype.getPrivate = function getPrivate(enc) {
                if (enc === 'hex')
                    return this.priv.toString(16, 2);
                else
                    return this.priv;
            };
            
            KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
                this.priv = new bn(key, enc || 16);
                
                // Ensure that the priv won't be bigger than n, otherwise we may fail
                // in fixed multiplication method
                this.priv = this.priv.mod(this.ec.curve.n);
            };
            
            KeyPair.prototype._importPublic = function _importPublic(key, enc) {
                if (key.x || key.y) {
                    this.pub = this.ec.curve.point(key.x, key.y);
                    return;
                }
                
                key = utils.toArray(key, enc);
                if (this.ec.curve.type !== 'mont')
                    return this._importPublicShort(key);
                else
                    return this._importPublicMont(key);
            };
            
            KeyPair.prototype._importPublicShort = function _importPublicShort(key) {
                var len = this.ec.curve.p.byteLength();
                if (key[0] === 0x04 && key.length - 1 === 2 * len) {
                    this.pub = this.ec.curve.point(
                        key.slice(1, 1 + len),
      key.slice(1 + len, 1 + 2 * len));
                } else if ((key[0] === 0x02 || key[0] === 0x03) && key.length - 1 === len) {
                    this.pub = this.ec.curve.pointFromX(key[0] === 0x03, key.slice(1, 1 + len));
                }
            };
            
            KeyPair.prototype._importPublicMont = function _importPublicMont(key) {
                this.pub = this.ec.curve.point(key, 1);
            };
            
            // ECDH
            KeyPair.prototype.derive = function derive(pub) {
                return pub.mul(this.priv).getX();
            };
            
            // ECDSA
            KeyPair.prototype.sign = function sign(msg) {
                return this.ec.sign(msg, this);
            };
            
            KeyPair.prototype.verify = function verify(msg, signature) {
                return this.ec.verify(msg, signature, this);
            };
            
            KeyPair.prototype.inspect = function inspect() {
                return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
            };

        }, { "../../elliptic": 200, "bn.js": 198 }], 209: [function (require, module, exports) {
            'use strict';
            
            var bn = require('bn.js');
            
            var elliptic = require('../../elliptic');
            var utils = elliptic.utils;
            var assert = utils.assert;
            
            function Signature(options, enc) {
                if (options instanceof Signature)
                    return options;
                
                if (this._importDER(options, enc))
                    return;
                
                assert(options.r && options.s, 'Signature without r or s');
                this.r = new bn(options.r, 16);
                this.s = new bn(options.s, 16);
                if (options.recoveryParam !== null)
                    this.recoveryParam = options.recoveryParam;
                else
                    this.recoveryParam = null;
            }
            module.exports = Signature;
            
            Signature.prototype._importDER = function _importDER(data, enc) {
                data = utils.toArray(data, enc);
                if (data.length < 6 || data[0] !== 0x30 || data[2] !== 0x02)
                    return false;
                var total = data[1];
                if (1 + total > data.length)
                    return false;
                var rlen = data[3];
                // Short length notation
                if (rlen >= 0x80)
                    return false;
                if (4 + rlen + 2 >= data.length)
                    return false;
                if (data[4 + rlen] !== 0x02)
                    return false;
                var slen = data[5 + rlen];
                // Short length notation
                if (slen >= 0x80)
                    return false;
                if (4 + rlen + 2 + slen > data.length)
                    return false;
                
                this.r = new bn(data.slice(4, 4 + rlen));
                this.s = new bn(data.slice(4 + rlen + 2, 4 + rlen + 2 + slen));
                this.recoveryParam = null;
                
                return true;
            };
            
            Signature.prototype.toDER = function toDER(enc) {
                var r = this.r.toArray();
                var s = this.s.toArray();
                
                // Pad values
                if (r[0] & 0x80)
                    r = [0].concat(r);
                // Pad values
                if (s[0] & 0x80)
                    s = [0].concat(s);
                
                var total = r.length + s.length + 4;
                var res = [0x30, total, 0x02, r.length];
                res = res.concat(r, [0x02, s.length], s);
                return utils.encode(res, enc);
            };

        }, { "../../elliptic": 200, "bn.js": 198 }], 210: [function (require, module, exports) {
            'use strict';
            
            var hash = require('hash.js');
            var elliptic = require('../elliptic');
            var utils = elliptic.utils;
            var assert = utils.assert;
            
            function HmacDRBG(options) {
                if (!(this instanceof HmacDRBG))
                    return new HmacDRBG(options);
                this.hash = options.hash;
                this.predResist = !!options.predResist;
                
                this.outLen = this.hash.outSize;
                this.minEntropy = options.minEntropy || this.hash.hmacStrength;
                
                this.reseed = null;
                this.reseedInterval = null;
                this.K = null;
                this.V = null;
                
                var entropy = utils.toArray(options.entropy, options.entropyEnc);
                var nonce = utils.toArray(options.nonce, options.nonceEnc);
                var pers = utils.toArray(options.pers, options.persEnc);
                assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
                this._init(entropy, nonce, pers);
            }
            module.exports = HmacDRBG;
            
            HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
                var seed = entropy.concat(nonce).concat(pers);
                
                this.K = new Array(this.outLen / 8);
                this.V = new Array(this.outLen / 8);
                for (var i = 0; i < this.V.length; i++) {
                    this.K[i] = 0x00;
                    this.V[i] = 0x01;
                }
                
                this._update(seed);
                this.reseed = 1;
                this.reseedInterval = 0x1000000000000;  // 2^48
            };
            
            HmacDRBG.prototype._hmac = function hmac() {
                return new hash.hmac(this.hash, this.K);
            };
            
            HmacDRBG.prototype._update = function update(seed) {
                var kmac = this._hmac()
                 .update(this.V)
                 .update([0x00]);
                if (seed)
                    kmac = kmac.update(seed);
                this.K = kmac.digest();
                this.V = this._hmac().update(this.V).digest();
                if (!seed)
                    return;
                
                this.K = this._hmac()
               .update(this.V)
               .update([0x01])
               .update(seed)
               .digest();
                this.V = this._hmac().update(this.V).digest();
            };
            
            HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
                // Optional entropy enc
                if (typeof entropyEnc !== 'string') {
                    addEnc = add;
                    add = entropyEnc;
                    entropyEnc = null;
                }
                
                entropy = utils.toBuffer(entropy, entropyEnc);
                add = utils.toBuffer(add, addEnc);
                
                assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
                
                this._update(entropy.concat(add || []));
                this.reseed = 1;
            };
            
            HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
                if (this.reseed > this.reseedInterval)
                    throw new Error('Reseed is required');
                
                // Optional encoding
                if (typeof enc !== 'string') {
                    addEnc = add;
                    add = enc;
                    enc = null;
                }
                
                // Optional additional data
                if (add) {
                    add = utils.toArray(add, addEnc);
                    this._update(add);
                }
                
                var temp = [];
                while (temp.length < len) {
                    this.V = this._hmac().update(this.V).digest();
                    temp = temp.concat(this.V);
                }
                
                var res = temp.slice(0, len);
                this._update(add);
                this.reseed++;
                return utils.encode(res, enc);
            };

        }, { "../elliptic": 200, "hash.js": 214 }], 211: [function (require, module, exports) {
            module.exports = {
                doubles: {
                    step: 4,
                    points: [
                        [
                            'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
                            'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
                        ],
                        [
                            '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
                            '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
                        ],
                        [
                            '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
                            'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
                        ],
                        [
                            '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
                            '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
                        ],
                        [
                            '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
                            '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
                        ],
                        [
                            '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
                            '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
                        ],
                        [
                            'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
                            '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
                        ],
                        [
                            '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
                            'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
                        ],
                        [
                            'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
                            '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
                        ],
                        [
                            'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
                            'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
                        ],
                        [
                            'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
                            '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
                        ],
                        [
                            '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
                            '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
                        ],
                        [
                            '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
                            '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
                        ],
                        [
                            '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
                            '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
                        ],
                        [
                            '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
                            '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
                        ],
                        [
                            '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
                            '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
                        ],
                        [
                            '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
                            '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
                        ],
                        [
                            '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
                            '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
                        ],
                        [
                            '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
                            'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
                        ],
                        [
                            'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
                            '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
                        ],
                        [
                            'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
                            '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
                        ],
                        [
                            '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
                            '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
                        ],
                        [
                            '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
                            '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
                        ],
                        [
                            'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
                            '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
                        ],
                        [
                            '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
                            'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
                        ],
                        [
                            'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
                            '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
                        ],
                        [
                            'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
                            'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
                        ],
                        [
                            'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
                            '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
                        ],
                        [
                            'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
                            'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
                        ],
                        [
                            'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
                            '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
                        ],
                        [
                            '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
                            'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
                        ],
                        [
                            '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
                            '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
                        ],
                        [
                            'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
                            '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
                        ],
                        [
                            '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
                            'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
                        ],
                        [
                            'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
                            '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
                        ],
                        [
                            'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
                            '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
                        ],
                        [
                            'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
                            'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
                        ],
                        [
                            '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
                            '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
                        ],
                        [
                            '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
                            '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
                        ],
                        [
                            '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
                            'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
                        ],
                        [
                            '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
                            '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
                        ],
                        [
                            'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
                            '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
                        ],
                        [
                            '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
                            '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
                        ],
                        [
                            '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
                            'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
                        ],
                        [
                            '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
                            '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
                        ],
                        [
                            'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
                            '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
                        ],
                        [
                            '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
                            'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
                        ],
                        [
                            'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
                            'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
                        ],
                        [
                            'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
                            '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
                        ],
                        [
                            '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
                            'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
                        ],
                        [
                            '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
                            'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
                        ],
                        [
                            'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
                            '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
                        ],
                        [
                            'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
                            '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
                        ],
                        [
                            'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
                            '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
                        ],
                        [
                            '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
                            'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
                        ],
                        [
                            '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
                            '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
                        ],
                        [
                            'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
                            'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
                        ],
                        [
                            '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
                            'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
                        ],
                        [
                            '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
                            '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
                        ],
                        [
                            '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
                            '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
                        ],
                        [
                            'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
                            'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
                        ],
                        [
                            '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
                            '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
                        ],
                        [
                            '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
                            '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
                        ],
                        [
                            'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
                            '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
                        ],
                        [
                            'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
                            'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
                        ]
                    ]
                },
                naf: {
                    wnd: 7,
                    points: [
                        [
                            'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
                            '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
                        ],
                        [
                            '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
                            'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
                        ],
                        [
                            '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
                            '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
                        ],
                        [
                            'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
                            'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
                        ],
                        [
                            '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
                            'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
                        ],
                        [
                            'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
                            'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
                        ],
                        [
                            'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
                            '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
                        ],
                        [
                            'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
                            '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
                        ],
                        [
                            '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
                            '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
                        ],
                        [
                            '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
                            '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
                        ],
                        [
                            '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
                            '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
                        ],
                        [
                            '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
                            '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
                        ],
                        [
                            'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
                            'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
                        ],
                        [
                            'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
                            '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
                        ],
                        [
                            '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
                            'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
                        ],
                        [
                            '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
                            'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
                        ],
                        [
                            '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
                            '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
                        ],
                        [
                            '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
                            '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
                        ],
                        [
                            '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
                            '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
                        ],
                        [
                            '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
                            'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
                        ],
                        [
                            'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
                            'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
                        ],
                        [
                            '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
                            '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
                        ],
                        [
                            '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
                            '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
                        ],
                        [
                            'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
                            'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
                        ],
                        [
                            '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
                            '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
                        ],
                        [
                            'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
                            'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
                        ],
                        [
                            'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
                            'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
                        ],
                        [
                            '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
                            '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
                        ],
                        [
                            '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
                            '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
                        ],
                        [
                            '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
                            '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
                        ],
                        [
                            'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
                            '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
                        ],
                        [
                            '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
                            '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
                        ],
                        [
                            'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
                            '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
                        ],
                        [
                            '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
                            'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
                        ],
                        [
                            '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
                            'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
                        ],
                        [
                            'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
                            'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
                        ],
                        [
                            '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
                            '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
                        ],
                        [
                            '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
                            'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
                        ],
                        [
                            'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
                            'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
                        ],
                        [
                            '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
                            '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
                        ],
                        [
                            '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
                            'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
                        ],
                        [
                            '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
                            '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
                        ],
                        [
                            '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
                            'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
                        ],
                        [
                            'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
                            '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
                        ],
                        [
                            '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
                            '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
                        ],
                        [
                            '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
                            'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
                        ],
                        [
                            '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
                            'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
                        ],
                        [
                            'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
                            'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
                        ],
                        [
                            'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
                            'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
                        ],
                        [
                            '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
                            '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
                        ],
                        [
                            '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
                            '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
                        ],
                        [
                            'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
                            '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
                        ],
                        [
                            'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
                            'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
                        ],
                        [
                            '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
                            '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
                        ],
                        [
                            '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
                            '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
                        ],
                        [
                            'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
                            '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
                        ],
                        [
                            '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
                            '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
                        ],
                        [
                            'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
                            'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
                        ],
                        [
                            '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
                            'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
                        ],
                        [
                            '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
                            '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
                        ],
                        [
                            'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
                            '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
                        ],
                        [
                            'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
                            '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
                        ],
                        [
                            '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
                            '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
                        ],
                        [
                            '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
                            '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
                        ],
                        [
                            '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
                            'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
                        ],
                        [
                            '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
                            'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
                        ],
                        [
                            '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
                            '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
                        ],
                        [
                            '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
                            '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
                        ],
                        [
                            '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
                            '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
                        ],
                        [
                            '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
                            'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
                        ],
                        [
                            'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
                            'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
                        ],
                        [
                            '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
                            'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
                        ],
                        [
                            'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
                            '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
                        ],
                        [
                            'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
                            '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
                        ],
                        [
                            'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
                            '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
                        ],
                        [
                            'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
                            '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
                        ],
                        [
                            '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
                            'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
                        ],
                        [
                            '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
                            '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
                        ],
                        [
                            '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
                            'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
                        ],
                        [
                            'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
                            'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
                        ],
                        [
                            'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
                            '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
                        ],
                        [
                            'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
                            'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
                        ],
                        [
                            'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
                            '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
                        ],
                        [
                            '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
                            '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
                        ],
                        [
                            'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
                            '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
                        ],
                        [
                            'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
                            '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
                        ],
                        [
                            '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
                            '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
                        ],
                        [
                            '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
                            'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
                        ],
                        [
                            'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
                            '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
                        ],
                        [
                            'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
                            '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
                        ],
                        [
                            'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
                            '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
                        ],
                        [
                            '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
                            '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
                        ],
                        [
                            'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
                            'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
                        ],
                        [
                            '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
                            'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
                        ],
                        [
                            'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
                            'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
                        ],
                        [
                            'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
                            '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
                        ],
                        [
                            '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
                            'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
                        ],
                        [
                            'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
                            '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
                        ],
                        [
                            'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
                            '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
                        ],
                        [
                            'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
                            '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
                        ],
                        [
                            '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
                            'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
                        ],
                        [
                            '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
                            'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
                        ],
                        [
                            'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
                            '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
                        ],
                        [
                            '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
                            'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
                        ],
                        [
                            '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
                            '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
                        ],
                        [
                            '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
                            'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
                        ],
                        [
                            'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
                            'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
                        ],
                        [
                            '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
                            'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
                        ],
                        [
                            '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
                            '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
                        ],
                        [
                            '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
                            'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
                        ],
                        [
                            '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
                            '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
                        ],
                        [
                            'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
                            'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
                        ],
                        [
                            '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
                            '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
                        ],
                        [
                            'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
                            '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
                        ],
                        [
                            '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
                            '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
                        ],
                        [
                            'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
                            'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
                        ],
                        [
                            'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
                            '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
                        ],
                        [
                            'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
                            'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
                        ],
                        [
                            '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
                            'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
                        ],
                        [
                            '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
                            '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
                        ],
                        [
                            '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
                            'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
                        ],
                        [
                            '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
                            '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
                        ],
                        [
                            '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
                            '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
                        ],
                        [
                            '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
                            'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
                        ],
                        [
                            '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
                            '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
                        ],
                        [
                            '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
                            '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
                        ],
                        [
                            '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
                            '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
                        ]
                    ]
                }
            };

        }, {}], 212: [function (require, module, exports) {
            'use strict';
            
            var utils = exports;
            
            utils.assert = function assert(val, msg) {
                if (!val)
                    throw new Error(msg || 'Assertion failed');
            };
            
            function toArray(msg, enc) {
                if (Array.isArray(msg))
                    return msg.slice();
                if (!msg)
                    return [];
                var res = [];
                if (typeof msg !== 'string') {
                    for (var i = 0; i < msg.length; i++)
                        res[i] = msg[i] | 0;
                    return res;
                }
                if (!enc) {
                    for (var i = 0; i < msg.length; i++) {
                        var c = msg.charCodeAt(i);
                        var hi = c >> 8;
                        var lo = c & 0xff;
                        if (hi)
                            res.push(hi, lo);
                        else
                            res.push(lo);
                    }
                } else if (enc === 'hex') {
                    msg = msg.replace(/[^a-z0-9]+/ig, '');
                    if (msg.length % 2 !== 0)
                        msg = '0' + msg;
                    for (var i = 0; i < msg.length; i += 2)
                        res.push(parseInt(msg[i] + msg[i + 1], 16));
                }
                return res;
            }
            utils.toArray = toArray;
            
            function zero2(word) {
                if (word.length === 1)
                    return '0' + word;
                else
                    return word;
            }
            utils.zero2 = zero2;
            
            function toHex(msg) {
                var res = '';
                for (var i = 0; i < msg.length; i++)
                    res += zero2(msg[i].toString(16));
                return res;
            }
            utils.toHex = toHex;
            
            utils.encode = function encode(arr, enc) {
                if (enc === 'hex')
                    return toHex(arr);
                else
                    return arr;
            };
            
            // Represent num in a w-NAF form
            function getNAF(num, w) {
                var naf = [];
                var ws = 1 << (w + 1);
                var k = num.clone();
                while (k.cmpn(1) >= 0) {
                    var z;
                    if (k.isOdd()) {
                        var mod = k.andln(ws - 1);
                        if (mod > (ws >> 1) - 1)
                            z = (ws >> 1) - mod;
                        else
                            z = mod;
                        k.isubn(z);
                    } else {
                        z = 0;
                    }
                    naf.push(z);
                    
                    // Optimization, shift by word if possible
                    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
                    for (var i = 1; i < shift; i++)
                        naf.push(0);
                    k.ishrn(shift);
                }
                
                return naf;
            }
            utils.getNAF = getNAF;
            
            // Represent k1, k2 in a Joint Sparse Form
            function getJSF(k1, k2) {
                var jsf = [
                    [],
                    []
                ];
                
                k1 = k1.clone();
                k2 = k2.clone();
                var d1 = 0;
                var d2 = 0;
                while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
                    
                    // First phase
                    var m14 = (k1.andln(3) + d1) & 3;
                    var m24 = (k2.andln(3) + d2) & 3;
                    if (m14 === 3)
                        m14 = -1;
                    if (m24 === 3)
                        m24 = -1;
                    var u1;
                    if ((m14 & 1) === 0) {
                        u1 = 0;
                    } else {
                        var m8 = (k1.andln(7) + d1) & 7;
                        if ((m8 === 3 || m8 === 5) && m24 === 2)
                            u1 = -m14;
                        else
                            u1 = m14;
                    }
                    jsf[0].push(u1);
                    
                    var u2;
                    if ((m24 & 1) === 0) {
                        u2 = 0;
                    } else {
                        var m8 = (k2.andln(7) + d2) & 7;
                        if ((m8 === 3 || m8 === 5) && m14 === 2)
                            u2 = -m24;
                        else
                            u2 = m24;
                    }
                    jsf[1].push(u2);
                    
                    // Second phase
                    if (2 * d1 === u1 + 1)
                        d1 = 1 - d1;
                    if (2 * d2 === u2 + 1)
                        d2 = 1 - d2;
                    k1.ishrn(1);
                    k2.ishrn(1);
                }
                
                return jsf;
            }
            utils.getJSF = getJSF;

        }, {}], 213: [function (require, module, exports) {
            var r;
            
            module.exports = function rand(len) {
                if (!r)
                    r = new Rand(null);
                
                return r.generate(len);
            };
            
            function Rand(rand) {
                this.rand = rand;
            }
            module.exports.Rand = Rand;
            
            Rand.prototype.generate = function generate(len) {
                return this._rand(len);
            };
            
            if (typeof window === 'object') {
                if (window.crypto && window.crypto.getRandomValues) {
                    // Modern browsers
                    Rand.prototype._rand = function _rand(n) {
                        var arr = new Uint8Array(n);
                        window.crypto.getRandomValues(arr);
                        return arr;
                    };
                } else if (window.msCrypto && window.msCrypto.getRandomValues) {
                    // IE
                    Rand.prototype._rand = function _rand(n) {
                        var arr = new Uint8Array(n);
                        window.msCrypto.getRandomValues(arr);
                        return arr;
                    };
                } else {
                    // Old junk
                    Rand.prototype._rand = function () {
                        throw new Error('Not implemented yet');
                    };
                }
            } else {
                // Node.js or Web worker
                try {
                    var crypto = require('cry' + 'pto');
                    
                    Rand.prototype._rand = function _rand(n) {
                        return crypto.randomBytes(n);
                    };
                } catch (e) {
                    // Emulate crypto API using randy
                    Rand.prototype._rand = function _rand(n) {
                        var res = new Uint8Array(n);
                        for (var i = 0; i < res.length; i++)
                            res[i] = this.rand.getByte();
                        return res;
                    };
                }
            }

        }, {}], 214: [function (require, module, exports) {
            var hash = exports;
            
            hash.utils = require('./hash/utils');
            hash.common = require('./hash/common');
            hash.sha = require('./hash/sha');
            hash.ripemd = require('./hash/ripemd');
            hash.hmac = require('./hash/hmac');
            
            // Proxy hash functions to the main object
            hash.sha1 = hash.sha.sha1;
            hash.sha256 = hash.sha.sha256;
            hash.sha224 = hash.sha.sha224;
            hash.sha384 = hash.sha.sha384;
            hash.sha512 = hash.sha.sha512;
            hash.ripemd160 = hash.ripemd.ripemd160;

        }, { "./hash/common": 215, "./hash/hmac": 216, "./hash/ripemd": 217, "./hash/sha": 218, "./hash/utils": 219 }], 215: [function (require, module, exports) {
            var hash = require('../hash');
            var utils = hash.utils;
            var assert = utils.assert;
            
            function BlockHash() {
                this.pending = null;
                this.pendingTotal = 0;
                this.blockSize = this.constructor.blockSize;
                this.outSize = this.constructor.outSize;
                this.hmacStrength = this.constructor.hmacStrength;
                this.padLength = this.constructor.padLength / 8;
                this.endian = 'big';
                
                this._delta8 = this.blockSize / 8;
                this._delta32 = this.blockSize / 32;
            }
            exports.BlockHash = BlockHash;
            
            BlockHash.prototype.update = function update(msg, enc) {
                // Convert message to array, pad it, and join into 32bit blocks
                msg = utils.toArray(msg, enc);
                if (!this.pending)
                    this.pending = msg;
                else
                    this.pending = this.pending.concat(msg);
                this.pendingTotal += msg.length;
                
                // Enough data, try updating
                if (this.pending.length >= this._delta8) {
                    msg = this.pending;
                    
                    // Process pending data in blocks
                    var r = msg.length % this._delta8;
                    this.pending = msg.slice(msg.length - r, msg.length);
                    if (this.pending.length === 0)
                        this.pending = null;
                    
                    msg = utils.join32(msg, 0, msg.length - r, this.endian);
                    for (var i = 0; i < msg.length; i += this._delta32)
                        this._update(msg, i, i + this._delta32);
                }
                
                return this;
            };
            
            BlockHash.prototype.digest = function digest(enc) {
                this.update(this._pad());
                assert(this.pending === null);
                
                return this._digest(enc);
            };
            
            BlockHash.prototype._pad = function pad() {
                var len = this.pendingTotal;
                var bytes = this._delta8;
                var k = bytes - ((len + this.padLength) % bytes);
                var res = new Array(k + this.padLength);
                res[0] = 0x80;
                for (var i = 1; i < k; i++)
                    res[i] = 0;
                
                // Append length
                len <<= 3;
                if (this.endian === 'big') {
                    for (var t = 8; t < this.padLength; t++)
                        res[i++] = 0;
                    
                    res[i++] = 0;
                    res[i++] = 0;
                    res[i++] = 0;
                    res[i++] = 0;
                    res[i++] = (len >>> 24) & 0xff;
                    res[i++] = (len >>> 16) & 0xff;
                    res[i++] = (len >>> 8) & 0xff;
                    res[i++] = len & 0xff;
                } else {
                    res[i++] = len & 0xff;
                    res[i++] = (len >>> 8) & 0xff;
                    res[i++] = (len >>> 16) & 0xff;
                    res[i++] = (len >>> 24) & 0xff;
                    res[i++] = 0;
                    res[i++] = 0;
                    res[i++] = 0;
                    res[i++] = 0;
                    
                    for (var t = 8; t < this.padLength; t++)
                        res[i++] = 0;
                }
                
                return res;
            };

        }, { "../hash": 214 }], 216: [function (require, module, exports) {
            var hmac = exports;
            
            var hash = require('../hash');
            var utils = hash.utils;
            var assert = utils.assert;
            
            function Hmac(hash, key, enc) {
                if (!(this instanceof Hmac))
                    return new Hmac(hash, key, enc);
                this.Hash = hash;
                this.blockSize = hash.blockSize / 8;
                this.outSize = hash.outSize / 8;
                this.inner = null;
                this.outer = null;
                
                this._init(utils.toArray(key, enc));
            }
            module.exports = Hmac;
            
            Hmac.prototype._init = function init(key) {
                // Shorten key, if needed
                if (key.length > this.blockSize)
                    key = new this.Hash().update(key).digest();
                assert(key.length <= this.blockSize);
                
                // Add padding to key
                for (var i = key.length; i < this.blockSize; i++)
                    key.push(0);
                
                for (var i = 0; i < key.length; i++)
                    key[i] ^= 0x36;
                this.inner = new this.Hash().update(key);
                
                // 0x36 ^ 0x5c = 0x6a
                for (var i = 0; i < key.length; i++)
                    key[i] ^= 0x6a;
                this.outer = new this.Hash().update(key);
            };
            
            Hmac.prototype.update = function update(msg, enc) {
                this.inner.update(msg, enc);
                return this;
            };
            
            Hmac.prototype.digest = function digest(enc) {
                this.outer.update(this.inner.digest());
                return this.outer.digest(enc);
            };

        }, { "../hash": 214 }], 217: [function (require, module, exports) {
            var hash = require('../hash');
            var utils = hash.utils;
            
            var rotl32 = utils.rotl32;
            var sum32 = utils.sum32;
            var sum32_3 = utils.sum32_3;
            var sum32_4 = utils.sum32_4;
            var BlockHash = hash.common.BlockHash;
            
            function RIPEMD160() {
                if (!(this instanceof RIPEMD160))
                    return new RIPEMD160();
                
                BlockHash.call(this);
                
                this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
                this.endian = 'little';
            }
            utils.inherits(RIPEMD160, BlockHash);
            exports.ripemd160 = RIPEMD160;
            
            RIPEMD160.blockSize = 512;
            RIPEMD160.outSize = 160;
            RIPEMD160.hmacStrength = 192;
            RIPEMD160.padLength = 64;
            
            RIPEMD160.prototype._update = function update(msg, start) {
                var A = this.h[0];
                var B = this.h[1];
                var C = this.h[2];
                var D = this.h[3];
                var E = this.h[4];
                var Ah = A;
                var Bh = B;
                var Ch = C;
                var Dh = D;
                var Eh = E;
                for (var j = 0; j < 80; j++) {
                    var T = sum32(
                        rotl32(
                            sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
                    A = E;
                    E = D;
                    D = rotl32(C, 10);
                    C = B;
                    B = T;
                    T = sum32(
                        rotl32(
                            sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
                    Ah = Eh;
                    Eh = Dh;
                    Dh = rotl32(Ch, 10);
                    Ch = Bh;
                    Bh = T;
                }
                T = sum32_3(this.h[1], C, Dh);
                this.h[1] = sum32_3(this.h[2], D, Eh);
                this.h[2] = sum32_3(this.h[3], E, Ah);
                this.h[3] = sum32_3(this.h[4], A, Bh);
                this.h[4] = sum32_3(this.h[0], B, Ch);
                this.h[0] = T;
            };
            
            RIPEMD160.prototype._digest = function digest(enc) {
                if (enc === 'hex')
                    return utils.toHex32(this.h, 'little');
                else
                    return utils.split32(this.h, 'little');
            };
            
            function f(j, x, y, z) {
                if (j <= 15)
                    return x ^ y ^ z;
                else if (j <= 31)
                    return (x & y) | ((~x) & z);
                else if (j <= 47)
                    return (x | (~y)) ^ z;
                else if (j <= 63)
                    return (x & z) | (y & (~z));
                else
                    return x ^ (y | (~z));
            }
            
            function K(j) {
                if (j <= 15)
                    return 0x00000000;
                else if (j <= 31)
                    return 0x5a827999;
                else if (j <= 47)
                    return 0x6ed9eba1;
                else if (j <= 63)
                    return 0x8f1bbcdc;
                else
                    return 0xa953fd4e;
            }
            
            function Kh(j) {
                if (j <= 15)
                    return 0x50a28be6;
                else if (j <= 31)
                    return 0x5c4dd124;
                else if (j <= 47)
                    return 0x6d703ef3;
                else if (j <= 63)
                    return 0x7a6d76e9;
                else
                    return 0x00000000;
            }
            
            var r = [
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
                3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
                1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
                4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
            ];
            
            var rh = [
                5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
                6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
                15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
                8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
                12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
            ];
            
            var s = [
                11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
                7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
                11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
                11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
                9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
            ];
            
            var sh = [
                8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
                9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
                9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
                15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
                8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
            ];

        }, { "../hash": 214 }], 218: [function (require, module, exports) {
            var hash = require('../hash');
            var utils = hash.utils;
            var assert = utils.assert;
            
            var rotr32 = utils.rotr32;
            var rotl32 = utils.rotl32;
            var sum32 = utils.sum32;
            var sum32_4 = utils.sum32_4;
            var sum32_5 = utils.sum32_5;
            var rotr64_hi = utils.rotr64_hi;
            var rotr64_lo = utils.rotr64_lo;
            var shr64_hi = utils.shr64_hi;
            var shr64_lo = utils.shr64_lo;
            var sum64 = utils.sum64;
            var sum64_hi = utils.sum64_hi;
            var sum64_lo = utils.sum64_lo;
            var sum64_4_hi = utils.sum64_4_hi;
            var sum64_4_lo = utils.sum64_4_lo;
            var sum64_5_hi = utils.sum64_5_hi;
            var sum64_5_lo = utils.sum64_5_lo;
            var BlockHash = hash.common.BlockHash;
            
            var sha256_K = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
                0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
                0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
                0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
                0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
                0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
            ];
            
            var sha512_K = [
                0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
                0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
                0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
                0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
                0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
                0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
                0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
                0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
                0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
                0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
                0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
                0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
                0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
                0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
                0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
                0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
                0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
                0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
                0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
                0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
                0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
                0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
                0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
                0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
                0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
                0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
                0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
                0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
                0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
                0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
                0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
                0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
                0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
                0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
                0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
                0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
                0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
                0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
                0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
                0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
            ];
            
            var sha1_K = [
                0x5A827999, 0x6ED9EBA1,
                0x8F1BBCDC, 0xCA62C1D6
            ];
            
            function SHA256() {
                if (!(this instanceof SHA256))
                    return new SHA256();
                
                BlockHash.call(this);
                this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
                this.k = sha256_K;
                this.W = new Array(64);
            }
            utils.inherits(SHA256, BlockHash);
            exports.sha256 = SHA256;
            
            SHA256.blockSize = 512;
            SHA256.outSize = 256;
            SHA256.hmacStrength = 192;
            SHA256.padLength = 64;
            
            SHA256.prototype._update = function _update(msg, start) {
                var W = this.W;
                
                for (var i = 0; i < 16; i++)
                    W[i] = msg[start + i];
                for (; i < W.length; i++)
                    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
                
                var a = this.h[0];
                var b = this.h[1];
                var c = this.h[2];
                var d = this.h[3];
                var e = this.h[4];
                var f = this.h[5];
                var g = this.h[6];
                var h = this.h[7];
                
                assert(this.k.length === W.length);
                for (var i = 0; i < W.length; i++) {
                    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
                    var T2 = sum32(s0_256(a), maj32(a, b, c));
                    h = g;
                    g = f;
                    f = e;
                    e = sum32(d, T1);
                    d = c;
                    c = b;
                    b = a;
                    a = sum32(T1, T2);
                }
                
                this.h[0] = sum32(this.h[0], a);
                this.h[1] = sum32(this.h[1], b);
                this.h[2] = sum32(this.h[2], c);
                this.h[3] = sum32(this.h[3], d);
                this.h[4] = sum32(this.h[4], e);
                this.h[5] = sum32(this.h[5], f);
                this.h[6] = sum32(this.h[6], g);
                this.h[7] = sum32(this.h[7], h);
            };
            
            SHA256.prototype._digest = function digest(enc) {
                if (enc === 'hex')
                    return utils.toHex32(this.h, 'big');
                else
                    return utils.split32(this.h, 'big');
            };
            
            function SHA224() {
                if (!(this instanceof SHA224))
                    return new SHA224();
                
                SHA256.call(this);
                this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
            }
            utils.inherits(SHA224, SHA256);
            exports.sha224 = SHA224;
            
            SHA224.blockSize = 512;
            SHA224.outSize = 224;
            SHA224.hmacStrength = 192;
            SHA224.padLength = 64;
            
            SHA224.prototype._digest = function digest(enc) {
                // Just truncate output
                if (enc === 'hex')
                    return utils.toHex32(this.h.slice(0, 7), 'big');
                else
                    return utils.split32(this.h.slice(0, 7), 'big');
            };
            
            function SHA512() {
                if (!(this instanceof SHA512))
                    return new SHA512();
                
                BlockHash.call(this);
                this.h = [0x6a09e667, 0xf3bcc908,
             0xbb67ae85, 0x84caa73b,
             0x3c6ef372, 0xfe94f82b,
             0xa54ff53a, 0x5f1d36f1,
             0x510e527f, 0xade682d1,
             0x9b05688c, 0x2b3e6c1f,
             0x1f83d9ab, 0xfb41bd6b,
             0x5be0cd19, 0x137e2179];
                this.k = sha512_K;
                this.W = new Array(160);
            }
            utils.inherits(SHA512, BlockHash);
            exports.sha512 = SHA512;
            
            SHA512.blockSize = 1024;
            SHA512.outSize = 512;
            SHA512.hmacStrength = 192;
            SHA512.padLength = 128;
            
            SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
                var W = this.W;
                
                // 32 x 32bit words
                for (var i = 0; i < 32; i++)
                    W[i] = msg[start + i];
                for (; i < W.length; i += 2) {
                    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
                    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
                    var c1_hi = W[i - 14];  // i - 7
                    var c1_lo = W[i - 13];
                    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
                    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
                    var c3_hi = W[i - 32];  // i - 16
                    var c3_lo = W[i - 31];
                    
                    W[i] = sum64_4_hi(c0_hi, c0_lo,
                      c1_hi, c1_lo,
                      c2_hi, c2_lo,
                      c3_hi, c3_lo);
                    W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
                          c1_hi, c1_lo,
                          c2_hi, c2_lo,
                          c3_hi, c3_lo);
                }
            };
            
            SHA512.prototype._update = function _update(msg, start) {
                this._prepareBlock(msg, start);
                
                var W = this.W;
                
                var ah = this.h[0];
                var al = this.h[1];
                var bh = this.h[2];
                var bl = this.h[3];
                var ch = this.h[4];
                var cl = this.h[5];
                var dh = this.h[6];
                var dl = this.h[7];
                var eh = this.h[8];
                var el = this.h[9];
                var fh = this.h[10];
                var fl = this.h[11];
                var gh = this.h[12];
                var gl = this.h[13];
                var hh = this.h[14];
                var hl = this.h[15];
                
                assert(this.k.length === W.length);
                for (var i = 0; i < W.length; i += 2) {
                    var c0_hi = hh;
                    var c0_lo = hl;
                    var c1_hi = s1_512_hi(eh, el);
                    var c1_lo = s1_512_lo(eh, el);
                    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
                    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
                    var c3_hi = this.k[i];
                    var c3_lo = this.k[i + 1];
                    var c4_hi = W[i];
                    var c4_lo = W[i + 1];
                    
                    var T1_hi = sum64_5_hi(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);
                    var T1_lo = sum64_5_lo(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);
                    
                    var c0_hi = s0_512_hi(ah, al);
                    var c0_lo = s0_512_lo(ah, al);
                    var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
                    var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
                    
                    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
                    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
                    
                    hh = gh;
                    hl = gl;
                    
                    gh = fh;
                    gl = fl;
                    
                    fh = eh;
                    fl = el;
                    
                    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
                    el = sum64_lo(dl, dl, T1_hi, T1_lo);
                    
                    dh = ch;
                    dl = cl;
                    
                    ch = bh;
                    cl = bl;
                    
                    bh = ah;
                    bl = al;
                    
                    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
                    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
                }
                
                sum64(this.h, 0, ah, al);
                sum64(this.h, 2, bh, bl);
                sum64(this.h, 4, ch, cl);
                sum64(this.h, 6, dh, dl);
                sum64(this.h, 8, eh, el);
                sum64(this.h, 10, fh, fl);
                sum64(this.h, 12, gh, gl);
                sum64(this.h, 14, hh, hl);
            };
            
            SHA512.prototype._digest = function digest(enc) {
                if (enc === 'hex')
                    return utils.toHex32(this.h, 'big');
                else
                    return utils.split32(this.h, 'big');
            };
            
            function SHA384() {
                if (!(this instanceof SHA384))
                    return new SHA384();
                
                SHA512.call(this);
                this.h = [0xcbbb9d5d, 0xc1059ed8,
             0x629a292a, 0x367cd507,
             0x9159015a, 0x3070dd17,
             0x152fecd8, 0xf70e5939,
             0x67332667, 0xffc00b31,
             0x8eb44a87, 0x68581511,
             0xdb0c2e0d, 0x64f98fa7,
             0x47b5481d, 0xbefa4fa4];
            }
            utils.inherits(SHA384, SHA512);
            exports.sha384 = SHA384;
            
            SHA384.blockSize = 1024;
            SHA384.outSize = 384;
            SHA384.hmacStrength = 192;
            SHA384.padLength = 128;
            
            SHA384.prototype._digest = function digest(enc) {
                if (enc === 'hex')
                    return utils.toHex32(this.h.slice(0, 12), 'big');
                else
                    return utils.split32(this.h.slice(0, 12), 'big');
            };
            
            function SHA1() {
                if (!(this instanceof SHA1))
                    return new SHA1();
                
                BlockHash.call(this);
                this.h = [0x67452301, 0xefcdab89, 0x98badcfe,
             0x10325476, 0xc3d2e1f0];
                this.W = new Array(80);
            }
            
            utils.inherits(SHA1, BlockHash);
            exports.sha1 = SHA1;
            
            SHA1.blockSize = 512;
            SHA1.outSize = 160;
            SHA1.hmacStrength = 80;
            SHA1.padLength = 64;
            
            SHA1.prototype._update = function _update(msg, start) {
                var W = this.W;
                
                for (var i = 0; i < 16; i++)
                    W[i] = msg[start + i];
                
                for (; i < W.length; i++)
                    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
                
                var a = this.h[0];
                var b = this.h[1];
                var c = this.h[2];
                var d = this.h[3];
                var e = this.h[4];
                
                for (var i = 0; i < W.length; i++) {
                    var s = ~~(i / 20);
                    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
                    e = d;
                    d = c;
                    c = rotl32(b, 30);
                    b = a;
                    a = t;
                }
                
                this.h[0] = sum32(this.h[0], a);
                this.h[1] = sum32(this.h[1], b);
                this.h[2] = sum32(this.h[2], c);
                this.h[3] = sum32(this.h[3], d);
                this.h[4] = sum32(this.h[4], e);
            };
            
            SHA1.prototype._digest = function digest(enc) {
                if (enc === 'hex')
                    return utils.toHex32(this.h, 'big');
                else
                    return utils.split32(this.h, 'big');
            };
            
            function ch32(x, y, z) {
                return (x & y) ^ ((~x) & z);
            }
            
            function maj32(x, y, z) {
                return (x & y) ^ (x & z) ^ (y & z);
            }
            
            function p32(x, y, z) {
                return x ^ y ^ z;
            }
            
            function s0_256(x) {
                return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
            }
            
            function s1_256(x) {
                return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
            }
            
            function g0_256(x) {
                return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
            }
            
            function g1_256(x) {
                return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
            }
            
            function ft_1(s, x, y, z) {
                if (s === 0)
                    return ch32(x, y, z);
                if (s === 1 || s === 3)
                    return p32(x, y, z);
                if (s === 2)
                    return maj32(x, y, z);
            }
            
            function ch64_hi(xh, xl, yh, yl, zh, zl) {
                var r = (xh & yh) ^ ((~xh) & zh);
                if (r < 0)
                    r += 0x100000000;
                return r;
            }
            
            function ch64_lo(xh, xl, yh, yl, zh, zl) {
                var r = (xl & yl) ^ ((~xl) & zl);
                if (r < 0)
                    r += 0x100000000;
                return r;
            }
            
            function maj64_hi(xh, xl, yh, yl, zh, zl) {
                var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
                if (r < 0)
                    r += 0x100000000;
                return r;
            }
            
            function maj64_lo(xh, xl, yh, yl, zh, zl) {
                var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
                if (r < 0)
                    r += 0x100000000;
                return r;
            }
            
            function s0_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 28);
                var c1_hi = rotr64_hi(xl, xh, 2);  // 34
                var c2_hi = rotr64_hi(xl, xh, 7);  // 39
                
                var r = c0_hi ^ c1_hi ^ c2_hi;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }
            
            function s0_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 28);
                var c1_lo = rotr64_lo(xl, xh, 2);  // 34
                var c2_lo = rotr64_lo(xl, xh, 7);  // 39
                
                var r = c0_lo ^ c1_lo ^ c2_lo;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }
            
            function s1_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 14);
                var c1_hi = rotr64_hi(xh, xl, 18);
                var c2_hi = rotr64_hi(xl, xh, 9);  // 41
                
                var r = c0_hi ^ c1_hi ^ c2_hi;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }
            
            function s1_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 14);
                var c1_lo = rotr64_lo(xh, xl, 18);
                var c2_lo = rotr64_lo(xl, xh, 9);  // 41
                
                var r = c0_lo ^ c1_lo ^ c2_lo;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }
            
            function g0_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 1);
                var c1_hi = rotr64_hi(xh, xl, 8);
                var c2_hi = shr64_hi(xh, xl, 7);
                
                var r = c0_hi ^ c1_hi ^ c2_hi;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }
            
            function g0_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 1);
                var c1_lo = rotr64_lo(xh, xl, 8);
                var c2_lo = shr64_lo(xh, xl, 7);
                
                var r = c0_lo ^ c1_lo ^ c2_lo;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }
            
            function g1_512_hi(xh, xl) {
                var c0_hi = rotr64_hi(xh, xl, 19);
                var c1_hi = rotr64_hi(xl, xh, 29);  // 61
                var c2_hi = shr64_hi(xh, xl, 6);
                
                var r = c0_hi ^ c1_hi ^ c2_hi;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }
            
            function g1_512_lo(xh, xl) {
                var c0_lo = rotr64_lo(xh, xl, 19);
                var c1_lo = rotr64_lo(xl, xh, 29);  // 61
                var c2_lo = shr64_lo(xh, xl, 6);
                
                var r = c0_lo ^ c1_lo ^ c2_lo;
                if (r < 0)
                    r += 0x100000000;
                return r;
            }

        }, { "../hash": 214 }], 219: [function (require, module, exports) {
            var utils = exports;
            var inherits = require('inherits');
            
            function toArray(msg, enc) {
                if (Array.isArray(msg))
                    return msg.slice();
                if (!msg)
                    return [];
                var res = [];
                if (typeof msg === 'string') {
                    if (!enc) {
                        for (var i = 0; i < msg.length; i++) {
                            var c = msg.charCodeAt(i);
                            var hi = c >> 8;
                            var lo = c & 0xff;
                            if (hi)
                                res.push(hi, lo);
                            else
                                res.push(lo);
                        }
                    } else if (enc === 'hex') {
                        msg = msg.replace(/[^a-z0-9]+/ig, '');
                        if (msg.length % 2 !== 0)
                            msg = '0' + msg;
                        for (var i = 0; i < msg.length; i += 2)
                            res.push(parseInt(msg[i] + msg[i + 1], 16));
                    }
                } else {
                    for (var i = 0; i < msg.length; i++)
                        res[i] = msg[i] | 0;
                }
                return res;
            }
            utils.toArray = toArray;
            
            function toHex(msg) {
                var res = '';
                for (var i = 0; i < msg.length; i++)
                    res += zero2(msg[i].toString(16));
                return res;
            }
            utils.toHex = toHex;
            
            function htonl(w) {
                var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
                return res >>> 0;
            }
            utils.htonl = htonl;
            
            function toHex32(msg, endian) {
                var res = '';
                for (var i = 0; i < msg.length; i++) {
                    var w = msg[i];
                    if (endian === 'little')
                        w = htonl(w);
                    res += zero8(w.toString(16));
                }
                return res;
            }
            utils.toHex32 = toHex32;
            
            function zero2(word) {
                if (word.length === 1)
                    return '0' + word;
                else
                    return word;
            }
            utils.zero2 = zero2;
            
            function zero8(word) {
                if (word.length === 7)
                    return '0' + word;
                else if (word.length === 6)
                    return '00' + word;
                else if (word.length === 5)
                    return '000' + word;
                else if (word.length === 4)
                    return '0000' + word;
                else if (word.length === 3)
                    return '00000' + word;
                else if (word.length === 2)
                    return '000000' + word;
                else if (word.length === 1)
                    return '0000000' + word;
                else
                    return word;
            }
            utils.zero8 = zero8;
            
            function join32(msg, start, end, endian) {
                var len = end - start;
                assert(len % 4 === 0);
                var res = new Array(len / 4);
                for (var i = 0, k = start; i < res.length; i++, k += 4) {
                    var w;
                    if (endian === 'big')
                        w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
                    else
                        w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
                    res[i] = w >>> 0;
                }
                return res;
            }
            utils.join32 = join32;
            
            function split32(msg, endian) {
                var res = new Array(msg.length * 4);
                for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
                    var m = msg[i];
                    if (endian === 'big') {
                        res[k] = m >>> 24;
                        res[k + 1] = (m >>> 16) & 0xff;
                        res[k + 2] = (m >>> 8) & 0xff;
                        res[k + 3] = m & 0xff;
                    } else {
                        res[k + 3] = m >>> 24;
                        res[k + 2] = (m >>> 16) & 0xff;
                        res[k + 1] = (m >>> 8) & 0xff;
                        res[k] = m & 0xff;
                    }
                }
                return res;
            }
            utils.split32 = split32;
            
            function rotr32(w, b) {
                return (w >>> b) | (w << (32 - b));
            }
            utils.rotr32 = rotr32;
            
            function rotl32(w, b) {
                return (w << b) | (w >>> (32 - b));
            }
            utils.rotl32 = rotl32;
            
            function sum32(a, b) {
                return (a + b) >>> 0;
            }
            utils.sum32 = sum32;
            
            function sum32_3(a, b, c) {
                return (a + b + c) >>> 0;
            }
            utils.sum32_3 = sum32_3;
            
            function sum32_4(a, b, c, d) {
                return (a + b + c + d) >>> 0;
            }
            utils.sum32_4 = sum32_4;
            
            function sum32_5(a, b, c, d, e) {
                return (a + b + c + d + e) >>> 0;
            }
            utils.sum32_5 = sum32_5;
            
            function assert(cond, msg) {
                if (!cond)
                    throw new Error(msg || 'Assertion failed');
            }
            utils.assert = assert;
            
            utils.inherits = inherits;
            
            function sum64(buf, pos, ah, al) {
                var bh = buf[pos];
                var bl = buf[pos + 1];
                
                var lo = (al + bl) >>> 0;
                var hi = (lo < al ? 1 : 0) + ah + bh;
                buf[pos] = hi >>> 0;
                buf[pos + 1] = lo;
            }
            exports.sum64 = sum64;
            
            function sum64_hi(ah, al, bh, bl) {
                var lo = (al + bl) >>> 0;
                var hi = (lo < al ? 1 : 0) + ah + bh;
                return hi >>> 0;
            }            ;
            exports.sum64_hi = sum64_hi;
            
            function sum64_lo(ah, al, bh, bl) {
                var lo = al + bl;
                return lo >>> 0;
            }            ;
            exports.sum64_lo = sum64_lo;
            
            function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
                var carry = 0;
                var lo = al;
                lo = (lo + bl) >>> 0;
                carry += lo < al ? 1 : 0;
                lo = (lo + cl) >>> 0;
                carry += lo < cl ? 1 : 0;
                lo = (lo + dl) >>> 0;
                carry += lo < dl ? 1 : 0;
                
                var hi = ah + bh + ch + dh + carry;
                return hi >>> 0;
            }            ;
            exports.sum64_4_hi = sum64_4_hi;
            
            function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
                var lo = al + bl + cl + dl;
                return lo >>> 0;
            }            ;
            exports.sum64_4_lo = sum64_4_lo;
            
            function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
                var carry = 0;
                var lo = al;
                lo = (lo + bl) >>> 0;
                carry += lo < al ? 1 : 0;
                lo = (lo + cl) >>> 0;
                carry += lo < cl ? 1 : 0;
                lo = (lo + dl) >>> 0;
                carry += lo < dl ? 1 : 0;
                lo = (lo + el) >>> 0;
                carry += lo < el ? 1 : 0;
                
                var hi = ah + bh + ch + dh + eh + carry;
                return hi >>> 0;
            }            ;
            exports.sum64_5_hi = sum64_5_hi;
            
            function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
                var lo = al + bl + cl + dl + el;
                
                return lo >>> 0;
            }            ;
            exports.sum64_5_lo = sum64_5_lo;
            
            function rotr64_hi(ah, al, num) {
                var r = (al << (32 - num)) | (ah >>> num);
                return r >>> 0;
            }            ;
            exports.rotr64_hi = rotr64_hi;
            
            function rotr64_lo(ah, al, num) {
                var r = (ah << (32 - num)) | (al >>> num);
                return r >>> 0;
            }            ;
            exports.rotr64_lo = rotr64_lo;
            
            function shr64_hi(ah, al, num) {
                return ah >>> num;
            }            ;
            exports.shr64_hi = shr64_hi;
            
            function shr64_lo(ah, al, num) {
                var r = (ah << (32 - num)) | (al >>> num);
                return r >>> 0;
            }            ;
            exports.shr64_lo = shr64_lo;

        }, { "inherits": 318 }], 220: [function (require, module, exports) {
            module.exports = {
                "name": "elliptic",
                "version": "3.1.0",
                "description": "EC cryptography",
                "main": "lib/elliptic.js",
                "scripts": {
                    "test": "make lint && mocha --reporter=spec test/*-test.js"
                },
                "repository": {
                    "type": "git",
                    "url": "git@github.com:indutny/elliptic"
                },
                "keywords": [
                    "EC",
                    "Elliptic",
                    "curve",
                    "Cryptography"
                ],
                "author": {
                    "name": "Fedor Indutny",
                    "email": "fedor@indutny.com"
                },
                "license": "MIT",
                "bugs": {
                    "url": "https://github.com/indutny/elliptic/issues"
                },
                "homepage": "https://github.com/indutny/elliptic",
                "devDependencies": {
                    "browserify": "^3.44.2",
                    "jscs": "^1.11.3",
                    "jshint": "^2.6.0",
                    "mocha": "^2.1.0",
                    "uglify-js": "^2.4.13"
                },
                "dependencies": {
                    "bn.js": "^2.0.3",
                    "brorand": "^1.0.1",
                    "hash.js": "^1.0.0",
                    "inherits": "^2.0.1"
                },
                "readme": "# Elliptic [![Build Status](https://secure.travis-ci.org/indutny/elliptic.png)](http://travis-ci.org/indutny/elliptic)\n\nFast elliptic-curve cryptography in a plain javascript implementation.\n\nNOTE: Please take a look at http://safecurves.cr.yp.to/ before choosing a curve\nfor your cryptography operations.\n\n## Incentive\n\nECC is much slower than regular RSA cryptography, the JS implementations are\neven more slower.\n\n## Benchmarks\n\n```bash\n$ node benchmarks/index.js\nBenchmarking: sign\nelliptic#sign x 262 ops/sec Â±0.51% (177 runs sampled)\neccjs#sign x 55.91 ops/sec Â±0.90% (144 runs sampled)\n------------------------\nFastest is elliptic#sign\n========================\nBenchmarking: verify\nelliptic#verify x 113 ops/sec Â±0.50% (166 runs sampled)\neccjs#verify x 48.56 ops/sec Â±0.36% (125 runs sampled)\n------------------------\nFastest is elliptic#verify\n========================\nBenchmarking: gen\nelliptic#gen x 294 ops/sec Â±0.43% (176 runs sampled)\neccjs#gen x 62.25 ops/sec Â±0.63% (129 runs sampled)\n------------------------\nFastest is elliptic#gen\n========================\nBenchmarking: ecdh\nelliptic#ecdh x 136 ops/sec Â±0.85% (156 runs sampled)\n------------------------\nFastest is elliptic#ecdh\n========================\n```\n\n## API\n\n### ECDSA\n\n```javascript\nvar EC = require('elliptic').ec;\n\n// Create and initialize EC context\n// (better do it once and reuse it)\nvar ec = new EC('secp256k1');\n\n// Generate keys\nvar key = ec.genKeyPair();\n\n// Sign message (must be an array, or it'll be treated as a hex sequence)\nvar msg = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nvar signature = key.sign(msg);\n\n// Export DER encoded signature in Array\nvar derSign = signature.toDER();\n\n// Verify signature\nconsole.log(key.verify(msg, derSign));\n```\n\n### ECDH\n\n```javascript\n// Generate keys\nvar key1 = ec.genKeyPair();\nvar key2 = ec.genKeyPair();\n\nvar shared1 = key1.derive(key2.getPublic());\nvar shared2 = key2.derive(key1.getPublic());\n\nconsole.log('Both shared secrets are BN instances');\nconsole.log(shared1.toString(16));\nconsole.log(shared2.toString(16));\n```\n\nNOTE: `.derive()` returns a [BN][1] instance.\n\n## Supported curves\n\nElliptic.js support following curve types:\n\n* Short Weierstrass\n* Montgomery\n* Edwards\n* Twisted Edwards\n\nFollowing curve 'presets' are embedded into the library:\n\n* `secp256k1`\n* `p192`\n* `p224`\n* `p256`\n* `curve25519`\n* `ed25519`\n\nNOTE: That `curve25519` could not be used for ECDSA, use `ed25519` instead.\n\n### Implementation details\n\nECDSA is using deterministic `k` value generation as per [RFC6979][0]. Most of\nthe curve operations are performed on non-affine coordinates (either projective\nor extended), various windowing techniques are used for different cases.\n\nAll operations are performed in reduction context using [bn.js][1], hashing is\nprovided by [hash.js][2]\n\n### Related projects\n\n* [eccrypto][3]: isomorphic implementation of ECDSA, ECDH and ECIES for both\n  browserify and node (uses `elliptic` for browser and [secp256k1-node][4] for\n  node)\n\n#### LICENSE\n\nThis software is licensed under the MIT License.\n\nCopyright Fedor Indutny, 2014.\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the\nfollowing conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n\n[0]: http://tools.ietf.org/html/rfc6979\n[1]: https://github.com/indutny/bn.js\n[2]: https://github.com/indutny/hash.js\n[3]: https://github.com/bitchan/eccrypto\n[4]: https://github.com/wanderer/secp256k1-node\n",
                "readmeFilename": "README.md",
                "_id": "elliptic@3.1.0",
                "_from": "elliptic@^3.0.0"
            }

        }, {}], 221: [function (require, module, exports) {
            (function (Buffer) {
                var createHash = require('create-hash');
                module.exports = function evp(password, salt, keyLen) {
                    keyLen = keyLen / 8;
                    var ki = 0;
                    var ii = 0;
                    var key = new Buffer(keyLen);
                    var addmd = 0;
                    var md, md_buf;
                    var i;
                    while (true) {
                        md = createHash('md5');
                        if (addmd++ > 0) {
                            md.update(md_buf);
                        }
                        md.update(password);
                        md.update(salt);
                        md_buf = md.digest();
                        i = 0;
                        if (keyLen > 0) {
                            while (true) {
                                if (keyLen === 0) {
                                    break;
                                }
                                if (i === md_buf.length) {
                                    break;
                                }
                                key[ki++] = md_buf[i++];
                                keyLen--;
                            }
                        }
                        if (keyLen === 0) {
                            break;
                        }
                    }
                    for (i = 0; i < md_buf.length; i++) {
                        md_buf[i] = 0;
                    }
                    return key;
                };
            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172, "create-hash": 267 }], 222: [function (require, module, exports) {
            module.exports = {
                "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
                "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
                "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
                "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
                "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
                "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
                "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
                "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
                "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
                "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
                "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
                "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
            }
        }, {}], 223: [function (require, module, exports) {
            // from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
            // Fedor, you are amazing.
            
            var asn1 = require('asn1.js');
            
            var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
                this.seq().obj(
                    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
                );
            });
            exports.RSAPrivateKey = RSAPrivateKey;
            
            var RSAPublicKey = asn1.define('RSAPublicKey', function () {
                this.seq().obj(
                    this.key('modulus').int(),
    this.key('publicExponent').int()
                );
            });
            exports.RSAPublicKey = RSAPublicKey;
            
            var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
                this.seq().obj(
                    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
                );
            });
            exports.PublicKey = PublicKey;
            
            var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
                this.seq().obj(
                    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
                        this.key('p').int(),
        this.key('q').int(),
        this.key('g').int()
                    ).optional()
                );
            });
            
            var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
                this.seq().obj(
                    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
                );
            });
            exports.PrivateKey = PrivateKeyInfo;
            var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
                this.seq().obj(
                    this.key('algorithm').seq().obj(
                        this.key('id').objid(),
      this.key('decrypt').seq().obj(
                            this.key('kde').seq().obj(
                                this.key('id').objid(),
          this.key('kdeparams').seq().obj(
                                    this.key('salt').octstr(),
            this.key('iters').int()
                                )
                            ),
        this.key('cipher').seq().obj(
                                this.key('algo').objid(),
          this.key('iv').octstr()
                            )
                        )
                    ),
    this.key('subjectPrivateKey').octstr()
                );
            });
            
            exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
            
            var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
                this.seq().obj(
                    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
                );
            });
            exports.DSAPrivateKey = DSAPrivateKey;
            
            exports.DSAparam = asn1.define('DSAparam', function () {
                this.int();
            });
            var ECPrivateKey = asn1.define('ECPrivateKey', function () {
                this.seq().obj(
                    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
                );
            });
            exports.ECPrivateKey = ECPrivateKey;
            var ECParameters = asn1.define('ECParameters', function () {
                this.choice({
                    namedCurve: this.objid()
                });
            });
            
            exports.signature = asn1.define('signature', function () {
                this.seq().obj(
                    this.key('r').int(),
    this.key('s').int()
                );
            });

        }, { "asn1.js": 226 }], 224: [function (require, module, exports) {
            (function (Buffer) {
                // adapted from https://github.com/apatil/pemstrip
                var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m;
                var startRegex = /^-----BEGIN (.*) KEY-----\r?\n/m;
                var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m;
                var evp = require('./EVP_BytesToKey');
                var ciphers = require('browserify-aes');
                module.exports = function (okey, password) {
                    var key = okey.toString();
                    var match = key.match(findProc);
                    var decrypted;
                    if (!match) {
                        var match2 = key.match(fullRegex);
                        decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64');
                    } else {
                        var suite = 'aes' + match[1];
                        var iv = new Buffer(match[2], 'hex');
                        var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64');
                        var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1]));
                        var out = [];
                        var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
                        out.push(cipher.update(cipherText));
                        out.push(cipher.final());
                        decrypted = Buffer.concat(out);
                    }
                    var tag = key.match(startRegex)[1] + ' KEY';
                    return {
                        tag: tag,
                        data: decrypted
                    };
                };
                
                // http://stackoverflow.com/a/7033705
                function wrap(str) {
                    var chunks = []
                    
                    for (var i = 0; i < str.length; i += 64) {
                        chunks.push(str.slice(i, i + 64))
                    }
                    return chunks.join("\n")
                }

            }).call(this, require("buffer").Buffer)
        }, { "./EVP_BytesToKey": 221, "browserify-aes": 180, "buffer": 172 }], 225: [function (require, module, exports) {
            (function (Buffer) {
                var asn1 = require('./asn1');
                var aesid = require('./aesid.json');
                var fixProc = require('./fixProc');
                var ciphers = require('browserify-aes');
                var compat = require('pbkdf2');
                module.exports = parseKeys;
                
                function parseKeys(buffer) {
                    var password;
                    if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
                        password = buffer.passphrase;
                        buffer = buffer.key;
                    }
                    if (typeof buffer === 'string') {
                        buffer = new Buffer(buffer);
                    }
                    
                    var stripped = fixProc(buffer, password);
                    
                    var type = stripped.tag;
                    var data = stripped.data;
                    var subtype, ndata;
                    switch (type) {
                        case 'PUBLIC KEY':
                            ndata = asn1.PublicKey.decode(data, 'der');
                            subtype = ndata.algorithm.algorithm.join('.');
                            switch (subtype) {
                                case '1.2.840.113549.1.1.1':
                                    return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
                                case '1.2.840.10045.2.1':
                                    ndata.subjectPrivateKey = ndata.subjectPublicKey;
                                    return {
                                        type: 'ec',
                                        data: ndata
                                    };
                                case '1.2.840.10040.4.1':
                                    ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
                                    return {
                                        type: 'dsa',
                                        data: ndata.algorithm.params
                                    };
                                default: throw new Error('unknown key id ' + subtype);
                            }
                            throw new Error('unknown key type ' + type);
                        case 'ENCRYPTED PRIVATE KEY':
                            data = asn1.EncryptedPrivateKey.decode(data, 'der');
                            data = decrypt(data, password);
      //falling through
                        case 'PRIVATE KEY':
                            ndata = asn1.PrivateKey.decode(data, 'der');
                            subtype = ndata.algorithm.algorithm.join('.');
                            switch (subtype) {
                                case '1.2.840.113549.1.1.1':
                                    return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
                                case '1.2.840.10045.2.1':
                                    return {
                                        curve: ndata.algorithm.curve,
                                        privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
                                    };
                                case '1.2.840.10040.4.1':
                                    ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
                                    return {
                                        type: 'dsa',
                                        params: ndata.algorithm.params
                                    };
                                default: throw new Error('unknown key id ' + subtype);
                            }
                            throw new Error('unknown key type ' + type);
                        case 'RSA PUBLIC KEY':
                            return asn1.RSAPublicKey.decode(data, 'der');
                        case 'RSA PRIVATE KEY':
                            return asn1.RSAPrivateKey.decode(data, 'der');
                        case 'DSA PRIVATE KEY':
                            return {
                                type: 'dsa',
                                params: asn1.DSAPrivateKey.decode(data, 'der')
                            };
                        case 'EC PRIVATE KEY':
                            data = asn1.ECPrivateKey.decode(data, 'der');
                            return {
                                curve: data.parameters.value,
                                privateKey: data.privateKey
                            };
                        default: throw new Error('unknown key type ' + type);
                    }
                }
                parseKeys.signature = asn1.signature;
                function decrypt(data, password) {
                    var salt = data.algorithm.decrypt.kde.kdeparams.salt;
                    var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
                    var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
                    var iv = data.algorithm.decrypt.cipher.iv;
                    var cipherText = data.subjectPrivateKey;
                    var keylen = parseInt(algo.split('-')[1], 10) / 8;
                    var key = compat.pbkdf2Sync(password, salt, iters, keylen);
                    var cipher = ciphers.createDecipheriv(algo, key, iv);
                    var out = [];
                    out.push(cipher.update(cipherText));
                    out.push(cipher.final());
                    return Buffer.concat(out);
                }

            }).call(this, require("buffer").Buffer)
        }, { "./aesid.json": 222, "./asn1": 223, "./fixProc": 224, "browserify-aes": 180, "buffer": 172, "pbkdf2": 287 }], 226: [function (require, module, exports) {
            var asn1 = exports;
            
            asn1.bignum = require('bn.js');
            
            asn1.define = require('./asn1/api').define;
            asn1.base = require('./asn1/base');
            asn1.constants = require('./asn1/constants');
            asn1.decoders = require('./asn1/decoders');
            asn1.encoders = require('./asn1/encoders');

        }, { "./asn1/api": 227, "./asn1/base": 229, "./asn1/constants": 233, "./asn1/decoders": 235, "./asn1/encoders": 238, "bn.js": 198 }], 227: [function (require, module, exports) {
            var asn1 = require('../asn1');
            var inherits = require('inherits');
            
            var api = exports;
            
            api.define = function define(name, body) {
                return new Entity(name, body);
            };
            
            function Entity(name, body) {
                this.name = name;
                this.body = body;
                
                this.decoders = {};
                this.encoders = {};
            }            ;
            
            Entity.prototype._createNamed = function createNamed(base) {
                var named;
                try {
                    named = require('vm').runInThisContext(
                        '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
                    );
                } catch (e) {
                    named = function (entity) {
                        this._initNamed(entity);
                    };
                }
                inherits(named, base);
                named.prototype._initNamed = function initnamed(entity) {
                    base.call(this, entity);
                };
                
                return new named(this);
            };
            
            Entity.prototype._getDecoder = function _getDecoder(enc) {
                // Lazily create decoder
                if (!this.decoders.hasOwnProperty(enc))
                    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
                return this.decoders[enc];
            };
            
            Entity.prototype.decode = function decode(data, enc, options) {
                return this._getDecoder(enc).decode(data, options);
            };
            
            Entity.prototype._getEncoder = function _getEncoder(enc) {
                // Lazily create encoder
                if (!this.encoders.hasOwnProperty(enc))
                    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
                return this.encoders[enc];
            };
            
            Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
                return this._getEncoder(enc).encode(data, reporter);
            };

        }, { "../asn1": 226, "inherits": 318, "vm": 343 }], 228: [function (require, module, exports) {
            var inherits = require('inherits');
            var Reporter = require('../base').Reporter;
            var Buffer = require('buffer').Buffer;
            
            function DecoderBuffer(base, options) {
                Reporter.call(this, options);
                if (!Buffer.isBuffer(base)) {
                    this.error('Input not Buffer');
                    return;
                }
                
                this.base = base;
                this.offset = 0;
                this.length = base.length;
            }
            inherits(DecoderBuffer, Reporter);
            exports.DecoderBuffer = DecoderBuffer;
            
            DecoderBuffer.prototype.save = function save() {
                return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
            };
            
            DecoderBuffer.prototype.restore = function restore(save) {
                // Return skipped data
                var res = new DecoderBuffer(this.base);
                res.offset = save.offset;
                res.length = this.offset;
                
                this.offset = save.offset;
                Reporter.prototype.restore.call(this, save.reporter);
                
                return res;
            };
            
            DecoderBuffer.prototype.isEmpty = function isEmpty() {
                return this.offset === this.length;
            };
            
            DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
                if (this.offset + 1 <= this.length)
                    return this.base.readUInt8(this.offset++, true);
                else
                    return this.error(fail || 'DecoderBuffer overrun');
            }
            
            DecoderBuffer.prototype.skip = function skip(bytes, fail) {
                if (!(this.offset + bytes <= this.length))
                    return this.error(fail || 'DecoderBuffer overrun');
                
                var res = new DecoderBuffer(this.base);
                
                // Share reporter state
                res._reporterState = this._reporterState;
                
                res.offset = this.offset;
                res.length = this.offset + bytes;
                this.offset += bytes;
                return res;
            }
            
            DecoderBuffer.prototype.raw = function raw(save) {
                return this.base.slice(save ? save.offset : this.offset, this.length);
            }
            
            function EncoderBuffer(value, reporter) {
                if (Array.isArray(value)) {
                    this.length = 0;
                    this.value = value.map(function (item) {
                        if (!(item instanceof EncoderBuffer))
                            item = new EncoderBuffer(item, reporter);
                        this.length += item.length;
                        return item;
                    }, this);
                } else if (typeof value === 'number') {
                    if (!(0 <= value && value <= 0xff))
                        return reporter.error('non-byte EncoderBuffer value');
                    this.value = value;
                    this.length = 1;
                } else if (typeof value === 'string') {
                    this.value = value;
                    this.length = Buffer.byteLength(value);
                } else if (Buffer.isBuffer(value)) {
                    this.value = value;
                    this.length = value.length;
                } else {
                    return reporter.error('Unsupported type: ' + typeof value);
                }
            }
            exports.EncoderBuffer = EncoderBuffer;
            
            EncoderBuffer.prototype.join = function join(out, offset) {
                if (!out)
                    out = new Buffer(this.length);
                if (!offset)
                    offset = 0;
                
                if (this.length === 0)
                    return out;
                
                if (Array.isArray(this.value)) {
                    this.value.forEach(function (item) {
                        item.join(out, offset);
                        offset += item.length;
                    });
                } else {
                    if (typeof this.value === 'number')
                        out[offset] = this.value;
                    else if (typeof this.value === 'string')
                        out.write(this.value, offset);
                    else if (Buffer.isBuffer(this.value))
                        this.value.copy(out, offset);
                    offset += this.length;
                }
                
                return out;
            };

        }, { "../base": 229, "buffer": 172, "inherits": 318 }], 229: [function (require, module, exports) {
            var base = exports;
            
            base.Reporter = require('./reporter').Reporter;
            base.DecoderBuffer = require('./buffer').DecoderBuffer;
            base.EncoderBuffer = require('./buffer').EncoderBuffer;
            base.Node = require('./node');

        }, { "./buffer": 228, "./node": 230, "./reporter": 231 }], 230: [function (require, module, exports) {
            var Reporter = require('../base').Reporter;
            var EncoderBuffer = require('../base').EncoderBuffer;
            var assert = require('minimalistic-assert');
            
            // Supported tags
            var tags = [
                'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
                'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str'
            ];
            
            // Public methods list
            var methods = [
                'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
                'any'
            ].concat(tags);
            
            // Overrided methods list
            var overrided = [
                '_peekTag', '_decodeTag', '_use',
                '_decodeStr', '_decodeObjid', '_decodeTime',
                '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

                '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
                '_encodeNull', '_encodeInt', '_encodeBool'
            ];
            
            function Node(enc, parent) {
                var state = {};
                this._baseState = state;
                
                state.enc = enc;
                
                state.parent = parent || null;
                state.children = null;
                
                // State
                state.tag = null;
                state.args = null;
                state.reverseArgs = null;
                state.choice = null;
                state.optional = false;
                state.any = false;
                state.obj = false;
                state.use = null;
                state.useDecoder = null;
                state.key = null;
                state['default'] = null;
                state.explicit = null;
                state.implicit = null;
                
                // Should create new instance on each method
                if (!state.parent) {
                    state.children = [];
                    this._wrap();
                }
            }
            module.exports = Node;
            
            var stateProps = [
                'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
                'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
                'implicit'
            ];
            
            Node.prototype.clone = function clone() {
                var state = this._baseState;
                var cstate = {};
                stateProps.forEach(function (prop) {
                    cstate[prop] = state[prop];
                });
                var res = new this.constructor(cstate.parent);
                res._baseState = cstate;
                return res;
            };
            
            Node.prototype._wrap = function wrap() {
                var state = this._baseState;
                methods.forEach(function (method) {
                    this[method] = function _wrappedMethod() {
                        var clone = new this.constructor(this);
                        state.children.push(clone);
                        return clone[method].apply(clone, arguments);
                    };
                }, this);
            };
            
            Node.prototype._init = function init(body) {
                var state = this._baseState;
                
                assert(state.parent === null);
                body.call(this);
                
                // Filter children
                state.children = state.children.filter(function (child) {
                    return child._baseState.parent === this;
                }, this);
                assert.equal(state.children.length, 1, 'Root node can have only one child');
            };
            
            Node.prototype._useArgs = function useArgs(args) {
                var state = this._baseState;
                
                // Filter children and args
                var children = args.filter(function (arg) {
                    return arg instanceof this.constructor;
                }, this);
                args = args.filter(function (arg) {
                    return !(arg instanceof this.constructor);
                }, this);
                
                if (children.length !== 0) {
                    assert(state.children === null);
                    state.children = children;
                    
                    // Replace parent to maintain backward link
                    children.forEach(function (child) {
                        child._baseState.parent = this;
                    }, this);
                }
                if (args.length !== 0) {
                    assert(state.args === null);
                    state.args = args;
                    state.reverseArgs = args.map(function (arg) {
                        if (typeof arg !== 'object' || arg.constructor !== Object)
                            return arg;
                        
                        var res = {};
                        Object.keys(arg).forEach(function (key) {
                            if (key == (key | 0))
                                key |= 0;
                            var value = arg[key];
                            res[value] = key;
                        });
                        return res;
                    });
                }
            };
            
            //
            // Overrided methods
            //
            
            overrided.forEach(function (method) {
                Node.prototype[method] = function _overrided() {
                    var state = this._baseState;
                    throw new Error(method + ' not implemented for encoding: ' + state.enc);
                };
            });
            
            //
            // Public methods
            //
            
            tags.forEach(function (tag) {
                Node.prototype[tag] = function _tagMethod() {
                    var state = this._baseState;
                    var args = Array.prototype.slice.call(arguments);
                    
                    assert(state.tag === null);
                    state.tag = tag;
                    
                    this._useArgs(args);
                    
                    return this;
                };
            });
            
            Node.prototype.use = function use(item) {
                var state = this._baseState;
                
                assert(state.use === null);
                state.use = item;
                
                return this;
            };
            
            Node.prototype.optional = function optional() {
                var state = this._baseState;
                
                state.optional = true;
                
                return this;
            };
            
            Node.prototype.def = function def(val) {
                var state = this._baseState;
                
                assert(state['default'] === null);
                state['default'] = val;
                state.optional = true;
                
                return this;
            };
            
            Node.prototype.explicit = function explicit(num) {
                var state = this._baseState;
                
                assert(state.explicit === null && state.implicit === null);
                state.explicit = num;
                
                return this;
            };
            
            Node.prototype.implicit = function implicit(num) {
                var state = this._baseState;
                
                assert(state.explicit === null && state.implicit === null);
                state.implicit = num;
                
                return this;
            };
            
            Node.prototype.obj = function obj() {
                var state = this._baseState;
                var args = Array.prototype.slice.call(arguments);
                
                state.obj = true;
                
                if (args.length !== 0)
                    this._useArgs(args);
                
                return this;
            };
            
            Node.prototype.key = function key(newKey) {
                var state = this._baseState;
                
                assert(state.key === null);
                state.key = newKey;
                
                return this;
            };
            
            Node.prototype.any = function any() {
                var state = this._baseState;
                
                state.any = true;
                
                return this;
            };
            
            Node.prototype.choice = function choice(obj) {
                var state = this._baseState;
                
                assert(state.choice === null);
                state.choice = obj;
                this._useArgs(Object.keys(obj).map(function (key) {
                    return obj[key];
                }));
                
                return this;
            };
            
            //
            // Decoding
            //
            
            Node.prototype._decode = function decode(input) {
                var state = this._baseState;
                
                // Decode root node
                if (state.parent === null)
                    return input.wrapResult(state.children[0]._decode(input));
                
                var result = state['default'];
                var present = true;
                
                var prevKey;
                if (state.key !== null)
                    prevKey = input.enterKey(state.key);
                
                // Check if tag is there
                if (state.optional) {
                    present = this._peekTag(
                        input,
      state.explicit !== null ? state.explicit :
          state.implicit !== null ? state.implicit :
              state.tag || 0,
      state.any
                    );
                    if (input.isError(present))
                        return present;
                }
                
                // Push object on stack
                var prevObj;
                if (state.obj && present)
                    prevObj = input.enterObject();
                
                if (present) {
                    // Unwrap explicit values
                    if (state.explicit !== null) {
                        var explicit = this._decodeTag(input, state.explicit);
                        if (input.isError(explicit))
                            return explicit;
                        input = explicit;
                    }
                    
                    // Unwrap implicit and normal values
                    if (state.use === null && state.choice === null) {
                        if (state.any)
                            var save = input.save();
                        var body = this._decodeTag(
                            input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
                        );
                        if (input.isError(body))
                            return body;
                        
                        if (state.any)
                            result = input.raw(save);
                        else
                            input = body;
                    }
                    
                    // Select proper method for tag
                    if (state.any)
                        result = result;
                    else if (state.choice === null)
                        result = this._decodeGeneric(state.tag, input);
                    else
                        result = this._decodeChoice(input);
                    
                    if (input.isError(result))
                        return result;
                    
                    // Decode children
                    if (!state.any && state.choice === null && state.children !== null) {
                        var fail = state.children.some(function decodeChildren(child) {
                            // NOTE: We are ignoring errors here, to let parser continue with other
                            // parts of encoded data
                            child._decode(input);
                        });
                        if (fail)
                            return err;
                    }
                }
                
                // Pop object
                if (state.obj && present)
                    result = input.leaveObject(prevObj);
                
                // Set key
                if (state.key !== null && (result !== null || present === true))
                    input.leaveKey(prevKey, state.key, result);
                
                return result;
            };
            
            Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
                var state = this._baseState;
                
                if (tag === 'seq' || tag === 'set')
                    return null;
                if (tag === 'seqof' || tag === 'setof')
                    return this._decodeList(input, tag, state.args[0]);
                else if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
                    return this._decodeStr(input, tag);
                else if (tag === 'objid' && state.args)
                    return this._decodeObjid(input, state.args[0], state.args[1]);
                else if (tag === 'objid')
                    return this._decodeObjid(input, null, null);
                else if (tag === 'gentime' || tag === 'utctime')
                    return this._decodeTime(input, tag);
                else if (tag === 'null_')
                    return this._decodeNull(input);
                else if (tag === 'bool')
                    return this._decodeBool(input);
                else if (tag === 'int' || tag === 'enum')
                    return this._decodeInt(input, state.args && state.args[0]);
                else if (state.use !== null)
                    return this._getUse(state.use, input._reporterState.obj)._decode(input);
                else
                    return input.error('unknown tag: ' + tag);
                
                return null;
            };
            
            Node.prototype._getUse = function _getUse(entity, obj) {
                
                var state = this._baseState;
                // Create altered use decoder if implicit is set
                state.useDecoder = this._use(entity, obj);
                assert(state.useDecoder._baseState.parent === null);
                state.useDecoder = state.useDecoder._baseState.children[0];
                if (state.implicit !== state.useDecoder._baseState.implicit) {
                    state.useDecoder = state.useDecoder.clone();
                    state.useDecoder._baseState.implicit = state.implicit;
                }
                return state.useDecoder;
            };
            
            Node.prototype._decodeChoice = function decodeChoice(input) {
                var state = this._baseState;
                var result = null;
                var match = false;
                
                Object.keys(state.choice).some(function (key) {
                    var save = input.save();
                    var node = state.choice[key];
                    try {
                        var value = node._decode(input);
                        if (input.isError(value))
                            return false;
                        
                        result = { type: key, value: value };
                        match = true;
                    } catch (e) {
                        input.restore(save);
                        return false;
                    }
                    return true;
                }, this);
                
                if (!match)
                    return input.error('Choice not matched');
                
                return result;
            };
            
            //
            // Encoding
            //
            
            Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
                return new EncoderBuffer(data, this.reporter);
            };
            
            Node.prototype._encode = function encode(data, reporter, parent) {
                var state = this._baseState;
                if (state['default'] !== null && state['default'] === data)
                    return;
                
                var result = this._encodeValue(data, reporter, parent);
                if (result === undefined)
                    return;
                
                if (this._skipDefault(result, reporter, parent))
                    return;
                
                return result;
            };
            
            Node.prototype._encodeValue = function encode(data, reporter, parent) {
                var state = this._baseState;
                
                // Decode root node
                if (state.parent === null)
                    return state.children[0]._encode(data, reporter || new Reporter());
                
                var result = null;
                var present = true;
                
                // Set reporter to share it with a child class
                this.reporter = reporter;
                
                // Check if data is there
                if (state.optional && data === undefined) {
                    if (state['default'] !== null)
                        data = state['default']
                    else
                        return;
                }
                
                // For error reporting
                var prevKey;
                
                // Encode children first
                var content = null;
                var primitive = false;
                if (state.any) {
                    // Anything that was given is translated to buffer
                    result = this._createEncoderBuffer(data);
                } else if (state.choice) {
                    result = this._encodeChoice(data, reporter);
                } else if (state.children) {
                    content = state.children.map(function (child) {
                        if (child._baseState.tag === 'null_')
                            return child._encode(null, reporter, data);
                        
                        if (child._baseState.key === null)
                            return reporter.error('Child should have a key');
                        var prevKey = reporter.enterKey(child._baseState.key);
                        
                        if (typeof data !== 'object')
                            return reporter.error('Child expected, but input is not object');
                        
                        var res = child._encode(data[child._baseState.key], reporter, data);
                        reporter.leaveKey(prevKey);
                        
                        return res;
                    }, this).filter(function (child) {
                        return child;
                    });
                    
                    content = this._createEncoderBuffer(content);
                } else {
                    if (state.tag === 'seqof' || state.tag === 'setof') {
                        // TODO(indutny): this should be thrown on DSL level
                        if (!(state.args && state.args.length === 1))
                            return reporter.error('Too many args for : ' + state.tag);
                        
                        if (!Array.isArray(data))
                            return reporter.error('seqof/setof, but data is not Array');
                        
                        var child = this.clone();
                        child._baseState.implicit = null;
                        content = this._createEncoderBuffer(data.map(function (item) {
                            var state = this._baseState;
                            
                            return this._getUse(state.args[0], data)._encode(item, reporter);
                        }, child));
                    } else if (state.use !== null) {
                        result = this._getUse(state.use, parent)._encode(data, reporter);
                    } else {
                        content = this._encodePrimitive(state.tag, data);
                        primitive = true;
                    }
                }
                
                // Encode data itself
                var result;
                if (!state.any && state.choice === null) {
                    var tag = state.implicit !== null ? state.implicit : state.tag;
                    var cls = state.implicit === null ? 'universal' : 'context';
                    
                    if (tag === null) {
                        if (state.use === null)
                            reporter.error('Tag could be ommited only for .use()');
                    } else {
                        if (state.use === null)
                            result = this._encodeComposite(tag, primitive, cls, content);
                    }
                }
                
                // Wrap in explicit
                if (state.explicit !== null)
                    result = this._encodeComposite(state.explicit, false, 'context', result);
                
                return result;
            };
            
            Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
                var state = this._baseState;
                
                var node = state.choice[data.type];
                if (!node) {
                    assert(
                        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
                }
                return node._encode(data.value, reporter);
            };
            
            Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
                var state = this._baseState;
                
                if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
                    return this._encodeStr(data, tag);
                else if (tag === 'objid' && state.args)
                    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
                else if (tag === 'objid')
                    return this._encodeObjid(data, null, null);
                else if (tag === 'gentime' || tag === 'utctime')
                    return this._encodeTime(data, tag);
                else if (tag === 'null_')
                    return this._encodeNull();
                else if (tag === 'int' || tag === 'enum')
                    return this._encodeInt(data, state.args && state.reverseArgs[0]);
                else if (tag === 'bool')
                    return this._encodeBool(data);
                else
                    throw new Error('Unsupported tag: ' + tag);
            };

        }, { "../base": 229, "minimalistic-assert": 240 }], 231: [function (require, module, exports) {
            var inherits = require('inherits');
            
            function Reporter(options) {
                this._reporterState = {
                    obj: null,
                    path: [],
                    options: options || {},
                    errors: []
                };
            }
            exports.Reporter = Reporter;
            
            Reporter.prototype.isError = function isError(obj) {
                return obj instanceof ReporterError;
            };
            
            Reporter.prototype.save = function save() {
                var state = this._reporterState;
                
                return { obj: state.obj, pathLen: state.path.length };
            };
            
            Reporter.prototype.restore = function restore(data) {
                var state = this._reporterState;
                
                state.obj = data.obj;
                state.path = state.path.slice(0, data.pathLen);
            };
            
            Reporter.prototype.enterKey = function enterKey(key) {
                return this._reporterState.path.push(key);
            };
            
            Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
                var state = this._reporterState;
                
                state.path = state.path.slice(0, index - 1);
                if (state.obj !== null)
                    state.obj[key] = value;
            };
            
            Reporter.prototype.enterObject = function enterObject() {
                var state = this._reporterState;
                
                var prev = state.obj;
                state.obj = {};
                return prev;
            };
            
            Reporter.prototype.leaveObject = function leaveObject(prev) {
                var state = this._reporterState;
                
                var now = state.obj;
                state.obj = prev;
                return now;
            };
            
            Reporter.prototype.error = function error(msg) {
                var err;
                var state = this._reporterState;
                
                var inherited = msg instanceof ReporterError;
                if (inherited) {
                    err = msg;
                } else {
                    err = new ReporterError(state.path.map(function (elem) {
                        return '[' + JSON.stringify(elem) + ']';
                    }).join(''), msg.message || msg, msg.stack);
                }
                
                if (!state.options.partial)
                    throw err;
                
                if (!inherited)
                    state.errors.push(err);
                
                return err;
            };
            
            Reporter.prototype.wrapResult = function wrapResult(result) {
                var state = this._reporterState;
                if (!state.options.partial)
                    return result;
                
                return {
                    result: this.isError(result) ? null : result,
                    errors: state.errors
                };
            };
            
            function ReporterError(path, msg) {
                this.path = path;
                this.rethrow(msg);
            }            ;
            inherits(ReporterError, Error);
            
            ReporterError.prototype.rethrow = function rethrow(msg) {
                this.message = msg + ' at: ' + (this.path || '(shallow)');
                Error.captureStackTrace(this, ReporterError);
                
                return this;
            };

        }, { "inherits": 318 }], 232: [function (require, module, exports) {
            var constants = require('../constants');
            
            exports.tagClass = {
                0: 'universal',
                1: 'application',
                2: 'context',
                3: 'private'
            };
            exports.tagClassByName = constants._reverse(exports.tagClass);
            
            exports.tag = {
                0x00: 'end',
                0x01: 'bool',
                0x02: 'int',
                0x03: 'bitstr',
                0x04: 'octstr',
                0x05: 'null_',
                0x06: 'objid',
                0x07: 'objDesc',
                0x08: 'external',
                0x09: 'real',
                0x0a: 'enum',
                0x0b: 'embed',
                0x0c: 'utf8str',
                0x0d: 'relativeOid',
                0x10: 'seq',
                0x11: 'set',
                0x12: 'numstr',
                0x13: 'printstr',
                0x14: 't61str',
                0x15: 'videostr',
                0x16: 'ia5str',
                0x17: 'utctime',
                0x18: 'gentime',
                0x19: 'graphstr',
                0x1a: 'iso646str',
                0x1b: 'genstr',
                0x1c: 'unistr',
                0x1d: 'charstr',
                0x1e: 'bmpstr'
            };
            exports.tagByName = constants._reverse(exports.tag);

        }, { "../constants": 233 }], 233: [function (require, module, exports) {
            var constants = exports;
            
            // Helper
            constants._reverse = function reverse(map) {
                var res = {};
                
                Object.keys(map).forEach(function (key) {
                    // Convert key to integer if it is stringified
                    if ((key | 0) == key)
                        key = key | 0;
                    
                    var value = map[key];
                    res[value] = key;
                });
                
                return res;
            };
            
            constants.der = require('./der');

        }, { "./der": 232 }], 234: [function (require, module, exports) {
            var inherits = require('inherits');
            
            var asn1 = require('../../asn1');
            var base = asn1.base;
            var bignum = asn1.bignum;
            
            // Import DER constants
            var der = asn1.constants.der;
            
            function DERDecoder(entity) {
                this.enc = 'der';
                this.name = entity.name;
                this.entity = entity;
                
                // Construct base tree
                this.tree = new DERNode();
                this.tree._init(entity.body);
            }            ;
            module.exports = DERDecoder;
            
            DERDecoder.prototype.decode = function decode(data, options) {
                if (!(data instanceof base.DecoderBuffer))
                    data = new base.DecoderBuffer(data, options);
                
                return this.tree._decode(data, options);
            };
            
            // Tree methods
            
            function DERNode(parent) {
                base.Node.call(this, 'der', parent);
            }
            inherits(DERNode, base.Node);
            
            DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
                if (buffer.isEmpty())
                    return false;
                
                var state = buffer.save();
                var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
                if (buffer.isError(decodedTag))
                    return decodedTag;
                
                buffer.restore(state);
                
                return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
            };
            
            DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
                var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
                if (buffer.isError(decodedTag))
                    return decodedTag;
                
                var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');
                
                // Failure
                if (buffer.isError(len))
                    return len;
                
                if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
                    return buffer.error('Failed to match tag: "' + tag + '"');
                }
                
                if (decodedTag.primitive || len !== null)
                    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
                
                // Indefinite length... find END tag
                var state = buffer.start();
                var res = this._skipUntilEnd(
                    buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
                if (buffer.isError(res))
                    return res;
                
                return buffer.cut(state);
            };
            
            DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
                while (true) {
                    var tag = derDecodeTag(buffer, fail);
                    if (buffer.isError(tag))
                        return tag;
                    var len = derDecodeLen(buffer, tag.primitive, fail);
                    if (buffer.isError(len))
                        return len;
                    
                    var res;
                    if (tag.primitive || len !== null)
                        res = buffer.skip(len)
                    else
                        res = this._skipUntilEnd(buffer, fail);
                    
                    // Failure
                    if (buffer.isError(res))
                        return res;
                    
                    if (tag.tagStr === 'end')
                        break;
                }
            };
            
            DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
                var result = [];
                while (!buffer.isEmpty()) {
                    var possibleEnd = this._peekTag(buffer, 'end');
                    if (buffer.isError(possibleEnd))
                        return possibleEnd;
                    
                    var res = decoder.decode(buffer, 'der');
                    if (buffer.isError(res) && possibleEnd)
                        break;
                    result.push(res);
                }
                return result;
            };
            
            DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
                if (tag === 'octstr') {
                    return buffer.raw();
                } else if (tag === 'bitstr') {
                    var unused = buffer.readUInt8();
                    if (buffer.isError(unused))
                        return unused;
                    
                    return { unused: unused, data: buffer.raw() };
                } else if (tag === 'ia5str') {
                    return buffer.raw().toString();
                } else {
                    return this.error('Decoding of string type: ' + tag + ' unsupported');
                }
            };
            
            DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
                var identifiers = [];
                var ident = 0;
                while (!buffer.isEmpty()) {
                    var subident = buffer.readUInt8();
                    ident <<= 7;
                    ident |= subident & 0x7f;
                    if ((subident & 0x80) === 0) {
                        identifiers.push(ident);
                        ident = 0;
                    }
                }
                if (subident & 0x80)
                    identifiers.push(ident);
                
                var first = (identifiers[0] / 40) | 0;
                var second = identifiers[0] % 40;
                
                if (relative)
                    result = identifiers;
                else
                    result = [first, second].concat(identifiers.slice(1));
                
                if (values)
                    result = values[result.join(' ')];
                
                return result;
            };
            
            DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
                var str = buffer.raw().toString();
                if (tag === 'gentime') {
                    var year = str.slice(0, 4) | 0;
                    var mon = str.slice(4, 6) | 0;
                    var day = str.slice(6, 8) | 0;
                    var hour = str.slice(8, 10) | 0;
                    var min = str.slice(10, 12) | 0;
                    var sec = str.slice(12, 14) | 0;
                } else if (tag === 'utctime') {
                    var year = str.slice(0, 2) | 0;
                    var mon = str.slice(2, 4) | 0;
                    var day = str.slice(4, 6) | 0;
                    var hour = str.slice(6, 8) | 0;
                    var min = str.slice(8, 10) | 0;
                    var sec = str.slice(10, 12) | 0;
                    if (year < 70)
                        year = 2000 + year;
                    else
                        year = 1900 + year;
                } else {
                    return this.error('Decoding ' + tag + ' time is not supported yet');
                }
                
                return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
            };
            
            DERNode.prototype._decodeNull = function decodeNull(buffer) {
                return null;
            };
            
            DERNode.prototype._decodeBool = function decodeBool(buffer) {
                var res = buffer.readUInt8();
                if (buffer.isError(res))
                    return res;
                else
                    return res !== 0;
            };
            
            DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
                // Bigint, return as it is (assume big endian)
                var raw = buffer.raw();
                var res = new bignum(raw);
                
                if (values)
                    res = values[res.toString(10)] || res;
                
                return res;
            };
            
            DERNode.prototype._use = function use(entity, obj) {
                if (typeof entity === 'function')
                    entity = entity(obj);
                return entity._getDecoder('der').tree;
            };
            
            // Utility methods
            
            function derDecodeTag(buf, fail) {
                var tag = buf.readUInt8(fail);
                if (buf.isError(tag))
                    return tag;
                
                var cls = der.tagClass[tag >> 6];
                var primitive = (tag & 0x20) === 0;
                
                // Multi-octet tag - load
                if ((tag & 0x1f) === 0x1f) {
                    var oct = tag;
                    tag = 0;
                    while ((oct & 0x80) === 0x80) {
                        oct = buf.readUInt8(fail);
                        if (buf.isError(oct))
                            return oct;
                        
                        tag <<= 7;
                        tag |= oct & 0x7f;
                    }
                } else {
                    tag &= 0x1f;
                }
                var tagStr = der.tag[tag];
                
                return {
                    cls: cls,
                    primitive: primitive,
                    tag: tag,
                    tagStr: tagStr
                };
            }
            
            function derDecodeLen(buf, primitive, fail) {
                var len = buf.readUInt8(fail);
                if (buf.isError(len))
                    return len;
                
                // Indefinite form
                if (!primitive && len === 0x80)
                    return null;
                
                // Definite form
                if ((len & 0x80) === 0) {
                    // Short form
                    return len;
                }
                
                // Long form
                var num = len & 0x7f;
                if (num >= 4)
                    return buf.error('length octect is too long');
                
                len = 0;
                for (var i = 0; i < num; i++) {
                    len <<= 8;
                    var j = buf.readUInt8(fail);
                    if (buf.isError(j))
                        return j;
                    len |= j;
                }
                
                return len;
            }

        }, { "../../asn1": 226, "inherits": 318 }], 235: [function (require, module, exports) {
            var decoders = exports;
            
            decoders.der = require('./der');
            decoders.pem = require('./pem');

        }, { "./der": 234, "./pem": 236 }], 236: [function (require, module, exports) {
            var inherits = require('inherits');
            var Buffer = require('buffer').Buffer;
            
            var asn1 = require('../../asn1');
            var DERDecoder = require('./der');
            
            function PEMDecoder(entity) {
                DERDecoder.call(this, entity);
                this.enc = 'pem';
            }            ;
            inherits(PEMDecoder, DERDecoder);
            module.exports = PEMDecoder;
            
            PEMDecoder.prototype.decode = function decode(data, options) {
                var lines = data.toString().split(/[\r\n]+/g);
                
                var label = options.label.toUpperCase();
                
                var re = /^-----(BEGIN|END) ([^-]+)-----$/;
                var start = -1;
                var end = -1;
                for (var i = 0; i < lines.length; i++) {
                    var match = lines[i].match(re);
                    if (match === null)
                        continue;
                    
                    if (match[2] !== label)
                        continue;
                    
                    if (start === -1) {
                        if (match[1] !== 'BEGIN')
                            break;
                        start = i;
                    } else {
                        if (match[1] !== 'END')
                            break;
                        end = i;
                        break;
                    }
                }
                if (start === -1 || end === -1)
                    throw new Error('PEM section not found for: ' + label);
                
                var base64 = lines.slice(start + 1, end).join('');
                // Remove excessive symbols
                base64.replace(/[^a-z0-9\+\/=]+/gi, '');
                
                var input = new Buffer(base64, 'base64');
                return DERDecoder.prototype.decode.call(this, input, options);
            };

        }, { "../../asn1": 226, "./der": 234, "buffer": 172, "inherits": 318 }], 237: [function (require, module, exports) {
            var inherits = require('inherits');
            var Buffer = require('buffer').Buffer;
            
            var asn1 = require('../../asn1');
            var base = asn1.base;
            var bignum = asn1.bignum;
            
            // Import DER constants
            var der = asn1.constants.der;
            
            function DEREncoder(entity) {
                this.enc = 'der';
                this.name = entity.name;
                this.entity = entity;
                
                // Construct base tree
                this.tree = new DERNode();
                this.tree._init(entity.body);
            }            ;
            module.exports = DEREncoder;
            
            DEREncoder.prototype.encode = function encode(data, reporter) {
                return this.tree._encode(data, reporter).join();
            };
            
            // Tree methods
            
            function DERNode(parent) {
                base.Node.call(this, 'der', parent);
            }
            inherits(DERNode, base.Node);
            
            DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
                var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
                
                // Short form
                if (content.length < 0x80) {
                    var header = new Buffer(2);
                    header[0] = encodedTag;
                    header[1] = content.length;
                    return this._createEncoderBuffer([header, content]);
                }
                
                // Long form
                // Count octets required to store length
                var lenOctets = 1;
                for (var i = content.length; i >= 0x100; i >>= 8)
                    lenOctets++;
                
                var header = new Buffer(1 + 1 + lenOctets);
                header[0] = encodedTag;
                header[1] = 0x80 | lenOctets;
                
                for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
                    header[i] = j & 0xff;
                
                return this._createEncoderBuffer([header, content]);
            };
            
            DERNode.prototype._encodeStr = function encodeStr(str, tag) {
                if (tag === 'octstr')
                    return this._createEncoderBuffer(str);
                else if (tag === 'bitstr')
                    return this._createEncoderBuffer([str.unused | 0, str.data]);
                else if (tag === 'ia5str')
                    return this._createEncoderBuffer(str);
                return this.reporter.error('Encoding of string type: ' + tag +
                             ' unsupported');
            };
            
            DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
                if (typeof id === 'string') {
                    if (!values)
                        return this.reporter.error('string objid given, but no values map found');
                    if (!values.hasOwnProperty(id))
                        return this.reporter.error('objid not found in values map');
                    id = values[id].split(/\s+/g);
                    for (var i = 0; i < id.length; i++)
                        id[i] |= 0;
                } else if (Array.isArray(id)) {
                    id = id.slice();
                }
                
                if (!Array.isArray(id)) {
                    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
                }
                
                if (!relative) {
                    if (id[1] >= 40)
                        return this.reporter.error('Second objid identifier OOB');
                    id.splice(0, 2, id[0] * 40 + id[1]);
                }
                
                // Count number of octets
                var size = 0;
                for (var i = 0; i < id.length; i++) {
                    var ident = id[i];
                    for (size++; ident >= 0x80; ident >>= 7)
                        size++;
                }
                
                var objid = new Buffer(size);
                var offset = objid.length - 1;
                for (var i = id.length - 1; i >= 0; i--) {
                    var ident = id[i];
                    objid[offset--] = ident & 0x7f;
                    while ((ident >>= 7) > 0)
                        objid[offset--] = 0x80 | (ident & 0x7f);
                }
                
                return this._createEncoderBuffer(objid);
            };
            
            function two(num) {
                if (num < 10)
                    return '0' + num;
                else
                    return num;
            }
            
            DERNode.prototype._encodeTime = function encodeTime(time, tag) {
                var str;
                var date = new Date(time);
                
                if (tag === 'gentime') {
                    str = [
                        two(date.getFullYear()),
                        two(date.getUTCMonth() + 1),
                        two(date.getUTCDate()),
                        two(date.getUTCHours()),
                        two(date.getUTCMinutes()),
                        two(date.getUTCSeconds()),
                        'Z'
                    ].join('');
                } else if (tag === 'utctime') {
                    str = [
                        two(date.getFullYear() % 100),
                        two(date.getUTCMonth() + 1),
                        two(date.getUTCDate()),
                        two(date.getUTCHours()),
                        two(date.getUTCMinutes()),
                        two(date.getUTCSeconds()),
                        'Z'
                    ].join('');
                } else {
                    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
                }
                
                return this._encodeStr(str, 'octstr');
            };
            
            DERNode.prototype._encodeNull = function encodeNull() {
                return this._createEncoderBuffer('');
            };
            
            DERNode.prototype._encodeInt = function encodeInt(num, values) {
                if (typeof num === 'string') {
                    if (!values)
                        return this.reporter.error('String int or enum given, but no values map');
                    if (!values.hasOwnProperty(num)) {
                        return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
                    }
                    num = values[num];
                }
                
                // Bignum, assume big endian
                if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
                    var numArray = num.toArray();
                    if (num.sign === false && numArray[0] & 0x80) {
                        numArray.unshift(0);
                    }
                    num = new Buffer(numArray);
                }
                
                if (Buffer.isBuffer(num)) {
                    var size = num.length;
                    if (num.length === 0)
                        size++;
                    
                    var out = new Buffer(size);
                    num.copy(out);
                    if (num.length === 0)
                        out[0] = 0
                    return this._createEncoderBuffer(out);
                }
                
                if (num < 0x80)
                    return this._createEncoderBuffer(num);
                
                if (num < 0x100)
                    return this._createEncoderBuffer([0, num]);
                
                var size = 1;
                for (var i = num; i >= 0x100; i >>= 8)
                    size++;
                
                var out = new Array(size);
                for (var i = out.length - 1; i >= 0; i--) {
                    out[i] = num & 0xff;
                    num >>= 8;
                }
                if (out[0] & 0x80) {
                    out.unshift(0);
                }
                
                return this._createEncoderBuffer(new Buffer(out));
            };
            
            DERNode.prototype._encodeBool = function encodeBool(value) {
                return this._createEncoderBuffer(value ? 0xff : 0);
            };
            
            DERNode.prototype._use = function use(entity, obj) {
                if (typeof entity === 'function')
                    entity = entity(obj);
                return entity._getEncoder('der').tree;
            };
            
            DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
                var state = this._baseState;
                var i;
                if (state['default'] === null)
                    return false;
                
                var data = dataBuffer.join();
                if (state.defaultBuffer === undefined)
                    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();
                
                if (data.length !== state.defaultBuffer.length)
                    return false;
                
                for (i = 0; i < data.length; i++)
                    if (data[i] !== state.defaultBuffer[i])
                        return false;
                
                return true;
            };
            
            // Utility methods
            
            function encodeTag(tag, primitive, cls, reporter) {
                var res;
                
                if (tag === 'seqof')
                    tag = 'seq';
                else if (tag === 'setof')
                    tag = 'set';
                
                if (der.tagByName.hasOwnProperty(tag))
                    res = der.tagByName[tag];
                else if (typeof tag === 'number' && (tag | 0) === tag)
                    res = tag;
                else
                    return reporter.error('Unknown tag: ' + tag);
                
                if (res >= 0x1f)
                    return reporter.error('Multi-octet tag encoding unsupported');
                
                if (!primitive)
                    res |= 0x20;
                
                res |= (der.tagClassByName[cls || 'universal'] << 6);
                
                return res;
            }

        }, { "../../asn1": 226, "buffer": 172, "inherits": 318 }], 238: [function (require, module, exports) {
            var encoders = exports;
            
            encoders.der = require('./der');
            encoders.pem = require('./pem');

        }, { "./der": 237, "./pem": 239 }], 239: [function (require, module, exports) {
            var inherits = require('inherits');
            var Buffer = require('buffer').Buffer;
            
            var asn1 = require('../../asn1');
            var DEREncoder = require('./der');
            
            function PEMEncoder(entity) {
                DEREncoder.call(this, entity);
                this.enc = 'pem';
            }            ;
            inherits(PEMEncoder, DEREncoder);
            module.exports = PEMEncoder;
            
            PEMEncoder.prototype.encode = function encode(data, options) {
                var buf = DEREncoder.prototype.encode.call(this, data);
                
                var p = buf.toString('base64');
                var out = ['-----BEGIN ' + options.label + '-----'];
                for (var i = 0; i < p.length; i += 64)
                    out.push(p.slice(i, i + 64));
                out.push('-----END ' + options.label + '-----');
                return out.join('\n');
            };

        }, { "../../asn1": 226, "./der": 237, "buffer": 172, "inherits": 318 }], 240: [function (require, module, exports) {
            module.exports = assert;
            
            function assert(val, msg) {
                if (!val)
                    throw new Error(msg || 'Assertion failed');
            }
            
            assert.equal = function assertEqual(l, r, msg) {
                if (l != r)
                    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
            };

        }, {}], 241: [function (require, module, exports) {
            (function (Buffer) {
                // much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
                var parseKeys = require('parse-asn1')
                var BN = require('bn.js')
                var elliptic = require('elliptic')
                var crt = require('browserify-rsa')
                var createHmac = require('create-hmac')
                var curves = require('./curves')
                
                module.exports = sign
                function sign(hash, key, hashType, signType) {
                    var priv = parseKeys(key)
                    if (priv.curve) {
                        if (signType !== 'ecdsa') {
                            throw new Error('wrong private key type')
                        }
                        return ecSign(hash, priv)
                    } else if (priv.type === 'dsa') {
                        return dsaSign(hash, priv, hashType)
                        if (signType !== 'dsa') {
                            throw new Error('wrong private key type')
                        }
                    } else {
                        if (signType !== 'rsa') {
                            throw new Error('wrong private key type')
                        }
                    }
                    var len = priv.modulus.byteLength()
                    var pad = [0, 1]
                    while (hash.length + pad.length + 1 < len) {
                        pad.push(0xff)
                    }
                    pad.push(0x00)
                    var i = -1
                    while (++i < hash.length) {
                        pad.push(hash[i])
                    }
                    
                    var out = crt(pad, priv)
                    return out
                }
                function ecSign(hash, priv) {
                    var curveId = curves[priv.curve.join('.')]
                    if (!curveId)
                        throw new Error('unknown curve ' + priv.curve.join('.'))
                    
                    var curve = new elliptic.ec(curveId)
                    
                    var key = curve.genKeyPair()
                    key._importPrivate(priv.privateKey)
                    var out = key.sign(hash)
                    return new Buffer(out.toDER())
                }
                function dsaSign(hash, priv, algo) {
                    var x = priv.params.priv_key
                    var p = priv.params.p
                    var q = priv.params.q
                    var montq = BN.mont(q)
                    var g = priv.params.g
                    var r = new BN(0)
                    var k
                    var H = bits2int(hash, q).mod(q)
                    var s = false
                    var kv = getKey(x, q, hash, algo)
                    while (s === false) {
                        k = makeKey(q, kv, algo)
                        r = makeR(g, k, p, q)
                        s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
                        if (!s.cmpn(0)) {
                            s = false
                            r = new BN(0)
                        }
                    }
                    return toDER(r, s)
                }
                function toDER(r, s) {
                    r = r.toArray()
                    s = s.toArray()
                    
                    // Pad values
                    if (r[0] & 0x80)
                        r = [0].concat(r)
                    // Pad values
                    if (s[0] & 0x80)
                        s = [0].concat(s)
                    
                    var total = r.length + s.length + 4
                    var res = [0x30, total, 0x02, r.length]
                    res = res.concat(r, [0x02, s.length], s)
                    return new Buffer(res)
                }
                module.exports.getKey = getKey
                function getKey(x, q, hash, algo) {
                    x = new Buffer(x.toArray())
                    if (x.length < q.byteLength()) {
                        var zeros = new Buffer(q.byteLength() - x.length)
                        zeros.fill(0)
                        x = Buffer.concat([zeros, x])
                    }
                    var hlen = hash.length
                    var hbits = bits2octets(hash, q)
                    var v = new Buffer(hlen)
                    v.fill(1)
                    var k = new Buffer(hlen)
                    k.fill(0)
                    k = createHmac(algo, k)
    .update(v)
    .update(new Buffer([0]))
    .update(x)
    .update(hbits)
    .digest()
                    v = createHmac(algo, k)
    .update(v)
    .digest()
                    k = createHmac(algo, k)
    .update(v)
    .update(new Buffer([1]))
    .update(x)
    .update(hbits)
    .digest()
                    v = createHmac(algo, k)
    .update(v)
    .digest()
                    return {
                        k: k,
                        v: v
                    }
                }
                function bits2int(obits, q) {
                    var bits = new BN(obits)
                    var shift = (obits.length << 3) - q.bitLength()
                    if (shift > 0) {
                        bits.ishrn(shift)
                    }
                    return bits
                }
                function bits2octets(bits, q) {
                    bits = bits2int(bits, q)
                    bits = bits.mod(q)
                    var out = new Buffer(bits.toArray())
                    if (out.length < q.byteLength()) {
                        var zeros = new Buffer(q.byteLength() - out.length)
                        zeros.fill(0)
                        out = Buffer.concat([zeros, out])
                    }
                    return out
                }
                module.exports.makeKey = makeKey
                function makeKey(q, kv, algo) {
                    var t
                    var k
                    while (true) {
                        t = new Buffer('')
                        while (t.length * 8 < q.bitLength()) {
                            kv.v = createHmac(algo, kv.k)
        .update(kv.v)
        .digest()
                            t = Buffer.concat([t, kv.v])
                        }
                        k = bits2int(t, q)
                        kv.k = createHmac(algo, kv.k)
        .update(kv.v)
        .update(new Buffer([0]))
        .digest()
                        kv.v = createHmac(algo, kv.k)
        .update(kv.v)
        .digest()
                        if (k.cmp(q) === -1) {
                            return k
                        }
                    }
                }
                function makeR(g, k, p, q) {
                    return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
                }

            }).call(this, require("buffer").Buffer)
        }, { "./curves": 197, "bn.js": 198, "browserify-rsa": 199, "buffer": 172, "create-hmac": 279, "elliptic": 200, "parse-asn1": 225 }], 242: [function (require, module, exports) {
            (function (Buffer) {
                'use strict'
                // much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
                var parseKeys = require('parse-asn1')
                var elliptic = require('elliptic')
                var curves = require('./curves')
                var BN = require('bn.js')
                module.exports = verify
                
                function verify(sig, hash, key, signType) {
                    var pub = parseKeys(key)
                    if (pub.type === 'ec') {
                        if (signType !== 'ecdsa') {
                            throw new Error('wrong public key type')
                        }
                        return ecVerify(sig, hash, pub)
                    } else if (pub.type === 'dsa') {
                        if (signType !== 'dsa') {
                            throw new Error('wrong public key type')
                        }
                        return dsaVerify(sig, hash, pub)
                    } else {
                        if (signType !== 'rsa') {
                            throw new Error('wrong public key type')
                        }
                    }
                    var len = pub.modulus.byteLength()
                    var pad = [1]
                    var padNum = 0
                    while (hash.length + pad.length + 2 < len) {
                        pad.push(0xff)
                        padNum++
                    }
                    pad.push(0x00)
                    var i = -1
                    while (++i < hash.length) {
                        pad.push(hash[i])
                    }
                    pad = new Buffer(pad)
                    var red = BN.mont(pub.modulus)
                    sig = new BN(sig).toRed(red)
                    
                    sig = sig.redPow(new BN(pub.publicExponent))
                    
                    sig = new Buffer(sig.fromRed().toArray())
                    var out = 0
                    if (padNum < 8) {
                        out = 1
                    }
                    len = Math.min(sig.length, pad.length)
                    if (sig.length !== pad.length) {
                        out = 1
                    }
                    
                    i = -1
                    while (++i < len) {
                        out |= (sig[i] ^ pad[i])
                    }
                    return out === 0
                }
                function ecVerify(sig, hash, pub) {
                    var curveId = curves[pub.data.algorithm.curve.join('.')]
                    if (!curveId)
                        throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))
                    
                    var curve = new elliptic.ec(curveId)
                    
                    var pubkey = pub.data.subjectPrivateKey.data
                    return curve.verify(hash, sig, pubkey)
                }
                function dsaVerify(sig, hash, pub) {
                    var p = pub.data.p
                    var q = pub.data.q
                    var g = pub.data.g
                    var y = pub.data.pub_key
                    var unpacked = parseKeys.signature.decode(sig, 'der')
                    var s = unpacked.s
                    var r = unpacked.r
                    checkValue(s, q)
                    checkValue(r, q)
                    var montq = BN.mont(q)
                    var montp = BN.mont(p)
                    var w = s.invm(q)
                    var v = g.toRed(montp)
  .redPow(new BN(hash).mul(w).mod(q))
  .fromRed()
  .mul(
                        y.toRed(montp)
    .redPow(r.mul(w).mod(q))
    .fromRed()
                    ).mod(p).mod(q)
                    return !v.cmp(r)
                }
                function checkValue(b, q) {
                    if (b.cmpn(0) <= 0) {
                        throw new Error('invalid sig')
                    }
                    if (b.cmp(q) >= q) {
                        throw new Error('invalid sig')
                    }
                }

            }).call(this, require("buffer").Buffer)
        }, { "./curves": 197, "bn.js": 198, "buffer": 172, "elliptic": 200, "parse-asn1": 225 }], 243: [function (require, module, exports) {
            (function (Buffer) {
                var elliptic = require('elliptic');
                var BN = require('bn.js');
                
                module.exports = function createECDH(curve) {
                    return new ECDH(curve);
                };
                
                var aliases = {
                    secp256k1: {
                        name: 'secp256k1',
                        byteLength: 32
                    },
                    secp224r1: {
                        name: 'p224',
                        byteLength: 28
                    },
                    prime256v1: {
                        name: 'p256',
                        byteLength: 32
                    },
                    prime192v1: {
                        name: 'p192',
                        byteLength: 24
                    },
                    ed25519: {
                        name: 'ed25519',
                        byteLength: 32
                    }
                };
                
                aliases.p224 = aliases.secp224r1;
                aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
                aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
                
                function ECDH(curve) {
                    this.curveType = aliases[curve];
                    if (!this.curveType) {
                        this.curveType = {
                            name: curve
                        };
                    }
                    this.curve = new elliptic.ec(this.curveType.name);
                    this.keys = void 0;
                }
                
                ECDH.prototype.generateKeys = function (enc, format) {
                    this.keys = this.curve.genKeyPair();
                    return this.getPublicKey(enc, format);
                };
                
                ECDH.prototype.computeSecret = function (other, inenc, enc) {
                    inenc = inenc || 'utf8';
                    if (!Buffer.isBuffer(other)) {
                        other = new Buffer(other, inenc);
                    }
                    var otherPub = this.curve.keyFromPublic(other).getPublic();
                    var out = otherPub.mul(this.keys.getPrivate()).getX();
                    return formatReturnValue(out, enc, this.curveType.byteLength);
                };
                
                ECDH.prototype.getPublicKey = function (enc, format) {
                    var key = this.keys.getPublic(format === 'compressed', true);
                    if (format === 'hybrid') {
                        if (key[key.length - 1] % 2) {
                            key[0] = 7;
                        } else {
                            key [0] = 6;
                        }
                    }
                    return formatReturnValue(key, enc);
                };
                
                ECDH.prototype.getPrivateKey = function (enc) {
                    return formatReturnValue(this.keys.getPrivate(), enc);
                };
                
                ECDH.prototype.setPublicKey = function (pub, enc) {
                    enc = enc || 'utf8';
                    if (!Buffer.isBuffer(pub)) {
                        pub = new Buffer(pub, enc);
                    }
                    this.keys._importPublic(pub);
                    return this;
                };
                
                ECDH.prototype.setPrivateKey = function (priv, enc) {
                    enc = enc || 'utf8';
                    if (!Buffer.isBuffer(priv)) {
                        priv = new Buffer(priv, enc);
                    }
                    var _priv = new BN(priv);
                    _priv = _priv.toString(16);
                    this.keys._importPrivate(_priv);
                    return this;
                };
                
                function formatReturnValue(bn, enc, len) {
                    if (!Array.isArray(bn)) {
                        bn = bn.toArray();
                    }
                    var buf = new Buffer(bn);
                    if (len && buf.length < len) {
                        var zeros = new Buffer(len - buf.length);
                        zeros.fill(0);
                        buf = Buffer.concat([zeros, buf]);
                    }
                    if (!enc) {
                        return buf;
                    } else {
                        return buf.toString(enc);
                    }
                }

            }).call(this, require("buffer").Buffer)
        }, { "bn.js": 245, "buffer": 172, "elliptic": 246 }], 244: [function (require, module, exports) {
            var createECDH = require('crypto').createECDH;
            
            module.exports = createECDH || require('./browser');
        }, { "./browser": 243, "crypto": 176 }], 245: [function (require, module, exports) {
            arguments[4][198][0].apply(exports, arguments)
        }, { "dup": 198 }], 246: [function (require, module, exports) {
            arguments[4][200][0].apply(exports, arguments)
        }, { "../package.json": 266, "./elliptic/curve": 249, "./elliptic/curves": 252, "./elliptic/ec": 253, "./elliptic/hmac-drbg": 256, "./elliptic/utils": 258, "brorand": 259, "dup": 200 }], 247: [function (require, module, exports) {
            arguments[4][201][0].apply(exports, arguments)
        }, { "../../elliptic": 246, "bn.js": 245, "dup": 201 }], 248: [function (require, module, exports) {
            arguments[4][202][0].apply(exports, arguments)
        }, { "../../elliptic": 246, "../curve": 249, "bn.js": 245, "dup": 202, "inherits": 318 }], 249: [function (require, module, exports) {
            arguments[4][203][0].apply(exports, arguments)
        }, { "./base": 247, "./edwards": 248, "./mont": 250, "./short": 251, "dup": 203 }], 250: [function (require, module, exports) {
            arguments[4][204][0].apply(exports, arguments)
        }, { "../curve": 249, "bn.js": 245, "dup": 204, "inherits": 318 }], 251: [function (require, module, exports) {
            arguments[4][205][0].apply(exports, arguments)
        }, { "../../elliptic": 246, "../curve": 249, "bn.js": 245, "dup": 205, "inherits": 318 }], 252: [function (require, module, exports) {
            arguments[4][206][0].apply(exports, arguments)
        }, { "../elliptic": 246, "./precomputed/secp256k1": 257, "dup": 206, "hash.js": 260 }], 253: [function (require, module, exports) {
            arguments[4][207][0].apply(exports, arguments)
        }, { "../../elliptic": 246, "./key": 254, "./signature": 255, "bn.js": 245, "dup": 207 }], 254: [function (require, module, exports) {
            arguments[4][208][0].apply(exports, arguments)
        }, { "../../elliptic": 246, "bn.js": 245, "dup": 208 }], 255: [function (require, module, exports) {
            arguments[4][209][0].apply(exports, arguments)
        }, { "../../elliptic": 246, "bn.js": 245, "dup": 209 }], 256: [function (require, module, exports) {
            arguments[4][210][0].apply(exports, arguments)
        }, { "../elliptic": 246, "dup": 210, "hash.js": 260 }], 257: [function (require, module, exports) {
            arguments[4][211][0].apply(exports, arguments)
        }, { "dup": 211 }], 258: [function (require, module, exports) {
            arguments[4][212][0].apply(exports, arguments)
        }, { "dup": 212 }], 259: [function (require, module, exports) {
            arguments[4][213][0].apply(exports, arguments)
        }, { "dup": 213 }], 260: [function (require, module, exports) {
            arguments[4][214][0].apply(exports, arguments)
        }, { "./hash/common": 261, "./hash/hmac": 262, "./hash/ripemd": 263, "./hash/sha": 264, "./hash/utils": 265, "dup": 214 }], 261: [function (require, module, exports) {
            arguments[4][215][0].apply(exports, arguments)
        }, { "../hash": 260, "dup": 215 }], 262: [function (require, module, exports) {
            arguments[4][216][0].apply(exports, arguments)
        }, { "../hash": 260, "dup": 216 }], 263: [function (require, module, exports) {
            arguments[4][217][0].apply(exports, arguments)
        }, { "../hash": 260, "dup": 217 }], 264: [function (require, module, exports) {
            arguments[4][218][0].apply(exports, arguments)
        }, { "../hash": 260, "dup": 218 }], 265: [function (require, module, exports) {
            arguments[4][219][0].apply(exports, arguments)
        }, { "dup": 219, "inherits": 318 }], 266: [function (require, module, exports) {
            arguments[4][220][0].apply(exports, arguments)
        }, { "dup": 220 }], 267: [function (require, module, exports) {
            (function (Buffer) {
                'use strict';
                var inherits = require('inherits')
                var md5 = require('./md5')
                var rmd160 = require('ripemd160')
                var sha = require('sha.js')
                
                var Transform = require('stream').Transform
                
                function HashNoConstructor(hash) {
                    Transform.call(this)
                    
                    this._hash = hash
                    this.buffers = []
                }
                
                inherits(HashNoConstructor, Transform)
                
                HashNoConstructor.prototype._transform = function (data, _, next) {
                    this.buffers.push(data)
                    
                    next()
                }
                
                HashNoConstructor.prototype._flush = function (next) {
                    this.push(this.digest())
                    next()
                }
                
                HashNoConstructor.prototype.update = function (data, enc) {
                    if (typeof data === 'string') {
                        data = new Buffer(data, enc)
                    }
                    
                    this.buffers.push(data)
                    return this
                }
                
                HashNoConstructor.prototype.digest = function (enc) {
                    var buf = Buffer.concat(this.buffers)
                    var r = this._hash(buf)
                    this.buffers = null
                    
                    return enc ? r.toString(enc) : r
                }
                
                function Hash(hash) {
                    Transform.call(this)
                    
                    this._hash = hash
                }
                
                inherits(Hash, Transform)
                
                Hash.prototype._transform = function (data, enc, next) {
                    if (enc) data = new Buffer(data, enc)
                    
                    this._hash.update(data)
                    
                    next()
                }
                
                Hash.prototype._flush = function (next) {
                    this.push(this._hash.digest())
                    this._hash = null
                    
                    next()
                }
                
                Hash.prototype.update = function (data, enc) {
                    if (typeof data === 'string') {
                        data = new Buffer(data, enc)
                    }
                    
                    this._hash.update(data)
                    return this
                }
                
                Hash.prototype.digest = function (enc) {
                    var outData = this._hash.digest()
                    
                    return enc ? outData.toString(enc) : outData
                }
                
                module.exports = function createHash(alg) {
                    if ('md5' === alg) return new HashNoConstructor(md5)
                    if ('rmd160' === alg) return new HashNoConstructor(rmd160)
                    
                    return new Hash(sha(alg))
                }

            }).call(this, require("buffer").Buffer)
        }, { "./md5": 269, "buffer": 172, "inherits": 318, "ripemd160": 270, "sha.js": 272, "stream": 338 }], 268: [function (require, module, exports) {
            (function (Buffer) {
                'use strict';
                var intSize = 4;
                var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
                var chrsz = 8;
                
                function toArray(buf, bigEndian) {
                    if ((buf.length % intSize) !== 0) {
                        var len = buf.length + (intSize - (buf.length % intSize));
                        buf = Buffer.concat([buf, zeroBuffer], len);
                    }
                    
                    var arr = [];
                    var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
                    for (var i = 0; i < buf.length; i += intSize) {
                        arr.push(fn.call(buf, i));
                    }
                    return arr;
                }
                
                function toBuffer(arr, size, bigEndian) {
                    var buf = new Buffer(size);
                    var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
                    for (var i = 0; i < arr.length; i++) {
                        fn.call(buf, arr[i], i * 4, true);
                    }
                    return buf;
                }
                
                function hash(buf, fn, hashSize, bigEndian) {
                    if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
                    var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
                    return toBuffer(arr, hashSize, bigEndian);
                }
                exports.hash = hash;
            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 269: [function (require, module, exports) {
            'use strict';
            /*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');
            
            /*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len) {
                /* append padding */
                x[len >> 5] |= 0x80 << ((len) % 32);
                x[(((len + 64) >>> 9) << 4) + 14] = len;
                
                var a = 1732584193;
                var b = -271733879;
                var c = -1732584194;
                var d = 271733878;
                
                for (var i = 0; i < x.length; i += 16) {
                    var olda = a;
                    var oldb = b;
                    var oldc = c;
                    var oldd = d;
                    
                    a = md5_ff(a, b, c, d, x[i + 0], 7 , -680876936);
                    d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
                    c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
                    b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
                    a = md5_ff(a, b, c, d, x[i + 4], 7 , -176418897);
                    d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
                    c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
                    b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
                    a = md5_ff(a, b, c, d, x[i + 8], 7 , 1770035416);
                    d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
                    c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
                    b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
                    a = md5_ff(a, b, c, d, x[i + 12], 7 , 1804603682);
                    d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
                    c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
                    b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
                    
                    a = md5_gg(a, b, c, d, x[i + 1], 5 , -165796510);
                    d = md5_gg(d, a, b, c, x[i + 6], 9 , -1069501632);
                    c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
                    b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
                    a = md5_gg(a, b, c, d, x[i + 5], 5 , -701558691);
                    d = md5_gg(d, a, b, c, x[i + 10], 9 , 38016083);
                    c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
                    b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
                    a = md5_gg(a, b, c, d, x[i + 9], 5 , 568446438);
                    d = md5_gg(d, a, b, c, x[i + 14], 9 , -1019803690);
                    c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
                    b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
                    a = md5_gg(a, b, c, d, x[i + 13], 5 , -1444681467);
                    d = md5_gg(d, a, b, c, x[i + 2], 9 , -51403784);
                    c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
                    b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
                    
                    a = md5_hh(a, b, c, d, x[i + 5], 4 , -378558);
                    d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
                    c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
                    b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
                    a = md5_hh(a, b, c, d, x[i + 1], 4 , -1530992060);
                    d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
                    c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
                    b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
                    a = md5_hh(a, b, c, d, x[i + 13], 4 , 681279174);
                    d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
                    c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
                    b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
                    a = md5_hh(a, b, c, d, x[i + 9], 4 , -640364487);
                    d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
                    c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
                    b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
                    
                    a = md5_ii(a, b, c, d, x[i + 0], 6 , -198630844);
                    d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
                    c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
                    b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
                    a = md5_ii(a, b, c, d, x[i + 12], 6 , 1700485571);
                    d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
                    c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
                    b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
                    a = md5_ii(a, b, c, d, x[i + 8], 6 , 1873313359);
                    d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
                    c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
                    b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
                    a = md5_ii(a, b, c, d, x[i + 4], 6 , -145523070);
                    d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
                    c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
                    b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
                    
                    a = safe_add(a, olda);
                    b = safe_add(b, oldb);
                    c = safe_add(c, oldc);
                    d = safe_add(d, oldd);
                }
                return Array(a, b, c, d);

            }
            
            /*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t) {
                return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
            }
            function md5_ff(a, b, c, d, x, s, t) {
                return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
            }
            function md5_gg(a, b, c, d, x, s, t) {
                return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
            }
            function md5_hh(a, b, c, d, x, s, t) {
                return md5_cmn(b ^ c ^ d, a, b, x, s, t);
            }
            function md5_ii(a, b, c, d, x, s, t) {
                return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
            }
            
            /*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y) {
                var lsw = (x & 0xFFFF) + (y & 0xFFFF);
                var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                return (msw << 16) | (lsw & 0xFFFF);
            }
            
            /*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt) {
                return (num << cnt) | (num >>> (32 - cnt));
            }
            
            module.exports = function md5(buf) {
                return helpers.hash(buf, core_md5, 16);
            };
        }, { "./helpers": 268 }], 270: [function (require, module, exports) {
            (function (Buffer) {
                /*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by CÃ©dric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// constants table
var zl = [
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
                    3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
                    1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
                    4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
                ]
                
                var zr = [
                    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
                    6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
                    15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
                    8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
                    12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
                ]
                
                var sl = [
                    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
                    7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
                    11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
                    11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
                    9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
                ]
                
                var sr = [
                    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
                    9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
                    9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
                    15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
                    8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
                ]
                
                var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
                var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]
                
                function bytesToWords(bytes) {
                    var words = []
                    for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
                        words[b >>> 5] |= bytes[i] << (24 - b % 32)
                    }
                    return words
                }
                
                function wordsToBytes(words) {
                    var bytes = []
                    for (var b = 0; b < words.length * 32; b += 8) {
                        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
                    }
                    return bytes
                }
                
                function processBlock(H, M, offset) {
                    // swap endian
                    for (var i = 0; i < 16; i++) {
                        var offset_i = offset + i
                        var M_offset_i = M[offset_i]
                        
                        // Swap
                        M[offset_i] = (
      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
)
                    }
                    
                    // Working variables
                    var al, bl, cl, dl, el
                    var ar, br, cr, dr, er
                    
                    ar = al = H[0]
                    br = bl = H[1]
                    cr = cl = H[2]
                    dr = dl = H[3]
                    er = el = H[4]
                    
                    // computation
                    var t
                    for (i = 0; i < 80; i += 1) {
                        t = (al + M[offset + zl[i]]) | 0
                        if (i < 16) {
                            t += f1(bl, cl, dl) + hl[0]
                        } else if (i < 32) {
                            t += f2(bl, cl, dl) + hl[1]
                        } else if (i < 48) {
                            t += f3(bl, cl, dl) + hl[2]
                        } else if (i < 64) {
                            t += f4(bl, cl, dl) + hl[3]
                        } else {// if (i<80) {
                            t += f5(bl, cl, dl) + hl[4]
                        }
                        t = t | 0
                        t = rotl(t, sl[i])
                        t = (t + el) | 0
                        al = el
                        el = dl
                        dl = rotl(cl, 10)
                        cl = bl
                        bl = t
                        
                        t = (ar + M[offset + zr[i]]) | 0
                        if (i < 16) {
                            t += f5(br, cr, dr) + hr[0]
                        } else if (i < 32) {
                            t += f4(br, cr, dr) + hr[1]
                        } else if (i < 48) {
                            t += f3(br, cr, dr) + hr[2]
                        } else if (i < 64) {
                            t += f2(br, cr, dr) + hr[3]
                        } else {// if (i<80) {
                            t += f1(br, cr, dr) + hr[4]
                        }
                        
                        t = t | 0
                        t = rotl(t, sr[i])
                        t = (t + er) | 0
                        ar = er
                        er = dr
                        dr = rotl(cr, 10)
                        cr = br
                        br = t
                    }
                    
                    // intermediate hash value
                    t = (H[1] + cl + dr) | 0
                    H[1] = (H[2] + dl + er) | 0
                    H[2] = (H[3] + el + ar) | 0
                    H[3] = (H[4] + al + br) | 0
                    H[4] = (H[0] + bl + cr) | 0
                    H[0] = t
                }
                
                function f1(x, y, z) {
                    return ((x) ^ (y) ^ (z))
                }
                
                function f2(x, y, z) {
                    return (((x) & (y)) | ((~x) & (z)))
                }
                
                function f3(x, y, z) {
                    return (((x) | (~(y))) ^ (z))
                }
                
                function f4(x, y, z) {
                    return (((x) & (z)) | ((y) & (~(z))))
                }
                
                function f5(x, y, z) {
                    return ((x) ^ ((y) | (~(z))))
                }
                
                function rotl(x, n) {
                    return (x << n) | (x >>> (32 - n))
                }
                
                function ripemd160(message) {
                    var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]
                    
                    if (typeof message === 'string') {
                        message = new Buffer(message, 'utf8')
                    }
                    
                    var m = bytesToWords(message)
                    
                    var nBitsLeft = message.length * 8
                    var nBitsTotal = message.length * 8
                    
                    // Add padding
                    m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
                    m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
)
                    
                    for (var i = 0; i < m.length; i += 16) {
                        processBlock(H, m, i)
                    }
                    
                    // swap endian
                    for (i = 0; i < 5; i++) {
                        // shortcut
                        var H_i = H[i]
                        
                        // Swap
                        H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)
                    }
                    
                    var digestbytes = wordsToBytes(H)
                    return new Buffer(digestbytes)
                }
                
                module.exports = ripemd160

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 271: [function (require, module, exports) {
            (function (Buffer) {
                // prototype class for hash functions
                function Hash(blockSize, finalSize) {
                    this._block = new Buffer(blockSize)
                    this._finalSize = finalSize
                    this._blockSize = blockSize
                    this._len = 0
                    this._s = 0
                }
                
                Hash.prototype.update = function (data, enc) {
                    if (typeof data === 'string') {
                        enc = enc || 'utf8'
                        data = new Buffer(data, enc)
                    }
                    
                    var l = this._len += data.length
                    var s = this._s || 0
                    var f = 0
                    var buffer = this._block
                    
                    while (s < l) {
                        var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
                        var ch = (t - f)
                        
                        for (var i = 0; i < ch; i++) {
                            buffer[(s % this._blockSize) + i] = data[i + f]
                        }
                        
                        s += ch
                        f += ch
                        
                        if ((s % this._blockSize) === 0) {
                            this._update(buffer)
                        }
                    }
                    this._s = s
                    
                    return this
                }
                
                Hash.prototype.digest = function (enc) {
                    // Suppose the length of the message M, in bits, is l
                    var l = this._len * 8
                    
                    // Append the bit 1 to the end of the message
                    this._block[this._len % this._blockSize] = 0x80
                    
                    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
                    this._block.fill(0, this._len % this._blockSize + 1)
                    
                    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
                        this._update(this._block)
                        this._block.fill(0)
                    }
                    
                    // to this append the block which is equal to the number l written in binary
                    // TODO: handle case where l is > Math.pow(2, 29)
                    this._block.writeInt32BE(l, this._blockSize - 4)
                    
                    var hash = this._update(this._block) || this._hash()
                    
                    return enc ? hash.toString(enc) : hash
                }
                
                Hash.prototype._update = function () {
                    throw new Error('_update must be implemented by subclass')
                }
                
                module.exports = Hash

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172 }], 272: [function (require, module, exports) {
            var exports = module.exports = function SHA(algorithm) {
                algorithm = algorithm.toLowerCase()
                
                var Algorithm = exports[algorithm]
                if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')
                
                return new Algorithm()
            }
            
            exports.sha = require('./sha')
            exports.sha1 = require('./sha1')
            exports.sha224 = require('./sha224')
            exports.sha256 = require('./sha256')
            exports.sha384 = require('./sha384')
            exports.sha512 = require('./sha512')

        }, { "./sha": 273, "./sha1": 274, "./sha224": 275, "./sha256": 276, "./sha384": 277, "./sha512": 278 }], 273: [function (require, module, exports) {
            (function (Buffer) {
                /*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
                var Hash = require('./hash')
                
                var W = new Array(80)
                
                function Sha() {
                    this.init()
                    this._w = W
                    
                    Hash.call(this, 64, 56)
                }
                
                inherits(Sha, Hash)
                
                Sha.prototype.init = function () {
                    this._a = 0x67452301 | 0
                    this._b = 0xefcdab89 | 0
                    this._c = 0x98badcfe | 0
                    this._d = 0x10325476 | 0
                    this._e = 0xc3d2e1f0 | 0
                    
                    return this
                }
                
                /*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt) {
                    return (num << cnt) | (num >>> (32 - cnt))
                }
                
                Sha.prototype._update = function (M) {
                    var W = this._w
                    
                    var a = this._a
                    var b = this._b
                    var c = this._c
                    var d = this._d
                    var e = this._e
                    
                    var j = 0, k
                    
                    /*
   * SHA-1 has a bitwise rotate left operation. But, SHA is not
   * function calcW() { return rol(W[j - 3] ^ W[j -  8] ^ W[j - 14] ^ W[j - 16], 1) }
   */
  function calcW() { return W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16] }
                    function loop(w, f) {
                        W[j] = w
                        
                        var t = rol(a, 5) + f + e + w + k
                        
                        e = d
                        d = c
                        c = rol(b, 30)
                        b = a
                        a = t
                        j++
                    }
                    
                    k = 1518500249
                    while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))
                    while (j < 20) loop(calcW(), (b & c) | ((~b) & d))
                    k = 1859775393
                    while (j < 40) loop(calcW(), b ^ c ^ d)
                    k = -1894007588
                    while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))
                    k = -899497514
                    while (j < 80) loop(calcW(), b ^ c ^ d)
                    
                    this._a = (a + this._a) | 0
                    this._b = (b + this._b) | 0
                    this._c = (c + this._c) | 0
                    this._d = (d + this._d) | 0
                    this._e = (e + this._e) | 0
                }
                
                Sha.prototype._hash = function () {
                    var H = new Buffer(20)
                    
                    H.writeInt32BE(this._a | 0, 0)
                    H.writeInt32BE(this._b | 0, 4)
                    H.writeInt32BE(this._c | 0, 8)
                    H.writeInt32BE(this._d | 0, 12)
                    H.writeInt32BE(this._e | 0, 16)
                    
                    return H
                }
                
                module.exports = Sha


            }).call(this, require("buffer").Buffer)
        }, { "./hash": 271, "buffer": 172, "inherits": 318 }], 274: [function (require, module, exports) {
            (function (Buffer) {
                /*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
                var Hash = require('./hash')
                
                var W = new Array(80)
                
                function Sha1() {
                    this.init()
                    this._w = W
                    
                    Hash.call(this, 64, 56)
                }
                
                inherits(Sha1, Hash)
                
                Sha1.prototype.init = function () {
                    this._a = 0x67452301 | 0
                    this._b = 0xefcdab89 | 0
                    this._c = 0x98badcfe | 0
                    this._d = 0x10325476 | 0
                    this._e = 0xc3d2e1f0 | 0
                    
                    return this
                }
                
                /*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt) {
                    return (num << cnt) | (num >>> (32 - cnt))
                }
                
                Sha1.prototype._update = function (M) {
                    var W = this._w
                    
                    var a = this._a
                    var b = this._b
                    var c = this._c
                    var d = this._d
                    var e = this._e
                    
                    var j = 0, k
                    
                    function calcW() { return rol(W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16], 1) }
                    function loop(w, f) {
                        W[j] = w
                        
                        var t = rol(a, 5) + f + e + w + k
                        
                        e = d
                        d = c
                        c = rol(b, 30)
                        b = a
                        a = t
                        j++
                    }
                    
                    k = 1518500249
                    while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))
                    while (j < 20) loop(calcW(), (b & c) | ((~b) & d))
                    k = 1859775393
                    while (j < 40) loop(calcW(), b ^ c ^ d)
                    k = -1894007588
                    while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))
                    k = -899497514
                    while (j < 80) loop(calcW(), b ^ c ^ d)
                    
                    this._a = (a + this._a) | 0
                    this._b = (b + this._b) | 0
                    this._c = (c + this._c) | 0
                    this._d = (d + this._d) | 0
                    this._e = (e + this._e) | 0
                }
                
                Sha1.prototype._hash = function () {
                    var H = new Buffer(20)
                    
                    H.writeInt32BE(this._a | 0, 0)
                    H.writeInt32BE(this._b | 0, 4)
                    H.writeInt32BE(this._c | 0, 8)
                    H.writeInt32BE(this._d | 0, 12)
                    H.writeInt32BE(this._e | 0, 16)
                    
                    return H
                }
                
                module.exports = Sha1

            }).call(this, require("buffer").Buffer)
        }, { "./hash": 271, "buffer": 172, "inherits": 318 }], 275: [function (require, module, exports) {
            (function (Buffer) {
                /**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
                var Sha256 = require('./sha256')
                var Hash = require('./hash')
                
                var W = new Array(64)
                
                function Sha224() {
                    this.init()
                    
                    this._w = W // new Array(64)
                    
                    Hash.call(this, 64, 56)
                }
                
                inherits(Sha224, Sha256)
                
                Sha224.prototype.init = function () {
                    this._a = 0xc1059ed8 | 0
                    this._b = 0x367cd507 | 0
                    this._c = 0x3070dd17 | 0
                    this._d = 0xf70e5939 | 0
                    this._e = 0xffc00b31 | 0
                    this._f = 0x68581511 | 0
                    this._g = 0x64f98fa7 | 0
                    this._h = 0xbefa4fa4 | 0
                    
                    return this
                }
                
                Sha224.prototype._hash = function () {
                    var H = new Buffer(28)
                    
                    H.writeInt32BE(this._a, 0)
                    H.writeInt32BE(this._b, 4)
                    H.writeInt32BE(this._c, 8)
                    H.writeInt32BE(this._d, 12)
                    H.writeInt32BE(this._e, 16)
                    H.writeInt32BE(this._f, 20)
                    H.writeInt32BE(this._g, 24)
                    
                    return H
                }
                
                module.exports = Sha224

            }).call(this, require("buffer").Buffer)
        }, { "./hash": 271, "./sha256": 276, "buffer": 172, "inherits": 318 }], 276: [function (require, module, exports) {
            (function (Buffer) {
                /**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
                var Hash = require('./hash')
                
                var K = [
                    0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
                    0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
                    0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
                    0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
                    0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
                    0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
                    0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
                    0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
                    0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
                    0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
                    0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
                    0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
                    0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
                    0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
                    0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
                    0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
                ]
                
                var W = new Array(64)
                
                function Sha256() {
                    this.init()
                    
                    this._w = W // new Array(64)
                    
                    Hash.call(this, 64, 56)
                }
                
                inherits(Sha256, Hash)
                
                Sha256.prototype.init = function () {
                    this._a = 0x6a09e667 | 0
                    this._b = 0xbb67ae85 | 0
                    this._c = 0x3c6ef372 | 0
                    this._d = 0xa54ff53a | 0
                    this._e = 0x510e527f | 0
                    this._f = 0x9b05688c | 0
                    this._g = 0x1f83d9ab | 0
                    this._h = 0x5be0cd19 | 0
                    
                    return this
                }
                
                function S(X, n) {
                    return (X >>> n) | (X << (32 - n))
                }
                
                function R(X, n) {
                    return (X >>> n)
                }
                
                function Ch(x, y, z) {
                    return ((x & y) ^ ((~x) & z))
                }
                
                function Maj(x, y, z) {
                    return ((x & y) ^ (x & z) ^ (y & z))
                }
                
                function Sigma0256(x) {
                    return (S(x, 2) ^ S(x, 13) ^ S(x, 22))
                }
                
                function Sigma1256(x) {
                    return (S(x, 6) ^ S(x, 11) ^ S(x, 25))
                }
                
                function Gamma0256(x) {
                    return (S(x, 7) ^ S(x, 18) ^ R(x, 3))
                }
                
                function Gamma1256(x) {
                    return (S(x, 17) ^ S(x, 19) ^ R(x, 10))
                }
                
                Sha256.prototype._update = function (M) {
                    var W = this._w
                    
                    var a = this._a | 0
                    var b = this._b | 0
                    var c = this._c | 0
                    var d = this._d | 0
                    var e = this._e | 0
                    var f = this._f | 0
                    var g = this._g | 0
                    var h = this._h | 0
                    
                    var j = 0
                    
                    function calcW() { return Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16] }
                    function loop(w) {
                        W[j] = w
                        
                        var T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
                        var T2 = Sigma0256(a) + Maj(a, b, c)
                        
                        h = g
                        g = f
                        f = e
                        e = d + T1
                        d = c
                        c = b
                        b = a
                        a = T1 + T2
                        
                        j++
                    }
                    
                    while (j < 16) loop(M.readInt32BE(j * 4))
                    while (j < 64) loop(calcW())
                    
                    this._a = (a + this._a) | 0
                    this._b = (b + this._b) | 0
                    this._c = (c + this._c) | 0
                    this._d = (d + this._d) | 0
                    this._e = (e + this._e) | 0
                    this._f = (f + this._f) | 0
                    this._g = (g + this._g) | 0
                    this._h = (h + this._h) | 0
                }
                
                Sha256.prototype._hash = function () {
                    var H = new Buffer(32)
                    
                    H.writeInt32BE(this._a, 0)
                    H.writeInt32BE(this._b, 4)
                    H.writeInt32BE(this._c, 8)
                    H.writeInt32BE(this._d, 12)
                    H.writeInt32BE(this._e, 16)
                    H.writeInt32BE(this._f, 20)
                    H.writeInt32BE(this._g, 24)
                    H.writeInt32BE(this._h, 28)
                    
                    return H
                }
                
                module.exports = Sha256

            }).call(this, require("buffer").Buffer)
        }, { "./hash": 271, "buffer": 172, "inherits": 318 }], 277: [function (require, module, exports) {
            (function (Buffer) {
                var inherits = require('inherits')
                var SHA512 = require('./sha512')
                var Hash = require('./hash')
                
                var W = new Array(160)
                
                function Sha384() {
                    this.init()
                    this._w = W
                    
                    Hash.call(this, 128, 112)
                }
                
                inherits(Sha384, SHA512)
                
                Sha384.prototype.init = function () {
                    this._a = 0xcbbb9d5d | 0
                    this._b = 0x629a292a | 0
                    this._c = 0x9159015a | 0
                    this._d = 0x152fecd8 | 0
                    this._e = 0x67332667 | 0
                    this._f = 0x8eb44a87 | 0
                    this._g = 0xdb0c2e0d | 0
                    this._h = 0x47b5481d | 0
                    
                    this._al = 0xc1059ed8 | 0
                    this._bl = 0x367cd507 | 0
                    this._cl = 0x3070dd17 | 0
                    this._dl = 0xf70e5939 | 0
                    this._el = 0xffc00b31 | 0
                    this._fl = 0x68581511 | 0
                    this._gl = 0x64f98fa7 | 0
                    this._hl = 0xbefa4fa4 | 0
                    
                    return this
                }
                
                Sha384.prototype._hash = function () {
                    var H = new Buffer(48)
                    
                    function writeInt64BE(h, l, offset) {
                        H.writeInt32BE(h, offset)
                        H.writeInt32BE(l, offset + 4)
                    }
                    
                    writeInt64BE(this._a, this._al, 0)
                    writeInt64BE(this._b, this._bl, 8)
                    writeInt64BE(this._c, this._cl, 16)
                    writeInt64BE(this._d, this._dl, 24)
                    writeInt64BE(this._e, this._el, 32)
                    writeInt64BE(this._f, this._fl, 40)
                    
                    return H
                }
                
                module.exports = Sha384

            }).call(this, require("buffer").Buffer)
        }, { "./hash": 271, "./sha512": 278, "buffer": 172, "inherits": 318 }], 278: [function (require, module, exports) {
            (function (Buffer) {
                var inherits = require('inherits')
                var Hash = require('./hash')
                
                var K = [
                    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
                    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
                    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
                    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
                    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
                    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
                    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
                    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
                    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
                    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
                    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
                    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
                    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
                    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
                    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
                    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
                    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
                    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
                    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
                    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
                    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
                    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
                    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
                    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
                    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
                    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
                    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
                    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
                    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
                    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
                    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
                    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
                    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
                    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
                    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
                    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
                    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
                    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
                    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
                    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
                ]
                
                var W = new Array(160)
                
                function Sha512() {
                    this.init()
                    this._w = W
                    
                    Hash.call(this, 128, 112)
                }
                
                inherits(Sha512, Hash)
                
                Sha512.prototype.init = function () {
                    this._a = 0x6a09e667 | 0
                    this._b = 0xbb67ae85 | 0
                    this._c = 0x3c6ef372 | 0
                    this._d = 0xa54ff53a | 0
                    this._e = 0x510e527f | 0
                    this._f = 0x9b05688c | 0
                    this._g = 0x1f83d9ab | 0
                    this._h = 0x5be0cd19 | 0
                    
                    this._al = 0xf3bcc908 | 0
                    this._bl = 0x84caa73b | 0
                    this._cl = 0xfe94f82b | 0
                    this._dl = 0x5f1d36f1 | 0
                    this._el = 0xade682d1 | 0
                    this._fl = 0x2b3e6c1f | 0
                    this._gl = 0xfb41bd6b | 0
                    this._hl = 0x137e2179 | 0
                    
                    return this
                }
                
                function S(X, Xl, n) {
                    return (X >>> n) | (Xl << (32 - n))
                }
                
                function Ch(x, y, z) {
                    return ((x & y) ^ ((~x) & z))
                }
                
                function Maj(x, y, z) {
                    return ((x & y) ^ (x & z) ^ (y & z))
                }
                
                Sha512.prototype._update = function (M) {
                    var W = this._w
                    
                    var a = this._a | 0
                    var b = this._b | 0
                    var c = this._c | 0
                    var d = this._d | 0
                    var e = this._e | 0
                    var f = this._f | 0
                    var g = this._g | 0
                    var h = this._h | 0
                    
                    var al = this._al | 0
                    var bl = this._bl | 0
                    var cl = this._cl | 0
                    var dl = this._dl | 0
                    var el = this._el | 0
                    var fl = this._fl | 0
                    var gl = this._gl | 0
                    var hl = this._hl | 0
                    
                    var i = 0, j = 0
                    var Wi, Wil
                    function calcW() {
                        var x = W[j - 15 * 2]
                        var xl = W[j - 15 * 2 + 1]
                        var gamma0 = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
                        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)
                        
                        x = W[j - 2 * 2]
                        xl = W[j - 2 * 2 + 1]
                        var gamma1 = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
                        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)
                        
                        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                        var Wi7 = W[j - 7 * 2]
                        var Wi7l = W[j - 7 * 2 + 1]
                        
                        var Wi16 = W[j - 16 * 2]
                        var Wi16l = W[j - 16 * 2 + 1]
                        
                        Wil = gamma0l + Wi7l
                        Wi = gamma0 + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
                        Wil = Wil + gamma1l
                        Wi = Wi + gamma1 + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
                        Wil = Wil + Wi16l
                        Wi = Wi + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
                    }
                    
                    function loop() {
                        W[j] = Wi
                        W[j + 1] = Wil
                        
                        var maj = Maj(a, b, c)
                        var majl = Maj(al, bl, cl)
                        
                        var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
                        var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
                        var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
                        var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)
                        
                        // t1 = h + sigma1 + ch + K[i] + W[i]
                        var Ki = K[j]
                        var Kil = K[j + 1]
                        
                        var ch = Ch(e, f, g)
                        var chl = Ch(el, fl, gl)
                        
                        var t1l = hl + sigma1l
                        var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
                        t1l = t1l + chl
                        t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
                        t1l = t1l + Kil
                        t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
                        t1l = t1l + Wil
                        t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)
                        
                        // t2 = sigma0 + maj
                        var t2l = sigma0l + majl
                        var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)
                        
                        h = g
                        hl = gl
                        g = f
                        gl = fl
                        f = e
                        fl = el
                        el = (dl + t1l) | 0
                        e = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
                        d = c
                        dl = cl
                        c = b
                        cl = bl
                        b = a
                        bl = al
                        al = (t1l + t2l) | 0
                        a = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
                        
                        i++
                        j += 2
                    }
                    
                    while (i < 16) {
                        Wi = M.readInt32BE(j * 4)
                        Wil = M.readInt32BE(j * 4 + 4)
                        
                        loop()
                    }
                    
                    while (i < 80) {
                        calcW()
                        loop()
                    }
                    
                    this._al = (this._al + al) | 0
                    this._bl = (this._bl + bl) | 0
                    this._cl = (this._cl + cl) | 0
                    this._dl = (this._dl + dl) | 0
                    this._el = (this._el + el) | 0
                    this._fl = (this._fl + fl) | 0
                    this._gl = (this._gl + gl) | 0
                    this._hl = (this._hl + hl) | 0
                    
                    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
                    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
                    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
                    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
                    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
                    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
                    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
                    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
                }
                
                Sha512.prototype._hash = function () {
                    var H = new Buffer(64)
                    
                    function writeInt64BE(h, l, offset) {
                        H.writeInt32BE(h, offset)
                        H.writeInt32BE(l, offset + 4)
                    }
                    
                    writeInt64BE(this._a, this._al, 0)
                    writeInt64BE(this._b, this._bl, 8)
                    writeInt64BE(this._c, this._cl, 16)
                    writeInt64BE(this._d, this._dl, 24)
                    writeInt64BE(this._e, this._el, 32)
                    writeInt64BE(this._f, this._fl, 40)
                    writeInt64BE(this._g, this._gl, 48)
                    writeInt64BE(this._h, this._hl, 56)
                    
                    return H
                }
                
                module.exports = Sha512

            }).call(this, require("buffer").Buffer)
        }, { "./hash": 271, "buffer": 172, "inherits": 318 }], 279: [function (require, module, exports) {
            (function (Buffer) {
                'use strict';
                var createHash = require('create-hash/browser');
                var inherits = require('inherits')
                
                var Transform = require('stream').Transform
                
                var ZEROS = new Buffer(128)
                ZEROS.fill(0)
                
                function Hmac(alg, key) {
                    Transform.call(this)
                    
                    if (typeof key === 'string') {
                        key = new Buffer(key)
                    }
                    
                    var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64
                    
                    this._alg = alg
                    this._key = key
                    
                    if (key.length > blocksize) {
                        key = createHash(alg).update(key).digest()

                    } else if (key.length < blocksize) {
                        key = Buffer.concat([key, ZEROS], blocksize)
                    }
                    
                    var ipad = this._ipad = new Buffer(blocksize)
                    var opad = this._opad = new Buffer(blocksize)
                    
                    for (var i = 0; i < blocksize; i++) {
                        ipad[i] = key[i] ^ 0x36
                        opad[i] = key[i] ^ 0x5C
                    }
                    
                    this._hash = createHash(alg).update(ipad)
                }
                
                inherits(Hmac, Transform)
                
                Hmac.prototype.update = function (data, enc) {
                    this._hash.update(data, enc)
                    
                    return this
                }
                
                Hmac.prototype._transform = function (data, _, next) {
                    this._hash.update(data)
                    
                    next()
                }
                
                Hmac.prototype._flush = function (next) {
                    this.push(this.digest())
                    
                    next()
                }
                
                Hmac.prototype.digest = function (enc) {
                    var h = this._hash.digest()
                    
                    return createHash(this._alg).update(this._opad).update(h).digest(enc)
                }
                
                module.exports = function createHmac(alg, key) {
                    return new Hmac(alg, key)
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172, "create-hash/browser": 267, "inherits": 318, "stream": 338 }], 280: [function (require, module, exports) {
            (function (Buffer) {
                var generatePrime = require('./lib/generatePrime');
                var primes = require('./lib/primes');
                
                var DH = require('./lib/dh');
                
                function getDiffieHellman(mod) {
                    var prime = new Buffer(primes[mod].prime, 'hex');
                    var gen = new Buffer(primes[mod].gen, 'hex');
                    
                    return new DH(prime, gen);
                }
                
                function createDiffieHellman(prime, enc, generator, genc) {
                    if (Buffer.isBuffer(enc) || (typeof enc === 'string' && ['hex', 'binary', 'base64'].indexOf(enc) === -1)) {
                        genc = generator;
                        generator = enc;
                        enc = undefined;
                    }
                    
                    enc = enc || 'binary';
                    genc = genc || 'binary';
                    generator = generator || new Buffer([2]);
                    
                    if (!Buffer.isBuffer(generator)) {
                        generator = new Buffer(generator, genc);
                    }
                    
                    if (typeof prime === 'number') {
                        return new DH(generatePrime(prime, generator), generator, true);
                    }
                    
                    if (!Buffer.isBuffer(prime)) {
                        prime = new Buffer(prime, enc);
                    }
                    
                    return new DH(prime, generator, true);
                }
                
                exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
                exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;

            }).call(this, require("buffer").Buffer)
        }, { "./lib/dh": 281, "./lib/generatePrime": 282, "./lib/primes": 283, "buffer": 172 }], 281: [function (require, module, exports) {
            (function (Buffer) {
                var BN = require('bn.js');
                var MillerRabin = require('miller-rabin');
                var millerRabin = new MillerRabin();
                var TWENTYFOUR = new BN(24);
                var ELEVEN = new BN(11);
                var TEN = new BN(10);
                var THREE = new BN(3);
                var SEVEN = new BN(7);
                var primes = require('./generatePrime');
                var randomBytes = require('randombytes');
                module.exports = DH;
                
                function setPublicKey(pub, enc) {
                    enc = enc || 'utf8';
                    if (!Buffer.isBuffer(pub)) {
                        pub = new Buffer(pub, enc);
                    }
                    this._pub = new BN(pub);
                    return this;
                }
                
                function setPrivateKey(priv, enc) {
                    enc = enc || 'utf8';
                    if (!Buffer.isBuffer(priv)) {
                        priv = new Buffer(priv, enc);
                    }
                    this._priv = new BN(priv);
                    return this;
                }
                
                var primeCache = {};
                function checkPrime(prime, generator) {
                    var gen = generator.toString('hex');
                    var hex = [gen, prime.toString(16)].join('_');
                    if (hex in primeCache) {
                        return primeCache[hex];
                    }
                    var error = 0;
                    
                    if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
                        //not a prime so +1
                        error += 1;
                        
                        if (gen === '02' || gen === '05') {
                            // we'd be able to check the generator
                            // it would fail so +8
                            error += 8;
                        } else {
                            //we wouldn't be able to test the generator
                            // so +4
                            error += 4;
                        }
                        primeCache[hex] = error;
                        return error;
                    }
                    if (!millerRabin.test(prime.shrn(1))) {
                        //not a safe prime
                        error += 2;
                    }
                    var rem;
                    switch (gen) {
                        case '02':
                            if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
                                // unsuidable generator
                                error += 8;
                            }
                            break;
                        case '05':
                            rem = prime.mod(TEN);
                            if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
                                // prime mod 10 needs to equal 3 or 7
                                error += 8;
                            }
                            break;
                        default:
                            error += 4;
                    }
                    primeCache[hex] = error;
                    return error;
                }
                
                function defineError(self, error) {
                    try {
                        Object.defineProperty(self, 'verifyError', {
                            enumerable: true,
                            value: error,
                            writable: false
                        });
                    } catch (e) {
                        self.verifyError = error;
                    }
                }
                function DH(prime, generator, malleable) {
                    this.setGenerator(generator);
                    this.__prime = new BN(prime);
                    this._prime = BN.mont(this.__prime);
                    this._primeLen = prime.length;
                    this._pub = void 0;
                    this._priv = void 0;
                    
                    if (malleable) {
                        this.setPublicKey = setPublicKey;
                        this.setPrivateKey = setPrivateKey;
                        defineError(this, checkPrime(this.__prime, generator));
                    } else {
                        defineError(this, 8);
                    }
                }
                
                DH.prototype.generateKeys = function () {
                    if (!this._priv) {
                        this._priv = new BN(randomBytes(this._primeLen));
                    }
                    this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
                    return this.getPublicKey();
                };
                
                DH.prototype.computeSecret = function (other) {
                    other = new BN(other);
                    other = other.toRed(this._prime);
                    var secret = other.redPow(this._priv).fromRed();
                    var out = new Buffer(secret.toArray());
                    var prime = this.getPrime();
                    if (out.length < prime.length) {
                        var front = new Buffer(prime.length - out.length);
                        front.fill(0);
                        out = Buffer.concat([front, out]);
                    }
                    return out;
                };
                
                DH.prototype.getPublicKey = function getPublicKey(enc) {
                    return formatReturnValue(this._pub, enc);
                };
                
                DH.prototype.getPrivateKey = function getPrivateKey(enc) {
                    return formatReturnValue(this._priv, enc);
                };
                
                DH.prototype.getPrime = function (enc) {
                    return formatReturnValue(this.__prime, enc);
                };
                
                DH.prototype.getGenerator = function (enc) {
                    return formatReturnValue(this._gen, enc);
                };
                
                DH.prototype.setGenerator = function (gen, enc) {
                    enc = enc || 'utf8';
                    if (!Buffer.isBuffer(gen)) {
                        gen = new Buffer(gen, enc);
                    }
                    this._gen = new BN(gen);
                    return this;
                };
                
                function formatReturnValue(bn, enc) {
                    var buf = new Buffer(bn.toArray());
                    if (!enc) {
                        return buf;
                    } else {
                        return buf.toString(enc);
                    }
                }
            }).call(this, require("buffer").Buffer)
        }, { "./generatePrime": 282, "bn.js": 284, "buffer": 172, "miller-rabin": 285, "randombytes": 316 }], 282: [function (require, module, exports) {
            var randomBytes = require('randombytes');
            module.exports = findPrime;
            findPrime.simpleSieve = simpleSieve;
            findPrime.fermatTest = fermatTest;
            var BN = require('bn.js');
            var TWENTYFOUR = new BN(24);
            var MillerRabin = require('miller-rabin');
            var millerRabin = new MillerRabin();
            var ONE = new BN(1);
            var TWO = new BN(2);
            var FIVE = new BN(5);
            var SIXTEEN = new BN(16);
            var EIGHT = new BN(8);
            var TEN = new BN(10);
            var THREE = new BN(3);
            var SEVEN = new BN(7);
            var ELEVEN = new BN(11);
            var FOUR = new BN(4);
            var TWELVE = new BN(12);
            var primes = null;
            
            function _getPrimes() {
                if (primes !== null)
                    return primes;
                
                var limit = 0x100000;
                var res = [];
                res[0] = 2;
                for (var i = 1, k = 3; k < limit; k += 2) {
                    var sqrt = Math.ceil(Math.sqrt(k));
                    for (var j = 0; j < i && res[j] <= sqrt; j++)
                        if (k % res[j] === 0)
                            break;
                    
                    if (i !== j && res[j] <= sqrt)
                        continue;
                    
                    res[i++] = k;
                }
                primes = res;
                return res;
            }
            
            function simpleSieve(p) {
                var primes = _getPrimes();
                
                for (var i = 0; i < primes.length; i++)
                    if (p.modn(primes[i]) === 0) {
                        if (p.cmpn(primes[i]) === 0) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                
                return true;
            }
            
            function fermatTest(p) {
                var red = BN.mont(p);
                return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
            }
            
            function findPrime(bits, gen) {
                if (bits < 16) {
                    // this is what openssl does
                    if (gen === 2 || gen === 5) {
                        return new BN([0x8c, 0x7b]);
                    } else {
                        return new BN([0x8c, 0x27]);
                    }
                }
                gen = new BN(gen);
                var runs, comp;
                function generateRandom(bits) {
                    runs = -1;
                    var out = new BN(randomBytes(Math.ceil(bits / 8)));
                    while (out.bitLength() > bits) {
                        out.ishrn(1);
                    }
                    if (out.isEven()) {
                        out.iadd(ONE);
                    }
                    if (!out.testn(1)) {
                        out.iadd(TWO);
                    }
                    if (!gen.cmp(TWO)) {
                        while (out.mod(TWENTYFOUR).cmp(ELEVEN)) {
                            out.iadd(FOUR);
                        }
                        comp = {
                            major: [TWENTYFOUR],
                            minor: [TWELVE]
                        };
                    } else if (!gen.cmp(FIVE)) {
                        rem = out.mod(TEN);
                        while (rem.cmp(THREE)) {
                            out.iadd(FOUR);
                            rem = out.mod(TEN);
                        }
                        comp = {
                            major: [FOUR, SIXTEEN],
                            minor: [TWO, EIGHT]
                        };
                    } else {
                        comp = {
                            major: [FOUR],
                            minor: [TWO]
                        };
                    }
                    return out;
                }
                var num = generateRandom(bits);
                
                var n2 = num.shrn(1);
                
                while (true) {
                    while (num.bitLength() > bits) {
                        num = generateRandom(bits);
                        n2 = num.shrn(1);
                    }
                    runs++;
                    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
                        return num;
                    }
                    num.iadd(comp.major[runs % comp.major.length]);
                    n2.iadd(comp.minor[runs % comp.minor.length]);
                }

            }
        }, { "bn.js": 284, "miller-rabin": 285, "randombytes": 316 }], 283: [function (require, module, exports) {
            module.exports = {
                "modp1": {
                    "gen": "02",
                    "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
                },
                "modp2": {
                    "gen": "02",
                    "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
                },
                "modp5": {
                    "gen": "02",
                    "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
                },
                "modp14": {
                    "gen": "02",
                    "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
                },
                "modp15": {
                    "gen": "02",
                    "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
                },
                "modp16": {
                    "gen": "02",
                    "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
                },
                "modp17": {
                    "gen": "02",
                    "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
                },
                "modp18": {
                    "gen": "02",
                    "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
                }
            }
        }, {}], 284: [function (require, module, exports) {
            arguments[4][198][0].apply(exports, arguments)
        }, { "dup": 198 }], 285: [function (require, module, exports) {
            var bn = require('bn.js');
            var brorand = require('brorand');
            
            function MillerRabin(rand) {
                this.rand = rand || new brorand.Rand();
            }
            module.exports = MillerRabin;
            
            MillerRabin.create = function create(rand) {
                return new MillerRabin(rand);
            };
            
            MillerRabin.prototype._rand = function _rand(n) {
                var len = n.bitLength();
                var buf = this.rand.generate(Math.ceil(len / 8));
                
                // Set low bits
                buf[0] |= 3;
                
                // Mask high bits
                var mask = len & 0x7;
                if (mask !== 0)
                    buf[buf.length - 1] >>= 7 - mask;
                
                return new bn(buf);
            }
            
            MillerRabin.prototype.test = function test(n, k, cb) {
                var len = n.bitLength();
                var red = bn.mont(n);
                var rone = new bn(1).toRed(red);
                
                if (!k)
                    k = Math.max(1, (len / 48) | 0);
                
                // Find d and s, (n - 1) = (2 ^ s) * d;
                var n1 = n.subn(1);
                var n2 = n1.subn(1);
                for (var s = 0; !n1.testn(s); s++) { }
                var d = n.shrn(s);
                
                var rn1 = n1.toRed(red);
                
                var prime = true;
                for (; k > 0; k--) {
                    var a = this._rand(n2);
                    if (cb)
                        cb(a);
                    
                    var x = a.toRed(red).redPow(d);
                    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
                        continue;
                    
                    for (var i = 1; i < s; i++) {
                        x = x.redSqr();
                        
                        if (x.cmp(rone) === 0)
                            return false;
                        if (x.cmp(rn1) === 0)
                            break;
                    }
                    
                    if (i === s)
                        return false;
                }
                
                return prime;
            };
            
            MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
                var len = n.bitLength();
                var red = bn.mont(n);
                var rone = new bn(1).toRed(red);
                
                if (!k)
                    k = Math.max(1, (len / 48) | 0);
                
                // Find d and s, (n - 1) = (2 ^ s) * d;
                var n1 = n.subn(1);
                var n2 = n1.subn(1);
                for (var s = 0; !n1.testn(s); s++) { }
                var d = n.shrn(s);
                
                var rn1 = n1.toRed(red);
                
                for (; k > 0; k--) {
                    var a = this._rand(n2);
                    
                    var g = n.gcd(a);
                    if (g.cmpn(1) !== 0)
                        return g;
                    
                    var x = a.toRed(red).redPow(d);
                    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
                        continue;
                    
                    for (var i = 1; i < s; i++) {
                        x = x.redSqr();
                        
                        if (x.cmp(rone) === 0)
                            return x.fromRed().subn(1).gcd(n);
                        if (x.cmp(rn1) === 0)
                            break;
                    }
                    
                    if (i === s) {
                        x = x.redSqr();
                        return x.fromRed().subn(1).gcd(n);
                    }
                }
                
                return false;
            };

        }, { "bn.js": 284, "brorand": 286 }], 286: [function (require, module, exports) {
            arguments[4][213][0].apply(exports, arguments)
        }, { "dup": 213 }], 287: [function (require, module, exports) {
            (function (Buffer) {
                var createHmac = require('create-hmac')
                var MAX_ALLOC = Math.pow(2, 30) - 1// default in iojs
                
                exports.pbkdf2 = pbkdf2
                function pbkdf2(password, salt, iterations, keylen, digest, callback) {
                    if (typeof digest === 'function') {
                        callback = digest
                        digest = undefined
                    }
                    
                    if (typeof callback !== 'function') {
                        throw new Error('No callback provided to pbkdf2')
                    }
                    
                    var result = pbkdf2Sync(password, salt, iterations, keylen, digest)
                    setTimeout(function () {
                        callback(undefined, result)
                    })
                }
                
                exports.pbkdf2Sync = pbkdf2Sync
                function pbkdf2Sync(password, salt, iterations, keylen, digest) {
                    if (typeof iterations !== 'number') {
                        throw new TypeError('Iterations not a number')
                    }
                    
                    if (iterations < 0) {
                        throw new TypeError('Bad iterations')
                    }
                    
                    if (typeof keylen !== 'number') {
                        throw new TypeError('Key length not a number')
                    }
                    
                    if (keylen < 0 || keylen > MAX_ALLOC) {
                        throw new TypeError('Bad key length')
                    }
                    
                    digest = digest || 'sha1'
                    
                    if (!Buffer.isBuffer(password)) password = new Buffer(password, 'binary')
                    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt, 'binary')
                    
                    var hLen
                    var l = 1
                    var DK = new Buffer(keylen)
                    var block1 = new Buffer(salt.length + 4)
                    salt.copy(block1, 0, 0, salt.length)
                    
                    var r
                    var T
                    
                    for (var i = 1; i <= l; i++) {
                        block1.writeUInt32BE(i, salt.length)
                        var U = createHmac(digest, password).update(block1).digest()
                        
                        if (!hLen) {
                            hLen = U.length
                            T = new Buffer(hLen)
                            l = Math.ceil(keylen / hLen)
                            r = keylen - (l - 1) * hLen
                        }
                        
                        U.copy(T, 0, 0, hLen)
                        
                        for (var j = 1; j < iterations; j++) {
                            U = createHmac(digest, password).update(U).digest()
                            
                            for (var k = 0; k < hLen; k++) {
                                T[k] ^= U[k]
                            }
                        }
                        
                        var destPos = (i - 1) * hLen
                        var len = (i === l ? r : hLen)
                        T.copy(DK, destPos, 0, len)
                    }
                    
                    return DK
                }

            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172, "create-hmac": 279 }], 288: [function (require, module, exports) {
            exports.publicEncrypt = require('./publicEncrypt');
            exports.privateDecrypt = require('./privateDecrypt');
            
            exports.privateEncrypt = function privateEncrypt(key, buf) {
                return exports.publicEncrypt(key, buf, true);
            };
            
            exports.publicDecrypt = function publicDecrypt(key, buf) {
                return exports.privateDecrypt(key, buf, true);
            };
        }, { "./privateDecrypt": 312, "./publicEncrypt": 313 }], 289: [function (require, module, exports) {
            (function (Buffer) {
                var createHash = require('create-hash');
                module.exports = function (seed, len) {
                    var t = new Buffer('');
                    var i = 0, c;
                    while (t.length < len) {
                        c = i2ops(i++);
                        t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
                    }
                    return t.slice(0, len);
                };
                
                function i2ops(c) {
                    var out = new Buffer(4);
                    out.writeUInt32BE(c, 0);
                    return out;
                }
            }).call(this, require("buffer").Buffer)
        }, { "buffer": 172, "create-hash": 267 }], 290: [function (require, module, exports) {
            arguments[4][198][0].apply(exports, arguments)
        }, { "dup": 198 }], 291: [function (require, module, exports) {
            arguments[4][199][0].apply(exports, arguments)
        }, { "bn.js": 290, "buffer": 172, "dup": 199, "randombytes": 316 }], 292: [function (require, module, exports) {
            arguments[4][221][0].apply(exports, arguments)
        }, { "buffer": 172, "create-hash": 267, "dup": 221 }], 293: [function (require, module, exports) {
            arguments[4][222][0].apply(exports, arguments)
        }, { "dup": 222 }], 294: [function (require, module, exports) {
            arguments[4][223][0].apply(exports, arguments)
        }, { "asn1.js": 297, "dup": 223 }], 295: [function (require, module, exports) {
            arguments[4][224][0].apply(exports, arguments)
        }, { "./EVP_BytesToKey": 292, "browserify-aes": 180, "buffer": 172, "dup": 224 }], 296: [function (require, module, exports) {
            arguments[4][225][0].apply(exports, arguments)
        }, { "./aesid.json": 293, "./asn1": 294, "./fixProc": 295, "browserify-aes": 180, "buffer": 172, "dup": 225, "pbkdf2": 287 }], 297: [function (require, module, exports) {
            arguments[4][226][0].apply(exports, arguments)
        }, { "./asn1/api": 298, "./asn1/base": 300, "./asn1/constants": 304, "./asn1/decoders": 306, "./asn1/encoders": 309, "bn.js": 290, "dup": 226 }], 298: [function (require, module, exports) {
            arguments[4][227][0].apply(exports, arguments)
        }, { "../asn1": 297, "dup": 227, "inherits": 318, "vm": 343 }], 299: [function (require, module, exports) {
            arguments[4][228][0].apply(exports, arguments)
        }, { "../base": 300, "buffer": 172, "dup": 228, "inherits": 318 }], 300: [function (require, module, exports) {
            arguments[4][229][0].apply(exports, arguments)
        }, { "./buffer": 299, "./node": 301, "./reporter": 302, "dup": 229 }], 301: [function (require, module, exports) {
            arguments[4][230][0].apply(exports, arguments)
        }, { "../base": 300, "dup": 230, "minimalistic-assert": 311 }], 302: [function (require, module, exports) {
            arguments[4][231][0].apply(exports, arguments)
        }, { "dup": 231, "inherits": 318 }], 303: [function (require, module, exports) {
            arguments[4][232][0].apply(exports, arguments)
        }, { "../constants": 304, "dup": 232 }], 304: [function (require, module, exports) {
            arguments[4][233][0].apply(exports, arguments)
        }, { "./der": 303, "dup": 233 }], 305: [function (require, module, exports) {
            arguments[4][234][0].apply(exports, arguments)
        }, { "../../asn1": 297, "dup": 234, "inherits": 318 }], 306: [function (require, module, exports) {
            arguments[4][235][0].apply(exports, arguments)
        }, { "./der": 305, "./pem": 307, "dup": 235 }], 307: [function (require, module, exports) {
            arguments[4][236][0].apply(exports, arguments)
        }, { "../../asn1": 297, "./der": 305, "buffer": 172, "dup": 236, "inherits": 318 }], 308: [function (require, module, exports) {
            arguments[4][237][0].apply(exports, arguments)
        }, { "../../asn1": 297, "buffer": 172, "dup": 237, "inherits": 318 }], 309: [function (require, module, exports) {
            arguments[4][238][0].apply(exports, arguments)
        }, { "./der": 308, "./pem": 310, "dup": 238 }], 310: [function (require, module, exports) {
            arguments[4][239][0].apply(exports, arguments)
        }, { "../../asn1": 297, "./der": 308, "buffer": 172, "dup": 239, "inherits": 318 }], 311: [function (require, module, exports) {
            arguments[4][240][0].apply(exports, arguments)
        }, { "dup": 240 }], 312: [function (require, module, exports) {
            (function (Buffer) {
                var parseKeys = require('parse-asn1');
                var mgf = require('./mgf');
                var xor = require('./xor');
                var bn = require('bn.js');
                var crt = require('browserify-rsa');
                var createHash = require('create-hash');
                var withPublic = require('./withPublic');
                module.exports = function privateDecrypt(private_key, enc, reverse) {
                    var padding;
                    if (private_key.padding) {
                        padding = private_key.padding;
                    } else if (reverse) {
                        padding = 1;
                    } else {
                        padding = 4;
                    }
                    
                    var key = parseKeys(private_key);
                    var k = key.modulus.byteLength();
                    if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
                        throw new Error('decryption error');
                    }
                    var msg;
                    if (reverse) {
                        msg = withPublic(new bn(enc), key);
                    } else {
                        msg = crt(enc, key);
                    }
                    var zBuffer = new Buffer(k - msg.length);
                    zBuffer.fill(0);
                    msg = Buffer.concat([zBuffer, msg], k);
                    if (padding === 4) {
                        return oaep(key, msg);
                    } else if (padding === 1) {
                        return pkcs1(key, msg, reverse);
                    } else if (padding === 3) {
                        return msg;
                    } else {
                        throw new Error('unknown padding');
                    }
                };
                
                function oaep(key, msg) {
                    var n = key.modulus;
                    var k = key.modulus.byteLength();
                    var mLen = msg.length;
                    var iHash = createHash('sha1').update(new Buffer('')).digest();
                    var hLen = iHash.length;
                    var hLen2 = 2 * hLen;
                    if (msg[0] !== 0) {
                        throw new Error('decryption error');
                    }
                    var maskedSeed = msg.slice(1, hLen + 1);
                    var maskedDb = msg.slice(hLen + 1);
                    var seed = xor(maskedSeed, mgf(maskedDb, hLen));
                    var db = xor(maskedDb, mgf(seed, k - hLen - 1));
                    if (compare(iHash, db.slice(0, hLen))) {
                        throw new Error('decryption error');
                    }
                    var i = hLen;
                    while (db[i] === 0) {
                        i++;
                    }
                    if (db[i++] !== 1) {
                        throw new Error('decryption error');
                    }
                    return db.slice(i);
                }
                
                function pkcs1(key, msg, reverse) {
                    var p1 = msg.slice(0, 2);
                    var i = 2;
                    var status = 0;
                    while (msg[i++] !== 0) {
                        if (i >= msg.length) {
                            status++;
                            break;
                        }
                    }
                    var ps = msg.slice(2, i - 1);
                    var p2 = msg.slice(i - 1, i);
                    
                    if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
                        status++;
                    }
                    if (ps.length < 8) {
                        status++;
                    }
                    if (status) {
                        throw new Error('decryption error');
                    }
                    return msg.slice(i);
                }
                function compare(a, b) {
                    a = new Buffer(a);
                    b = new Buffer(b);
                    var dif = 0;
                    var len = a.length;
                    if (a.length !== b.length) {
                        dif++;
                        len = Math.min(a.length, b.length);
                    }
                    var i = -1;
                    while (++i < len) {
                        dif += (a[i] ^ b[i]);
                    }
                    return dif;
                }
            }).call(this, require("buffer").Buffer)
        }, { "./mgf": 289, "./withPublic": 314, "./xor": 315, "bn.js": 290, "browserify-rsa": 291, "buffer": 172, "create-hash": 267, "parse-asn1": 296 }], 313: [function (require, module, exports) {
            (function (Buffer) {
                var parseKeys = require('parse-asn1');
                var randomBytes = require('randombytes');
                var createHash = require('create-hash');
                var mgf = require('./mgf');
                var xor = require('./xor');
                var bn = require('bn.js');
                var withPublic = require('./withPublic');
                var crt = require('browserify-rsa');
                
                var constants = {
                    RSA_PKCS1_OAEP_PADDING: 4,
                    RSA_PKCS1_PADDIN: 1,
                    RSA_NO_PADDING: 3
                };
                
                module.exports = function publicEncrypt(public_key, msg, reverse) {
                    var padding;
                    if (public_key.padding) {
                        padding = public_key.padding;
                    } else if (reverse) {
                        padding = 1;
                    } else {
                        padding = 4;
                    }
                    var key = parseKeys(public_key);
                    var paddedMsg;
                    if (padding === 4) {
                        paddedMsg = oaep(key, msg);
                    } else if (padding === 1) {
                        paddedMsg = pkcs1(key, msg, reverse);
                    } else if (padding === 3) {
                        paddedMsg = new bn(msg);
                        if (paddedMsg.cmp(key.modulus) >= 0) {
                            throw new Error('data too long for modulus');
                        }
                    } else {
                        throw new Error('unknown padding');
                    }
                    if (reverse) {
                        return crt(paddedMsg, key);
                    } else {
                        return withPublic(paddedMsg, key);
                    }
                };
                
                function oaep(key, msg) {
                    var k = key.modulus.byteLength();
                    var mLen = msg.length;
                    var iHash = createHash('sha1').update(new Buffer('')).digest();
                    var hLen = iHash.length;
                    var hLen2 = 2 * hLen;
                    if (mLen > k - hLen2 - 2) {
                        throw new Error('message too long');
                    }
                    var ps = new Buffer(k - mLen - hLen2 - 2);
                    ps.fill(0);
                    var dblen = k - hLen - 1;
                    var seed = randomBytes(hLen);
                    var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
                    var maskedSeed = xor(seed, mgf(maskedDb, hLen));
                    return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
                }
                function pkcs1(key, msg, reverse) {
                    var mLen = msg.length;
                    var k = key.modulus.byteLength();
                    if (mLen > k - 11) {
                        throw new Error('message too long');
                    }
                    var ps;
                    if (reverse) {
                        ps = new Buffer(k - mLen - 3);
                        ps.fill(0xff);
                    } else {
                        ps = nonZero(k - mLen - 3);
                    }
                    return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
                }
                function nonZero(len, crypto) {
                    var out = new Buffer(len);
                    var i = 0;
                    var cache = randomBytes(len * 2);
                    var cur = 0;
                    var num;
                    while (i < len) {
                        if (cur === cache.length) {
                            cache = randomBytes(len * 2);
                            cur = 0;
                        }
                        num = cache[cur++];
                        if (num) {
                            out[i++] = num;
                        }
                    }
                    return out;
                }
            }).call(this, require("buffer").Buffer)
        }, { "./mgf": 289, "./withPublic": 314, "./xor": 315, "bn.js": 290, "browserify-rsa": 291, "buffer": 172, "create-hash": 267, "parse-asn1": 296, "randombytes": 316 }], 314: [function (require, module, exports) {
            (function (Buffer) {
                var bn = require('bn.js');
                function withPublic(paddedMsg, key) {
                    return new Buffer(paddedMsg
    .toRed(bn.mont(key.modulus))
    .redPow(new bn(key.publicExponent))
    .fromRed()
    .toArray());
                }
                
                module.exports = withPublic;
            }).call(this, require("buffer").Buffer)
        }, { "bn.js": 290, "buffer": 172 }], 315: [function (require, module, exports) {
            module.exports = function xor(a, b) {
                var len = a.length;
                var i = -1;
                while (++i < len) {
                    a[i] ^= b[i];
                }
                return a
            };
        }, {}], 316: [function (require, module, exports) {
            (function (process, global, Buffer) {
                'use strict';
                
                var crypto = global.crypto || global.msCrypto
                if (crypto && crypto.getRandomValues) {
                    module.exports = randomBytes;
                } else {
                    module.exports = oldBrowser;
                }
                function randomBytes(size, cb) {
                    var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
                    /* This will not work in older browsers.
     * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
     */

  crypto.getRandomValues(bytes);
                    if (typeof cb === 'function') {
                        return process.nextTick(function () {
                            cb(null, bytes);
                        });
                    }
                    return bytes;
                }
                function oldBrowser() {
                    throw new Error(
                        'secure random number generation not supported by this browser\n' +
      'use chrome, FireFox or Internet Explorer 11'
                    )
                }

            }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer)
        }, { "_process": 322, "buffer": 172 }], 317: [function (require, module, exports) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            
            function EventEmitter() {
                this._events = this._events || {};
                this._maxListeners = this._maxListeners || undefined;
            }
            module.exports = EventEmitter;
            
            // Backwards-compat with node 0.10.x
            EventEmitter.EventEmitter = EventEmitter;
            
            EventEmitter.prototype._events = undefined;
            EventEmitter.prototype._maxListeners = undefined;
            
            // By default EventEmitters will print a warning if more than 10 listeners are
            // added to it. This is a useful default which helps finding memory leaks.
            EventEmitter.defaultMaxListeners = 10;
            
            // Obviously not all Emitters should be limited to 10. This function allows
            // that to be increased. Set to zero for unlimited.
            EventEmitter.prototype.setMaxListeners = function (n) {
                if (!isNumber(n) || n < 0 || isNaN(n))
                    throw TypeError('n must be a positive number');
                this._maxListeners = n;
                return this;
            };
            
            EventEmitter.prototype.emit = function (type) {
                var er, handler, len, args, i, listeners;
                
                if (!this._events)
                    this._events = {};
                
                // If there is no 'error' event listener then throw.
                if (type === 'error') {
                    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
                        er = arguments[1];
                        if (er instanceof Error) {
                            throw er; // Unhandled 'error' event
                        }
                        //throw TypeError('Uncaught, unspecified "error" event.');
                        console.log('Uncaught, unspecified "error" event.');
                    }
                }
                
                handler = this._events[type];
                
                if (isUndefined(handler))
                    return false;
                
                if (isFunction(handler)) {
                    switch (arguments.length) {
      // fast cases
                        case 1:
                            handler.call(this);
                            break;
                        case 2:
                            handler.call(this, arguments[1]);
                            break;
                        case 3:
                            handler.call(this, arguments[1], arguments[2]);
                            break;
      // slower
                        default:
                            len = arguments.length;
                            args = new Array(len - 1);
                            for (i = 1; i < len; i++)
                                args[i - 1] = arguments[i];
                            handler.apply(this, args);
                    }
                } else if (isObject(handler)) {
                    len = arguments.length;
                    args = new Array(len - 1);
                    for (i = 1; i < len; i++)
                        args[i - 1] = arguments[i];
                    
                    listeners = handler.slice();
                    len = listeners.length;
                    for (i = 0; i < len; i++)
                        listeners[i].apply(this, args);
                }
                
                return true;
            };
            
            EventEmitter.prototype.addListener = function (type, listener) {
                var m;
                
                if (!isFunction(listener))
                    throw TypeError('listener must be a function');
                
                if (!this._events)
                    this._events = {};
                
                // To avoid recursion in the case that type === "newListener"! Before
                // adding it to the listeners, first emit "newListener".
                if (this._events.newListener)
                    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);
                
                if (!this._events[type])
                    // Optimize the case of one listener. Don't need the extra array object.
                    this._events[type] = listener;
                else if (isObject(this._events[type]))
                    // If we've already got an array, just append.
                    this._events[type].push(listener);
                else
                    // Adding the second element, need to change to array.
                    this._events[type] = [this._events[type], listener];
                
                // Check for listener leak
                if (isObject(this._events[type]) && !this._events[type].warned) {
                    var m;
                    if (!isUndefined(this._maxListeners)) {
                        m = this._maxListeners;
                    } else {
                        m = EventEmitter.defaultMaxListeners;
                    }
                    
                    if (m && m > 0 && this._events[type].length > m) {
                        this._events[type].warned = true;
                        console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
                        if (typeof console.trace === 'function') {
                            // not supported in IE 10
                            console.trace();
                        }
                    }
                }
                
                return this;
            };
            
            EventEmitter.prototype.on = EventEmitter.prototype.addListener;
            
            EventEmitter.prototype.once = function (type, listener) {
                if (!isFunction(listener))
                    throw TypeError('listener must be a function');
                
                var fired = false;
                
                function g() {
                    this.removeListener(type, g);
                    
                    if (!fired) {
                        fired = true;
                        listener.apply(this, arguments);
                    }
                }
                
                g.listener = listener;
                this.on(type, g);
                
                return this;
            };
            
            // emits a 'removeListener' event iff the listener was removed
            EventEmitter.prototype.removeListener = function (type, listener) {
                var list, position, length, i;
                
                if (!isFunction(listener))
                    throw TypeError('listener must be a function');
                
                if (!this._events || !this._events[type])
                    return this;
                
                list = this._events[type];
                length = list.length;
                position = -1;
                
                if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
                    delete this._events[type];
                    if (this._events.removeListener)
                        this.emit('removeListener', type, listener);

                } else if (isObject(list)) {
                    for (i = length; i-- > 0;) {
                        if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
                            position = i;
                            break;
                        }
                    }
                    
                    if (position < 0)
                        return this;
                    
                    if (list.length === 1) {
                        list.length = 0;
                        delete this._events[type];
                    } else {
                        list.splice(position, 1);
                    }
                    
                    if (this._events.removeListener)
                        this.emit('removeListener', type, listener);
                }
                
                return this;
            };
            
            EventEmitter.prototype.removeAllListeners = function (type) {
                var key, listeners;
                
                if (!this._events)
                    return this;
                
                // not listening for removeListener, no need to emit
                if (!this._events.removeListener) {
                    if (arguments.length === 0)
                        this._events = {};
                    else if (this._events[type])
                        delete this._events[type];
                    return this;
                }
                
                // emit removeListener for all listeners on all events
                if (arguments.length === 0) {
                    for (key in this._events) {
                        if (key === 'removeListener') continue;
                        this.removeAllListeners(key);
                    }
                    this.removeAllListeners('removeListener');
                    this._events = {};
                    return this;
                }
                
                listeners = this._events[type];
                
                if (isFunction(listeners)) {
                    this.removeListener(type, listeners);
                } else {
                    // LIFO order
                    while (listeners.length)
                        this.removeListener(type, listeners[listeners.length - 1]);
                }
                delete this._events[type];
                
                return this;
            };
            
            EventEmitter.prototype.listeners = function (type) {
                var ret;
                if (!this._events || !this._events[type])
                    ret = [];
                else if (isFunction(this._events[type]))
                    ret = [this._events[type]];
                else
                    ret = this._events[type].slice();
                return ret;
            };
            
            EventEmitter.listenerCount = function (emitter, type) {
                var ret;
                if (!emitter._events || !emitter._events[type])
                    ret = 0;
                else if (isFunction(emitter._events[type]))
                    ret = 1;
                else
                    ret = emitter._events[type].length;
                return ret;
            };
            
            function isFunction(arg) {
                return typeof arg === 'function';
            }
            
            function isNumber(arg) {
                return typeof arg === 'number';
            }
            
            function isObject(arg) {
                return typeof arg === 'object' && arg !== null;
            }
            
            function isUndefined(arg) {
                return arg === void 0;
            }

        }, {}], 318: [function (require, module, exports) {
            arguments[4][102][0].apply(exports, arguments)
        }, { "dup": 102 }], 319: [function (require, module, exports) {
            arguments[4][103][0].apply(exports, arguments)
        }, { "dup": 103 }], 320: [function (require, module, exports) {
            exports.endianness = function () { return 'LE' };
            
            exports.hostname = function () {
                if (typeof location !== 'undefined') {
                    return location.hostname
                }
                else return '';
            };
            
            exports.loadavg = function () { return [] };
            
            exports.uptime = function () { return 0 };
            
            exports.freemem = function () {
                return Number.MAX_VALUE;
            };
            
            exports.totalmem = function () {
                return Number.MAX_VALUE;
            };
            
            exports.cpus = function () { return [] };
            
            exports.type = function () { return 'Browser' };
            
            exports.release = function () {
                if (typeof navigator !== 'undefined') {
                    return navigator.appVersion;
                }
                return '';
            };
            
            exports.networkInterfaces 
= exports.getNetworkInterfaces 
= function () { return {} };
            
            exports.arch = function () { return 'javascript' };
            
            exports.platform = function () { return 'browser' };
            
            exports.tmpdir = exports.tmpDir = function () {
                return '/tmp';
            };
            
            exports.EOL = '\n';

        }, {}], 321: [function (require, module, exports) {
            (function (process) {
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                
                // resolves . and .. elements in a path array with directory names there
                // must be no slashes, empty elements, or device names (c:\) in the array
                // (so also no leading and trailing slashes - it does not distinguish
                // relative and absolute paths)
                function normalizeArray(parts, allowAboveRoot) {
                    // if the path tries to go above the root, `up` ends up > 0
                    var up = 0;
                    for (var i = parts.length - 1; i >= 0; i--) {
                        var last = parts[i];
                        if (last === '.') {
                            parts.splice(i, 1);
                        } else if (last === '..') {
                            parts.splice(i, 1);
                            up++;
                        } else if (up) {
                            parts.splice(i, 1);
                            up--;
                        }
                    }
                    
                    // if the path is allowed to go above the root, restore leading ..s
                    if (allowAboveRoot) {
                        for (; up--; up) {
                            parts.unshift('..');
                        }
                    }
                    
                    return parts;
                }
                
                // Split a filename into [root, dir, basename, ext], unix version
                // 'root' is just a slash, or nothing.
                var splitPathRe =
 /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
                var splitPath = function (filename) {
                    return splitPathRe.exec(filename).slice(1);
                };
                
                // path.resolve([from ...], to)
                // posix version
                exports.resolve = function () {
                    var resolvedPath = '',
                        resolvedAbsolute = false;
                    
                    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                        var path = (i >= 0) ? arguments[i] : process.cwd();
                        
                        // Skip empty and invalid entries
                        if (typeof path !== 'string') {
                            throw new TypeError('Arguments to path.resolve must be strings');
                        } else if (!path) {
                            continue;
                        }
                        
                        resolvedPath = path + '/' + resolvedPath;
                        resolvedAbsolute = path.charAt(0) === '/';
                    }
                    
                    // At this point the path should be resolved to a full absolute path, but
                    // handle relative paths to be safe (might happen when process.cwd() fails)
                    
                    // Normalize the path
                    resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
                        return !!p;
                    }), !resolvedAbsolute).join('/');
                    
                    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
                };
                
                // path.normalize(path)
                // posix version
                exports.normalize = function (path) {
                    var isAbsolute = exports.isAbsolute(path),
                        trailingSlash = substr(path, -1) === '/';
                    
                    // Normalize the path
                    path = normalizeArray(filter(path.split('/'), function (p) {
                        return !!p;
                    }), !isAbsolute).join('/');
                    
                    if (!path && !isAbsolute) {
                        path = '.';
                    }
                    if (path && trailingSlash) {
                        path += '/';
                    }
                    
                    return (isAbsolute ? '/' : '') + path;
                };
                
                // posix version
                exports.isAbsolute = function (path) {
                    return path.charAt(0) === '/';
                };
                
                // posix version
                exports.join = function () {
                    var paths = Array.prototype.slice.call(arguments, 0);
                    return exports.normalize(filter(paths, function (p, index) {
                        if (typeof p !== 'string') {
                            throw new TypeError('Arguments to path.join must be strings');
                        }
                        return p;
                    }).join('/'));
                };
                
                
                // path.relative(from, to)
                // posix version
                exports.relative = function (from, to) {
                    from = exports.resolve(from).substr(1);
                    to = exports.resolve(to).substr(1);
                    
                    function trim(arr) {
                        var start = 0;
                        for (; start < arr.length; start++) {
                            if (arr[start] !== '') break;
                        }
                        
                        var end = arr.length - 1;
                        for (; end >= 0; end--) {
                            if (arr[end] !== '') break;
                        }
                        
                        if (start > end) return [];
                        return arr.slice(start, end - start + 1);
                    }
                    
                    var fromParts = trim(from.split('/'));
                    var toParts = trim(to.split('/'));
                    
                    var length = Math.min(fromParts.length, toParts.length);
                    var samePartsLength = length;
                    for (var i = 0; i < length; i++) {
                        if (fromParts[i] !== toParts[i]) {
                            samePartsLength = i;
                            break;
                        }
                    }
                    
                    var outputParts = [];
                    for (var i = samePartsLength; i < fromParts.length; i++) {
                        outputParts.push('..');
                    }
                    
                    outputParts = outputParts.concat(toParts.slice(samePartsLength));
                    
                    return outputParts.join('/');
                };
                
                exports.sep = '/';
                exports.delimiter = ':';
                
                exports.dirname = function (path) {
                    var result = splitPath(path),
                        root = result[0],
                        dir = result[1];
                    
                    if (!root && !dir) {
                        // No dirname whatsoever
                        return '.';
                    }
                    
                    if (dir) {
                        // It has a dirname, strip trailing slash
                        dir = dir.substr(0, dir.length - 1);
                    }
                    
                    return root + dir;
                };
                
                
                exports.basename = function (path, ext) {
                    var f = splitPath(path)[2];
                    // TODO: make this comparison case-insensitive on windows?
                    if (ext && f.substr(-1 * ext.length) === ext) {
                        f = f.substr(0, f.length - ext.length);
                    }
                    return f;
                };
                
                
                exports.extname = function (path) {
                    return splitPath(path)[3];
                };
                
                function filter(xs, f) {
                    if (xs.filter) return xs.filter(f);
                    var res = [];
                    for (var i = 0; i < xs.length; i++) {
                        if (f(xs[i], i, xs)) res.push(xs[i]);
                    }
                    return res;
                }
                
                // String.prototype.substr - negative index don't work in IE8
                var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
                    if (start < 0) start = str.length + start;
                    return str.substr(start, len);
                }
;

            }).call(this, require('_process'))
        }, { "_process": 322 }], 322: [function (require, module, exports) {
            // shim for using process in browser
            
            var process = module.exports = {};
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;
            
            function cleanUpNextTick() {
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                } else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }
            
            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = setTimeout(cleanUpNextTick);
                draining = true;
                
                var len = queue.length;
                while (len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        currentQueue[queueIndex].run();
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                clearTimeout(timeout);
            }
            
            process.nextTick = function (fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                    setTimeout(drainQueue, 0);
                }
            };
            
            // v8 likes predictible objects
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = ''; // empty string to avoid regexp issues
            process.versions = {};
            
            function noop() { }
            
            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            
            process.binding = function (name) {
                throw new Error('process.binding is not supported');
            };
            
            // TODO(shtylman)
            process.cwd = function () { return '/' };
            process.chdir = function (dir) {
                throw new Error('process.chdir is not supported');
            };
            process.umask = function () { return 0; };

        }, {}], 323: [function (require, module, exports) {
            (function (global) {
                /*! https://mths.be/punycode v1.3.2 by @mathias */
                ; (function (root) {
                    
                    /** Detect free variables */
                    var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
                    var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
                    var freeGlobal = typeof global == 'object' && global;
                    if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
                        root = freeGlobal;
                    }
                    
                    /**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
                        maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
                        base = 36,
                        tMin = 1,
                        tMax = 26,
                        skew = 38,
                        damp = 700,
                        initialBias = 72,
                        initialN = 128, // 0x80
                        delimiter = '-', // '\x2D'

	/** Regular expressions */
                        regexPunycode = /^xn--/,
                        regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
                        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
                        errors = {
                            'overflow': 'Overflow: input needs wider integers to process',
                            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                            'invalid-input': 'Invalid input'
                        },

	/** Convenience shortcuts */
                        baseMinusTMin = base - tMin,
                        floor = Math.floor,
                        stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
                        key;
                    
                    /*--------------------------------------------------------------------------*/
                    
                    /**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
                        throw RangeError(errors[type]);
                    }
                    
                    /**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
                        var length = array.length;
                        var result = [];
                        while (length--) {
                            result[length] = fn(array[length]);
                        }
                        return result;
                    }
                    
                    /**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
                        var parts = string.split('@');
                        var result = '';
                        if (parts.length > 1) {
                            // In email addresses, only the domain name should be punycoded. Leave
                            // the local part (i.e. everything up to `@`) intact.
                            result = parts[0] + '@';
                            string = parts[1];
                        }
                        // Avoid `split(regex)` for IE8 compatibility. See #17.
                        string = string.replace(regexSeparators, '\x2E');
                        var labels = string.split('.');
                        var encoded = map(labels, fn).join('.');
                        return result + encoded;
                    }
                    
                    /**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
                        var output = [],
                            counter = 0,
                            length = string.length,
                            value,
                            extra;
                        while (counter < length) {
                            value = string.charCodeAt(counter++);
                            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                                // high surrogate, and there is a next character
                                extra = string.charCodeAt(counter++);
                                if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                                } else {
                                    // unmatched surrogate; only append this code unit, in case the next
                                    // code unit is the high surrogate of a surrogate pair
                                    output.push(value);
                                    counter--;
                                }
                            } else {
                                output.push(value);
                            }
                        }
                        return output;
                    }
                    
                    /**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
                        return map(array, function (value) {
                            var output = '';
                            if (value > 0xFFFF) {
                                value -= 0x10000;
                                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                                value = 0xDC00 | value & 0x3FF;
                            }
                            output += stringFromCharCode(value);
                            return output;
                        }).join('');
                    }
                    
                    /**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
                        if (codePoint - 48 < 10) {
                            return codePoint - 22;
                        }
                        if (codePoint - 65 < 26) {
                            return codePoint - 65;
                        }
                        if (codePoint - 97 < 26) {
                            return codePoint - 97;
                        }
                        return base;
                    }
                    
                    /**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
                        //  0..25 map to ASCII a..z or A..Z
                        // 26..35 map to ASCII 0..9
                        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                    }
                    
                    /**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
                        var k = 0;
                        delta = firstTime ? floor(delta / damp) : delta >> 1;
                        delta += floor(delta / numPoints);
                        for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
                            delta = floor(delta / baseMinusTMin);
                        }
                        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                    }
                    
                    /**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
                        // Don't use UCS-2
                        var output = [],
                            inputLength = input.length,
                            out,
                            i = 0,
                            n = initialN,
                            bias = initialBias,
                            basic,
                            j,
                            index,
                            oldi,
                            w,
                            k,
                            digit,
                            t,
		    /** Cached calculation results */
                            baseMinusT;
                        
                        // Handle the basic code points: let `basic` be the number of input code
                        // points before the last delimiter, or `0` if there is none, then copy
                        // the first basic code points to the output.
                        
                        basic = input.lastIndexOf(delimiter);
                        if (basic < 0) {
                            basic = 0;
                        }
                        
                        for (j = 0; j < basic; ++j) {
                            // if it's not a basic code point
                            if (input.charCodeAt(j) >= 0x80) {
                                error('not-basic');
                            }
                            output.push(input.charCodeAt(j));
                        }
                        
                        // Main decoding loop: start just after the last delimiter if any basic code
                        // points were copied; start at the beginning otherwise.
                        
                        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
                            
                            // `index` is the index of the next character to be consumed.
                            // Decode a generalized variable-length integer into `delta`,
                            // which gets added to `i`. The overflow checking is easier
                            // if we increase `i` as we go, then subtract off its starting
                            // value at the end to obtain `delta`.
                            for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
                                
                                if (index >= inputLength) {
                                    error('invalid-input');
                                }
                                
                                digit = basicToDigit(input.charCodeAt(index++));
                                
                                if (digit >= base || digit > floor((maxInt - i) / w)) {
                                    error('overflow');
                                }
                                
                                i += digit * w;
                                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                                
                                if (digit < t) {
                                    break;
                                }
                                
                                baseMinusT = base - t;
                                if (w > floor(maxInt / baseMinusT)) {
                                    error('overflow');
                                }
                                
                                w *= baseMinusT;

                            }
                            
                            out = output.length + 1;
                            bias = adapt(i - oldi, out, oldi == 0);
                            
                            // `i` was supposed to wrap around from `out` to `0`,
                            // incrementing `n` each time, so we'll fix that now:
                            if (floor(i / out) > maxInt - n) {
                                error('overflow');
                            }
                            
                            n += floor(i / out);
                            i %= out;
                            
                            // Insert `n` at position `i` of the output
                            output.splice(i++, 0, n);

                        }
                        
                        return ucs2encode(output);
                    }
                    
                    /**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
                        var n,
                            delta,
                            handledCPCount,
                            basicLength,
                            bias,
                            j,
                            m,
                            q,
                            k,
                            t,
                            currentValue,
                            output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
                            inputLength,
		    /** Cached calculation results */
                            handledCPCountPlusOne,
                            baseMinusT,
                            qMinusT;
                        
                        // Convert the input in UCS-2 to Unicode
                        input = ucs2decode(input);
                        
                        // Cache the length
                        inputLength = input.length;
                        
                        // Initialize the state
                        n = initialN;
                        delta = 0;
                        bias = initialBias;
                        
                        // Handle the basic code points
                        for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue < 0x80) {
                                output.push(stringFromCharCode(currentValue));
                            }
                        }
                        
                        handledCPCount = basicLength = output.length;
                        
                        // `handledCPCount` is the number of code points that have been handled;
                        // `basicLength` is the number of basic code points.
                        
                        // Finish the basic string - if it is not empty - with a delimiter
                        if (basicLength) {
                            output.push(delimiter);
                        }
                        
                        // Main encoding loop:
                        while (handledCPCount < inputLength) {
                            
                            // All non-basic code points < n have been handled already. Find the next
                            // larger one:
                            for (m = maxInt, j = 0; j < inputLength; ++j) {
                                currentValue = input[j];
                                if (currentValue >= n && currentValue < m) {
                                    m = currentValue;
                                }
                            }
                            
                            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                            // but guard against overflow
                            handledCPCountPlusOne = handledCPCount + 1;
                            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                                error('overflow');
                            }
                            
                            delta += (m - n) * handledCPCountPlusOne;
                            n = m;
                            
                            for (j = 0; j < inputLength; ++j) {
                                currentValue = input[j];
                                
                                if (currentValue < n && ++delta > maxInt) {
                                    error('overflow');
                                }
                                
                                if (currentValue == n) {
                                    // Represent delta as a generalized variable-length integer
                                    for (q = delta, k = base; /* no condition */; k += base) {
                                        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                                        if (q < t) {
                                            break;
                                        }
                                        qMinusT = q - t;
                                        baseMinusT = base - t;
                                        output.push(
                                            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                                        );
                                        q = floor(qMinusT / baseMinusT);
                                    }
                                    
                                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                    delta = 0;
                                    ++handledCPCount;
                                }
                            }
                            
                            ++delta;
                            ++n;

                        }
                        return output.join('');
                    }
                    
                    /**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
                        return mapDomain(input, function (string) {
                            return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
                        });
                    }
                    
                    /**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
                        return mapDomain(input, function (string) {
                            return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
                        });
                    }
                    
                    /*--------------------------------------------------------------------------*/
                    
                    /** Define the public API */
                    punycode = {
                        /**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
                        /**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
                            'decode': ucs2decode,
                            'encode': ucs2encode
                        },
                        'decode': decode,
                        'encode': encode,
                        'toASCII': toASCII,
                        'toUnicode': toUnicode
                    };
                    
                    /** Expose `punycode` */
                    // Some AMD build optimizers, like r.js, check for specific condition patterns
                    // like the following:
                    if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
                        define('punycode', function () {
                            return punycode;
                        });
                    } else if (freeExports && freeModule) {
                        if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
                            freeModule.exports = punycode;
                        } else { // in Narwhal or RingoJS v0.7.0-
                            for (key in punycode) {
                                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                            }
                        }
                    } else { // in Rhino or a web browser
                        root.punycode = punycode;
                    }

                }(this));

            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}], 324: [function (require, module, exports) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            
            'use strict';
            
            // If obj.hasOwnProperty has been overridden, then calling
            // obj.hasOwnProperty(prop) will break.
            // See: https://github.com/joyent/node/issues/1707
            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            
            module.exports = function (qs, sep, eq, options) {
                sep = sep || '&';
                eq = eq || '=';
                var obj = {};
                
                if (typeof qs !== 'string' || qs.length === 0) {
                    return obj;
                }
                
                var regexp = /\+/g;
                qs = qs.split(sep);
                
                var maxKeys = 1000;
                if (options && typeof options.maxKeys === 'number') {
                    maxKeys = options.maxKeys;
                }
                
                var len = qs.length;
                // maxKeys <= 0 means that we should not limit keys count
                if (maxKeys > 0 && len > maxKeys) {
                    len = maxKeys;
                }
                
                for (var i = 0; i < len; ++i) {
                    var x = qs[i].replace(regexp, '%20'),
                        idx = x.indexOf(eq),
                        kstr, vstr, k, v;
                    
                    if (idx >= 0) {
                        kstr = x.substr(0, idx);
                        vstr = x.substr(idx + 1);
                    } else {
                        kstr = x;
                        vstr = '';
                    }
                    
                    k = decodeURIComponent(kstr);
                    v = decodeURIComponent(vstr);
                    
                    if (!hasOwnProperty(obj, k)) {
                        obj[k] = v;
                    } else if (isArray(obj[k])) {
                        obj[k].push(v);
                    } else {
                        obj[k] = [obj[k], v];
                    }
                }
                
                return obj;
            };
            
            var isArray = Array.isArray || function (xs) {
                return Object.prototype.toString.call(xs) === '[object Array]';
            };

        }, {}], 325: [function (require, module, exports) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            
            'use strict';
            
            var stringifyPrimitive = function (v) {
                switch (typeof v) {
                    case 'string':
                        return v;

                    case 'boolean':
                        return v ? 'true' : 'false';

                    case 'number':
                        return isFinite(v) ? v : '';

                    default:
                        return '';
                }
            };
            
            module.exports = function (obj, sep, eq, name) {
                sep = sep || '&';
                eq = eq || '=';
                if (obj === null) {
                    obj = undefined;
                }
                
                if (typeof obj === 'object') {
                    return map(objectKeys(obj), function (k) {
                        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                        if (isArray(obj[k])) {
                            return map(obj[k], function (v) {
                                return ks + encodeURIComponent(stringifyPrimitive(v));
                            }).join(sep);
                        } else {
                            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                        }
                    }).join(sep);

                }
                
                if (!name) return '';
                return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
            };
            
            var isArray = Array.isArray || function (xs) {
                return Object.prototype.toString.call(xs) === '[object Array]';
            };
            
            function map(xs, f) {
                if (xs.map) return xs.map(f);
                var res = [];
                for (var i = 0; i < xs.length; i++) {
                    res.push(f(xs[i], i));
                }
                return res;
            }
            
            var objectKeys = Object.keys || function (obj) {
                var res = [];
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
                }
                return res;
            };

        }, {}], 326: [function (require, module, exports) {
            'use strict';
            
            exports.decode = exports.parse = require('./decode');
            exports.encode = exports.stringify = require('./encode');

        }, { "./decode": 324, "./encode": 325 }], 327: [function (require, module, exports) {
            module.exports = require("./lib/_stream_duplex.js")

        }, { "./lib/_stream_duplex.js": 328 }], 328: [function (require, module, exports) {
            arguments[4][96][0].apply(exports, arguments)
        }, { "./_stream_readable": 330, "./_stream_writable": 332, "_process": 322, "core-util-is": 333, "dup": 96, "inherits": 318 }], 329: [function (require, module, exports) {
            arguments[4][97][0].apply(exports, arguments)
        }, { "./_stream_transform": 331, "core-util-is": 333, "dup": 97, "inherits": 318 }], 330: [function (require, module, exports) {
            arguments[4][98][0].apply(exports, arguments)
        }, { "./_stream_duplex": 328, "_process": 322, "buffer": 172, "core-util-is": 333, "dup": 98, "events": 317, "inherits": 318, "isarray": 319, "stream": 338, "string_decoder/": 339, "util": 171 }], 331: [function (require, module, exports) {
            arguments[4][99][0].apply(exports, arguments)
        }, { "./_stream_duplex": 328, "core-util-is": 333, "dup": 99, "inherits": 318 }], 332: [function (require, module, exports) {
            arguments[4][100][0].apply(exports, arguments)
        }, { "./_stream_duplex": 328, "_process": 322, "buffer": 172, "core-util-is": 333, "dup": 100, "inherits": 318, "stream": 338 }], 333: [function (require, module, exports) {
            arguments[4][101][0].apply(exports, arguments)
        }, { "buffer": 172, "dup": 101 }], 334: [function (require, module, exports) {
            module.exports = require("./lib/_stream_passthrough.js")

        }, { "./lib/_stream_passthrough.js": 329 }], 335: [function (require, module, exports) {
            arguments[4][105][0].apply(exports, arguments)
        }, { "./lib/_stream_duplex.js": 328, "./lib/_stream_passthrough.js": 329, "./lib/_stream_readable.js": 330, "./lib/_stream_transform.js": 331, "./lib/_stream_writable.js": 332, "dup": 105, "stream": 338 }], 336: [function (require, module, exports) {
            module.exports = require("./lib/_stream_transform.js")

        }, { "./lib/_stream_transform.js": 331 }], 337: [function (require, module, exports) {
            module.exports = require("./lib/_stream_writable.js")

        }, { "./lib/_stream_writable.js": 332 }], 338: [function (require, module, exports) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            
            module.exports = Stream;
            
            var EE = require('events').EventEmitter;
            var inherits = require('inherits');
            
            inherits(Stream, EE);
            Stream.Readable = require('readable-stream/readable.js');
            Stream.Writable = require('readable-stream/writable.js');
            Stream.Duplex = require('readable-stream/duplex.js');
            Stream.Transform = require('readable-stream/transform.js');
            Stream.PassThrough = require('readable-stream/passthrough.js');
            
            // Backwards-compat with node 0.4.x
            Stream.Stream = Stream;
            
            
            
            // old-style streams.  Note that the pipe method (the only relevant
            // part of this class) is overridden in the Readable class.
            
            function Stream() {
                EE.call(this);
            }
            
            Stream.prototype.pipe = function (dest, options) {
                var source = this;
                
                function ondata(chunk) {
                    if (dest.writable) {
                        if (false === dest.write(chunk) && source.pause) {
                            source.pause();
                        }
                    }
                }
                
                source.on('data', ondata);
                
                function ondrain() {
                    if (source.readable && source.resume) {
                        source.resume();
                    }
                }
                
                dest.on('drain', ondrain);
                
                // If the 'end' option is not supplied, dest.end() will be called when
                // source gets the 'end' or 'close' events.  Only dest.end() once.
                if (!dest._isStdio && (!options || options.end !== false)) {
                    source.on('end', onend);
                    source.on('close', onclose);
                }
                
                var didOnEnd = false;
                function onend() {
                    if (didOnEnd) return;
                    didOnEnd = true;
                    
                    dest.end();
                }
                
                
                function onclose() {
                    if (didOnEnd) return;
                    didOnEnd = true;
                    
                    if (typeof dest.destroy === 'function') dest.destroy();
                }
                
                // don't leave dangling pipes when there are errors.
                function onerror(er) {
                    cleanup();
                    if (EE.listenerCount(this, 'error') === 0) {
                        throw er; // Unhandled stream error in pipe.
                    }
                }
                
                source.on('error', onerror);
                dest.on('error', onerror);
                
                // remove all the event listeners that were added.
                function cleanup() {
                    source.removeListener('data', ondata);
                    dest.removeListener('drain', ondrain);
                    
                    source.removeListener('end', onend);
                    source.removeListener('close', onclose);
                    
                    source.removeListener('error', onerror);
                    dest.removeListener('error', onerror);
                    
                    source.removeListener('end', cleanup);
                    source.removeListener('close', cleanup);
                    
                    dest.removeListener('close', cleanup);
                }
                
                source.on('end', cleanup);
                source.on('close', cleanup);
                
                dest.on('close', cleanup);
                
                dest.emit('pipe', source);
                
                // Allow for unix-like usage: A.pipe(B).pipe(C)
                return dest;
            };

        }, { "events": 317, "inherits": 318, "readable-stream/duplex.js": 327, "readable-stream/passthrough.js": 334, "readable-stream/readable.js": 335, "readable-stream/transform.js": 336, "readable-stream/writable.js": 337 }], 339: [function (require, module, exports) {
            arguments[4][104][0].apply(exports, arguments)
        }, { "buffer": 172, "dup": 104 }], 340: [function (require, module, exports) {
            // Copyright Joyent, Inc. and other Node contributors.
            //
            // Permission is hereby granted, free of charge, to any person obtaining a
            // copy of this software and associated documentation files (the
            // "Software"), to deal in the Software without restriction, including
            // without limitation the rights to use, copy, modify, merge, publish,
            // distribute, sublicense, and/or sell copies of the Software, and to permit
            // persons to whom the Software is furnished to do so, subject to the
            // following conditions:
            //
            // The above copyright notice and this permission notice shall be included
            // in all copies or substantial portions of the Software.
            //
            // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
            // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
            // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
            // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
            // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
            // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
            // USE OR OTHER DEALINGS IN THE SOFTWARE.
            
            var punycode = require('punycode');
            
            exports.parse = urlParse;
            exports.resolve = urlResolve;
            exports.resolveObject = urlResolveObject;
            exports.format = urlFormat;
            
            exports.Url = Url;
            
            function Url() {
                this.protocol = null;
                this.slashes = null;
                this.auth = null;
                this.host = null;
                this.port = null;
                this.hostname = null;
                this.hash = null;
                this.search = null;
                this.query = null;
                this.pathname = null;
                this.path = null;
                this.href = null;
            }
            
            // Reference: RFC 3986, RFC 1808, RFC 2396
            
            // define these here so at least they only have to be
            // compiled once on the first module load.
            var protocolPattern = /^([a-z0-9.+-]+:)/i,
                portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
                delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
                unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
                autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
                nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
                hostEndingChars = ['/', '?', '#'],
                hostnameMaxLen = 255,
                hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
                hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
                unsafeProtocol = {
                    'javascript': true,
                    'javascript:': true
                },
    // protocols that never have a hostname.
                hostlessProtocol = {
                    'javascript': true,
                    'javascript:': true
                },
    // protocols that always contain a // bit.
                slashedProtocol = {
                    'http': true,
                    'https': true,
                    'ftp': true,
                    'gopher': true,
                    'file': true,
                    'http:': true,
                    'https:': true,
                    'ftp:': true,
                    'gopher:': true,
                    'file:': true
                },
                querystring = require('querystring');
            
            function urlParse(url, parseQueryString, slashesDenoteHost) {
                if (url && isObject(url) && url instanceof Url) return url;
                
                var u = new Url;
                u.parse(url, parseQueryString, slashesDenoteHost);
                return u;
            }
            
            Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
                if (!isString(url)) {
                    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
                }
                
                var rest = url;
                
                // trim before proceeding.
                // This is to support parse stuff like "  http://foo.com  \n"
                rest = rest.trim();
                
                var proto = protocolPattern.exec(rest);
                if (proto) {
                    proto = proto[0];
                    var lowerProto = proto.toLowerCase();
                    this.protocol = lowerProto;
                    rest = rest.substr(proto.length);
                }
                
                // figure out if it's got a host
                // user@server is *always* interpreted as a hostname, and url
                // resolution will treat //foo/bar as host=foo,path=bar because that's
                // how the browser resolves relative URLs.
                if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                    var slashes = rest.substr(0, 2) === '//';
                    if (slashes && !(proto && hostlessProtocol[proto])) {
                        rest = rest.substr(2);
                        this.slashes = true;
                    }
                }
                
                if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
                    
                    // there's a hostname.
                    // the first instance of /, ?, ;, or # ends the host.
                    //
                    // If there is an @ in the hostname, then non-host chars *are* allowed
                    // to the left of the last @ sign, unless some host-ending character
                    // comes *before* the @-sign.
                    // URLs are obnoxious.
                    //
                    // ex:
                    // http://a@b@c/ => user:a@b host:c
                    // http://a@b?@c => user:a host:c path:/?@c
                    
                    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
                    // Review our test case against browsers more comprehensively.
                    
                    // find the first instance of any hostEndingChars
                    var hostEnd = -1;
                    for (var i = 0; i < hostEndingChars.length; i++) {
                        var hec = rest.indexOf(hostEndingChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                            hostEnd = hec;
                    }
                    
                    // at this point, either we have an explicit point where the
                    // auth portion cannot go past, or the last @ char is the decider.
                    var auth, atSign;
                    if (hostEnd === -1) {
                        // atSign can be anywhere.
                        atSign = rest.lastIndexOf('@');
                    } else {
                        // atSign must be in auth portion.
                        // http://a@b/c@d => host:b auth:a path:/c@d
                        atSign = rest.lastIndexOf('@', hostEnd);
                    }
                    
                    // Now we have a portion which is definitely the auth.
                    // Pull that off.
                    if (atSign !== -1) {
                        auth = rest.slice(0, atSign);
                        rest = rest.slice(atSign + 1);
                        this.auth = decodeURIComponent(auth);
                    }
                    
                    // the host is the remaining to the left of the first non-host char
                    hostEnd = -1;
                    for (var i = 0; i < nonHostChars.length; i++) {
                        var hec = rest.indexOf(nonHostChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                            hostEnd = hec;
                    }
                    // if we still have not hit it, then the entire thing is a host.
                    if (hostEnd === -1)
                        hostEnd = rest.length;
                    
                    this.host = rest.slice(0, hostEnd);
                    rest = rest.slice(hostEnd);
                    
                    // pull out port.
                    this.parseHost();
                    
                    // we've indicated that there is a hostname,
                    // so even if it's empty, it has to be present.
                    this.hostname = this.hostname || '';
                    
                    // if hostname begins with [ and ends with ]
                    // assume that it's an IPv6 address.
                    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';
                    
                    // validate a little.
                    if (!ipv6Hostname) {
                        var hostparts = this.hostname.split(/\./);
                        for (var i = 0, l = hostparts.length; i < l; i++) {
                            var part = hostparts[i];
                            if (!part) continue;
                            if (!part.match(hostnamePartPattern)) {
                                var newpart = '';
                                for (var j = 0, k = part.length; j < k; j++) {
                                    if (part.charCodeAt(j) > 127) {
                                        // we replace non-ASCII char with a temporary placeholder
                                        // we need this to make sure size of hostname is not
                                        // broken by replacing non-ASCII by nothing
                                        newpart += 'x';
                                    } else {
                                        newpart += part[j];
                                    }
                                }
                                // we test again with ASCII char only
                                if (!newpart.match(hostnamePartPattern)) {
                                    var validParts = hostparts.slice(0, i);
                                    var notHost = hostparts.slice(i + 1);
                                    var bit = part.match(hostnamePartStart);
                                    if (bit) {
                                        validParts.push(bit[1]);
                                        notHost.unshift(bit[2]);
                                    }
                                    if (notHost.length) {
                                        rest = '/' + notHost.join('.') + rest;
                                    }
                                    this.hostname = validParts.join('.');
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (this.hostname.length > hostnameMaxLen) {
                        this.hostname = '';
                    } else {
                        // hostnames are always lower case.
                        this.hostname = this.hostname.toLowerCase();
                    }
                    
                    if (!ipv6Hostname) {
                        // IDNA Support: Returns a puny coded representation of "domain".
                        // It only converts the part of the domain name that
                        // has non ASCII characters. I.e. it dosent matter if
                        // you call it with a domain that already is in ASCII.
                        var domainArray = this.hostname.split('.');
                        var newOut = [];
                        for (var i = 0; i < domainArray.length; ++i) {
                            var s = domainArray[i];
                            newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
                        }
                        this.hostname = newOut.join('.');
                    }
                    
                    var p = this.port ? ':' + this.port : '';
                    var h = this.hostname || '';
                    this.host = h + p;
                    this.href += this.host;
                    
                    // strip [ and ] from the hostname
                    // the host field still retains them, though
                    if (ipv6Hostname) {
                        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                        if (rest[0] !== '/') {
                            rest = '/' + rest;
                        }
                    }
                }
                
                // now rest is set to the post-host stuff.
                // chop off any delim chars.
                if (!unsafeProtocol[lowerProto]) {
                    
                    // First, make 100% sure that any "autoEscape" chars get
                    // escaped, even if encodeURIComponent doesn't think they
                    // need to be.
                    for (var i = 0, l = autoEscape.length; i < l; i++) {
                        var ae = autoEscape[i];
                        var esc = encodeURIComponent(ae);
                        if (esc === ae) {
                            esc = escape(ae);
                        }
                        rest = rest.split(ae).join(esc);
                    }
                }
                
                
                // chop off from the tail first.
                var hash = rest.indexOf('#');
                if (hash !== -1) {
                    // got a fragment string.
                    this.hash = rest.substr(hash);
                    rest = rest.slice(0, hash);
                }
                var qm = rest.indexOf('?');
                if (qm !== -1) {
                    this.search = rest.substr(qm);
                    this.query = rest.substr(qm + 1);
                    if (parseQueryString) {
                        this.query = querystring.parse(this.query);
                    }
                    rest = rest.slice(0, qm);
                } else if (parseQueryString) {
                    // no query string, but parseQueryString still requested
                    this.search = '';
                    this.query = {};
                }
                if (rest) this.pathname = rest;
                if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
                    this.pathname = '/';
                }
                
                //to support http.request
                if (this.pathname || this.search) {
                    var p = this.pathname || '';
                    var s = this.search || '';
                    this.path = p + s;
                }
                
                // finally, reconstruct the href based on what has been validated.
                this.href = this.format();
                return this;
            };
            
            // format a parsed object into a url string
            function urlFormat(obj) {
                // ensure it's an object, and not a string url.
                // If it's an obj, this is a no-op.
                // this way, you can call url_format() on strings
                // to clean up potentially wonky urls.
                if (isString(obj)) obj = urlParse(obj);
                if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
                return obj.format();
            }
            
            Url.prototype.format = function () {
                var auth = this.auth || '';
                if (auth) {
                    auth = encodeURIComponent(auth);
                    auth = auth.replace(/%3A/i, ':');
                    auth += '@';
                }
                
                var protocol = this.protocol || '',
                    pathname = this.pathname || '',
                    hash = this.hash || '',
                    host = false,
                    query = '';
                
                if (this.host) {
                    host = auth + this.host;
                } else if (this.hostname) {
                    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
                    if (this.port) {
                        host += ':' + this.port;
                    }
                }
                
                if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
                    query = querystring.stringify(this.query);
                }
                
                var search = this.search || (query && ('?' + query)) || '';
                
                if (protocol && protocol.substr(-1) !== ':') protocol += ':';
                
                // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
                // unless they had them to begin with.
                if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
                    host = '//' + (host || '');
                    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
                } else if (!host) {
                    host = '';
                }
                
                if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
                if (search && search.charAt(0) !== '?') search = '?' + search;
                
                pathname = pathname.replace(/[?#]/g, function (match) {
                    return encodeURIComponent(match);
                });
                search = search.replace('#', '%23');
                
                return protocol + host + pathname + search + hash;
            };
            
            function urlResolve(source, relative) {
                return urlParse(source, false, true).resolve(relative);
            }
            
            Url.prototype.resolve = function (relative) {
                return this.resolveObject(urlParse(relative, false, true)).format();
            };
            
            function urlResolveObject(source, relative) {
                if (!source) return relative;
                return urlParse(source, false, true).resolveObject(relative);
            }
            
            Url.prototype.resolveObject = function (relative) {
                if (isString(relative)) {
                    var rel = new Url();
                    rel.parse(relative, false, true);
                    relative = rel;
                }
                
                var result = new Url();
                Object.keys(this).forEach(function (k) {
                    result[k] = this[k];
                }, this);
                
                // hash is always overridden, no matter what.
                // even href="" will remove it.
                result.hash = relative.hash;
                
                // if the relative url is empty, then there's nothing left to do here.
                if (relative.href === '') {
                    result.href = result.format();
                    return result;
                }
                
                // hrefs like //foo/bar always cut to the protocol.
                if (relative.slashes && !relative.protocol) {
                    // take everything except the protocol from relative
                    Object.keys(relative).forEach(function (k) {
                        if (k !== 'protocol')
                            result[k] = relative[k];
                    });
                    
                    //urlParse appends trailing / to urls like http://www.example.com
                    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
                        result.path = result.pathname = '/';
                    }
                    
                    result.href = result.format();
                    return result;
                }
                
                if (relative.protocol && relative.protocol !== result.protocol) {
                    // if it's a known url protocol, then changing
                    // the protocol does weird things
                    // first, if it's not file:, then we MUST have a host,
                    // and if there was a path
                    // to begin with, then we MUST have a path.
                    // if it is file:, then the host is dropped,
                    // because that's known to be hostless.
                    // anything else is assumed to be absolute.
                    if (!slashedProtocol[relative.protocol]) {
                        Object.keys(relative).forEach(function (k) {
                            result[k] = relative[k];
                        });
                        result.href = result.format();
                        return result;
                    }
                    
                    result.protocol = relative.protocol;
                    if (!relative.host && !hostlessProtocol[relative.protocol]) {
                        var relPath = (relative.pathname || '').split('/');
                        while (relPath.length && !(relative.host = relPath.shift()))                        ;
                        if (!relative.host) relative.host = '';
                        if (!relative.hostname) relative.hostname = '';
                        if (relPath[0] !== '') relPath.unshift('');
                        if (relPath.length < 2) relPath.unshift('');
                        result.pathname = relPath.join('/');
                    } else {
                        result.pathname = relative.pathname;
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    result.host = relative.host || '';
                    result.auth = relative.auth;
                    result.hostname = relative.hostname || relative.host;
                    result.port = relative.port;
                    // to support http.request
                    if (result.pathname || result.search) {
                        var p = result.pathname || '';
                        var s = result.search || '';
                        result.path = p + s;
                    }
                    result.slashes = result.slashes || relative.slashes;
                    result.href = result.format();
                    return result;
                }
                
                var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
                    isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
),
                    mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
                    removeAllDots = mustEndAbs,
                    srcPath = result.pathname && result.pathname.split('/') || [],
                    relPath = relative.pathname && relative.pathname.split('/') || [],
                    psychotic = result.protocol && !slashedProtocol[result.protocol];
                
                // if the url is a non-slashed url, then relative
                // links like ../.. should be able
                // to crawl up to the hostname, as well.  This is strange.
                // result.protocol has already been set by now.
                // Later on, put the first path part into the host field.
                if (psychotic) {
                    result.hostname = '';
                    result.port = null;
                    if (result.host) {
                        if (srcPath[0] === '') srcPath[0] = result.host;
                        else srcPath.unshift(result.host);
                    }
                    result.host = '';
                    if (relative.protocol) {
                        relative.hostname = null;
                        relative.port = null;
                        if (relative.host) {
                            if (relPath[0] === '') relPath[0] = relative.host;
                            else relPath.unshift(relative.host);
                        }
                        relative.host = null;
                    }
                    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
                }
                
                if (isRelAbs) {
                    // it's absolute.
                    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
                    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
                    result.search = relative.search;
                    result.query = relative.query;
                    srcPath = relPath;
    // fall through to the dot-handling below.
                } else if (relPath.length) {
                    // it's relative
                    // throw away the existing file, and take the new path instead.
                    if (!srcPath) srcPath = [];
                    srcPath.pop();
                    srcPath = srcPath.concat(relPath);
                    result.search = relative.search;
                    result.query = relative.query;
                } else if (!isNullOrUndefined(relative.search)) {
                    // just pull out the search.
                    // like href='?foo'.
                    // Put this after the other two cases because it simplifies the booleans
                    if (psychotic) {
                        result.hostname = result.host = srcPath.shift();
                        //occationaly the auth can get stuck only in host
                        //this especialy happens in cases like
                        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                        var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
                        if (authInHost) {
                            result.auth = authInHost.shift();
                            result.host = result.hostname = authInHost.shift();
                        }
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    //to support http.request
                    if (!isNull(result.pathname) || !isNull(result.search)) {
                        result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
                    }
                    result.href = result.format();
                    return result;
                }
                
                if (!srcPath.length) {
                    // no path at all.  easy.
                    // we've already handled the other stuff above.
                    result.pathname = null;
                    //to support http.request
                    if (result.search) {
                        result.path = '/' + result.search;
                    } else {
                        result.path = null;
                    }
                    result.href = result.format();
                    return result;
                }
                
                // if a url ENDs in . or .., then it must get a trailing slash.
                // however, if it ends in anything else non-slashy,
                // then it must NOT get a trailing slash.
                var last = srcPath.slice(-1)[0];
                var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');
                
                // strip single dots, resolve double dots to parent dir
                // if the path tries to go above the root, `up` ends up > 0
                var up = 0;
                for (var i = srcPath.length; i >= 0; i--) {
                    last = srcPath[i];
                    if (last == '.') {
                        srcPath.splice(i, 1);
                    } else if (last === '..') {
                        srcPath.splice(i, 1);
                        up++;
                    } else if (up) {
                        srcPath.splice(i, 1);
                        up--;
                    }
                }
                
                // if the path is allowed to go above the root, restore leading ..s
                if (!mustEndAbs && !removeAllDots) {
                    for (; up--; up) {
                        srcPath.unshift('..');
                    }
                }
                
                if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
                    srcPath.unshift('');
                }
                
                if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
                    srcPath.push('');
                }
                
                var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');
                
                // put the host back
                if (psychotic) {
                    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
                    //occationaly the auth can get stuck only in host
                    //this especialy happens in cases like
                    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
                    if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift();
                    }
                }
                
                mustEndAbs = mustEndAbs || (result.host && srcPath.length);
                
                if (mustEndAbs && !isAbsolute) {
                    srcPath.unshift('');
                }
                
                if (!srcPath.length) {
                    result.pathname = null;
                    result.path = null;
                } else {
                    result.pathname = srcPath.join('/');
                }
                
                //to support request.http
                if (!isNull(result.pathname) || !isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
                }
                result.auth = relative.auth || result.auth;
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result;
            };
            
            Url.prototype.parseHost = function () {
                var host = this.host;
                var port = portPattern.exec(host);
                if (port) {
                    port = port[0];
                    if (port !== ':') {
                        this.port = port.substr(1);
                    }
                    host = host.substr(0, host.length - port.length);
                }
                if (host) this.hostname = host;
            };
            
            function isString(arg) {
                return typeof arg === "string";
            }
            
            function isObject(arg) {
                return typeof arg === 'object' && arg !== null;
            }
            
            function isNull(arg) {
                return arg === null;
            }
            function isNullOrUndefined(arg) {
                return arg == null;
            }

        }, { "punycode": 323, "querystring": 326 }], 341: [function (require, module, exports) {
            module.exports = function isBuffer(arg) {
                return arg && typeof arg === 'object' 
    && typeof arg.copy === 'function' 
    && typeof arg.fill === 'function' 
    && typeof arg.readUInt8 === 'function';
            }
        }, {}], 342: [function (require, module, exports) {
            (function (process, global) {
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                
                var formatRegExp = /%[sdj%]/g;
                exports.format = function (f) {
                    if (!isString(f)) {
                        var objects = [];
                        for (var i = 0; i < arguments.length; i++) {
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(' ');
                    }
                    
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function (x) {
                        if (x === '%%') return '%';
                        if (i >= len) return x;
                        switch (x) {
                            case '%s': return String(args[i++]);
                            case '%d': return Number(args[i++]);
                            case '%j':
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return '[Circular]';
                                }
                            default:
                                return x;
                        }
                    });
                    for (var x = args[i]; i < len; x = args[++i]) {
                        if (isNull(x) || !isObject(x)) {
                            str += ' ' + x;
                        } else {
                            str += ' ' + inspect(x);
                        }
                    }
                    return str;
                };
                
                
                // Mark that a method should not be used.
                // Returns a modified function which warns once by default.
                // If --no-deprecation is set, then it is a no-op.
                exports.deprecate = function (fn, msg) {
                    // Allow for deprecating things in the process of starting up.
                    if (isUndefined(global.process)) {
                        return function () {
                            return exports.deprecate(fn, msg).apply(this, arguments);
                        };
                    }
                    
                    if (process.noDeprecation === true) {
                        return fn;
                    }
                    
                    var warned = false;
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }
                    
                    return deprecated;
                };
                
                
                var debugs = {};
                var debugEnviron;
                exports.debuglog = function (set) {
                    if (isUndefined(debugEnviron))
                        debugEnviron = process.env.NODE_DEBUG || '';
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                            var pid = process.pid;
                            debugs[set] = function () {
                                var msg = exports.format.apply(exports, arguments);
                                console.error('%s %d: %s', set, pid, msg);
                            };
                        } else {
                            debugs[set] = function () { };
                        }
                    }
                    return debugs[set];
                };
                
                
                /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                exports.inspect = inspect;
                
                
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    'bold' : [1, 22],
                    'italic' : [3, 23],
                    'underline' : [4, 24],
                    'inverse' : [7, 27],
                    'white' : [37, 39],
                    'grey' : [90, 39],
                    'black' : [30, 39],
                    'blue' : [34, 39],
                    'cyan' : [36, 39],
                    'green' : [32, 39],
                    'magenta' : [35, 39],
                    'red' : [31, 39],
                    'yellow' : [33, 39]
                };
                
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    'special': 'cyan',
                    'number': 'yellow',
                    'boolean': 'yellow',
                    'undefined': 'grey',
                    'null': 'bold',
                    'string': 'green',
                    'date': 'magenta',
                    // "name": intentionally not styling
                    'regexp': 'red'
                };
                
                
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    
                    if (style) {
                        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
                    } else {
                        return str;
                    }
                }
                
                
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                
                
                function arrayToHash(array) {
                    var hash = {};
                    
                    array.forEach(function (val, idx) {
                        hash[val] = true;
                    });
                    
                    return hash;
                }
                
                
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    
                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }
                    
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) 
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                        return formatError(value);
                    }
                    
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ': ' + value.name : '';
                            return ctx.stylize('[Function' + name + ']', 'special');
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), 'date');
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    
                    var base = '', array = false, braces = ['{', '}'];
                    
                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = ['[', ']'];
                    }
                    
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ': ' + value.name : '';
                        base = ' [Function' + n + ']';
                    }
                    
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = ' ' + RegExp.prototype.toString.call(value);
                    }
                    
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = ' ' + Date.prototype.toUTCString.call(value);
                    }
                    
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = ' ' + formatError(value);
                    }
                    
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        } else {
                            return ctx.stylize('[Object]', 'special');
                        }
                    }
                    
                    ctx.seen.push(value);
                    
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function (key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    
                    ctx.seen.pop();
                    
                    return reduceToSingleString(output, base, braces);
                }
                
                
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value))
                        return ctx.stylize('undefined', 'undefined');
                    if (isString(value)) {
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    }
                    if (isNumber(value))
                        return ctx.stylize('' + value, 'number');
                    if (isBoolean(value))
                        return ctx.stylize('' + value, 'boolean');
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value))
                        return ctx.stylize('null', 'null');
                }
                
                
                function formatError(value) {
                    return '[' + Error.prototype.toString.call(value) + ']';
                }
                
                
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for (var i = 0, l = value.length; i < l; ++i) {
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
                        } else {
                            output.push('');
                        }
                    }
                    keys.forEach(function (key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
                        }
                    });
                    return output;
                }
                
                
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special');
                        } else {
                            str = ctx.stylize('[Getter]', 'special');
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize('[Setter]', 'special');
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = '[' + key + ']';
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf('\n') > -1) {
                                if (array) {
                                    str = str.split('\n').map(function (line) {
                                        return '  ' + line;
                                    }).join('\n').substr(2);
                                } else {
                                    str = '\n' + str.split('\n').map(function (line) {
                                        return '   ' + line;
                                    }).join('\n');
                                }
                            }
                        } else {
                            str = ctx.stylize('[Circular]', 'special');
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify('' + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.substr(1, name.length - 2);
                            name = ctx.stylize(name, 'name');
                        } else {
                            name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, 'string');
                        }
                    }
                    
                    return name + ': ' + str;
                }
                
                
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function (prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf('\n') >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                    }, 0);
                    
                    if (length > 60) {
                        return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
                    }
                    
                    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                }
                
                
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                exports.isArray = isArray;
                
                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }
                exports.isBoolean = isBoolean;
                
                function isNull(arg) {
                    return arg === null;
                }
                exports.isNull = isNull;
                
                function isNullOrUndefined(arg) {
                    return arg == null;
                }
                exports.isNullOrUndefined = isNullOrUndefined;
                
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                exports.isNumber = isNumber;
                
                function isString(arg) {
                    return typeof arg === 'string';
                }
                exports.isString = isString;
                
                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }
                exports.isSymbol = isSymbol;
                
                function isUndefined(arg) {
                    return arg === void 0;
                }
                exports.isUndefined = isUndefined;
                
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }
                exports.isRegExp = isRegExp;
                
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                exports.isObject = isObject;
                
                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }
                exports.isDate = isDate;
                
                function isError(e) {
                    return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
                }
                exports.isError = isError;
                
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                exports.isFunction = isFunction;
                
                function isPrimitive(arg) {
                    return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
                }
                exports.isPrimitive = isPrimitive;
                
                exports.isBuffer = require('./support/isBuffer');
                
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                
                
                function pad(n) {
                    return n < 10 ? '0' + n.toString(10) : n.toString(10);
                }
                
                
                var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];
                
                // 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
                    return [d.getDate(), months[d.getMonth()], time].join(' ');
                }
                
                
                // log is just a thin wrapper to console.log that prepends a timestamp
                exports.log = function () {
                    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
                };
                
                
                /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');
                
                exports._extend = function (origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while (i--) {
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };
                
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }

            }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, { "./support/isBuffer": 341, "_process": 322, "inherits": 318 }], 343: [function (require, module, exports) {
            var indexOf = require('indexof');
            
            var Object_keys = function (obj) {
                if (Object.keys) return Object.keys(obj)
                else {
                    var res = [];
                    for (var key in obj) res.push(key)
                    return res;
                }
            };
            
            var forEach = function (xs, fn) {
                if (xs.forEach) return xs.forEach(fn)
                else for (var i = 0; i < xs.length; i++) {
                    fn(xs[i], i, xs);
                }
            };
            
            var defineProp = (function () {
                try {
                    Object.defineProperty({}, '_', {});
                    return function (obj, name, value) {
                        Object.defineProperty(obj, name, {
                            writable: true,
                            enumerable: false,
                            configurable: true,
                            value: value
                        })
                    };
                } catch (e) {
                    return function (obj, name, value) {
                        obj[name] = value;
                    };
                }
            }());
            
            var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];
            
            function Context() { }
            Context.prototype = {};
            
            var Script = exports.Script = function NodeScript(code) {
                if (!(this instanceof Script)) return new Script(code);
                this.code = code;
            };
            
            Script.prototype.runInContext = function (context) {
                if (!(context instanceof Context)) {
                    throw new TypeError("needs a 'context' argument.");
                }
                
                var iframe = document.createElement('iframe');
                if (!iframe.style) iframe.style = {};
                iframe.style.display = 'none';
                
                document.body.appendChild(iframe);
                
                var win = iframe.contentWindow;
                var wEval = win.eval, wExecScript = win.execScript;
                
                if (!wEval && wExecScript) {
                    // win.eval() magically appears when this is called in IE:
                    wExecScript.call(win, 'null');
                    wEval = win.eval;
                }
                
                forEach(Object_keys(context), function (key) {
                    win[key] = context[key];
                });
                forEach(globals, function (key) {
                    if (context[key]) {
                        win[key] = context[key];
                    }
                });
                
                var winKeys = Object_keys(win);
                
                var res = wEval.call(win, this.code);
                
                forEach(Object_keys(win), function (key) {
                    // Avoid copying circular objects like `top` and `window` by only
                    // updating existing context properties or new properties in the `win`
                    // that was only introduced after the eval.
                    if (key in context || indexOf(winKeys, key) === -1) {
                        context[key] = win[key];
                    }
                });
                
                forEach(globals, function (key) {
                    if (!(key in context)) {
                        defineProp(context, key, win[key]);
                    }
                });
                
                document.body.removeChild(iframe);
                
                return res;
            };
            
            Script.prototype.runInThisContext = function () {
                return eval(this.code); // maybe...
            };
            
            Script.prototype.runInNewContext = function (context) {
                var ctx = Script.createContext(context);
                var res = this.runInContext(ctx);
                
                forEach(Object_keys(ctx), function (key) {
                    context[key] = ctx[key];
                });
                
                return res;
            };
            
            forEach(Object_keys(Script.prototype), function (name) {
                exports[name] = Script[name] = function (code) {
                    var s = Script(code);
                    return s[name].apply(s, [].slice.call(arguments, 1));
                };
            });
            
            exports.createScript = function (code) {
                return exports.Script(code);
            };
            
            exports.createContext = Script.createContext = function (context) {
                var copy = new Context();
                if (typeof context === 'object') {
                    forEach(Object_keys(context), function (key) {
                        copy[key] = context[key];
                    });
                }
                return copy;
            };

        }, { "indexof": 344 }], 344: [function (require, module, exports) {
            
            var indexOf = [].indexOf;
            
            module.exports = function (arr, obj) {
                if (indexOf) return arr.indexOf(obj);
                for (var i = 0; i < arr.length; ++i) {
                    if (arr[i] === obj) return i;
                }
                return -1;
            };
        }, {}]
}, {}, [1]);