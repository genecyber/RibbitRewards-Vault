{
  "name": "telehash",
  "version": "0.3.27",
  "main": "index.js",
  "dependencies": {
    "e3x": "git+https://github.com/telehash/e3x-js.git",
    "hashname": "git+https://github.com/telehash/hashname.git",
    "json-stable-stringify": "~1.0.0",
    "lob-enc": "git+https://github.com/telehash/lob-enc.git",
    "localstorage-fs": "~0.1.0",
    "optimist": "~0.6.1",
    "path-extra": "~0.3.0",
    "telehash-http": "git+https://github.com/quartzjer/telehash-http.git",
    "telehash-tcp4": "git+https://github.com/quartzjer/telehash-tcp4.git",
    "telehash-udp4": "git+https://github.com/quartzjer/telehash-udp4.git",
    "telehash-webrtc": "git+https://github.com/quartzjer/telehash-webrtc.git"
  },
  "devDependencies": {
    "chai": "*",
    "concat-stream": "~1.4.6",
    "event-stream": "~3.1.7",
    "mocha": "*"
  },
  "browser": {
    "fs": "localstorage-fs",
    "telehash-udp4": false,
    "telehash-tcp4": false
  },
  "bin": {
    "router": "./bin/router.js",
    "mesh": "./bin/mesh.js"
  },
  "scripts": {
    "browserify": "browserify index.js -o bundle.js",
    "browser": "browserify index.js -o bundle.js && node test/browser/server.js",
    "start": "node ./bin/router.js",
    "router": "node ./bin/router.js",
    "mesh": "node ./bin/mesh.js",
    "test": "make test"
  },
  "testling": {
    "harness": "mocha-bdd",
    "files": "test/*.js",
    "browsers": [
      "ie/8..latest",
      "chrome/latest",
      "firefox/latest"
    ]
  },
  "keywords": [
    "telehash",
    "crypto",
    "p2p",
    "json",
    "mesh"
  ],
  "description": "A telehash library for node and browserify",
  "homepage": "https://github.com/telehash/telehash-js",
  "repository": {
    "type": "git",
    "url": "https://github.com/telehash/telehash-js.git"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/telehash/telehash-js/raw/master/LICENSE"
    }
  ],
  "author": {
    "name": "Jeremie Miller",
    "email": "jeremie@jabber.org",
    "url": "http://jeremie.com/"
  },
  "maintainers": [
    {
      "name": "Jeremie Miller",
      "email": "jeremie@jabber.org",
      "url": "http://jeremie.com/"
    }
  ],
  "engines": {
    "node": "0.10.x",
    "npm": ">1.2.x"
  },
  "readme": "# Overview\n\n[![Build Status](https://travis-ci.org/telehash/telehash-js.svg?branch=v3)](https://travis-ci.org/telehash/telehash-js)\n\n[![telehash](https://nodei.co/npm/telehash.png)](https://nodei.co/npm/telehash/)\n\nThis module presents a simple high-level API for using [telehash v3](https://github.com/telehash/telehash.org/tree/master/v3) for both node and browserify.\n\nThe browser crypto that powers this is only possible thanks to the incredible work done by the team behind [Forge](https://github.com/digitalbazaar/forge), [Tom Wu](http://www-cs-students.stanford.edu/~tjw/), and the [Sanford Javascript Crypto Library](https://github.com/bitwiseshiftleft/sjcl).\n\n# Router\n\nTelehash apps usually need one or more mesh routers to assist in establishing p2p links.  You can run your own router via `npm start`, manually via `node bin/router.js`, or just `router` if you did an `npm install -g`.  The JSON object from the router output can be passed in to the `mesh.link({...})` function (shown below) or stored in your own `links.json` locally.\n\n# Library Interface\n\n## Local Endpoint Identity Generation\n\nTo create a new hashname:\n\n```js\nvar th = require(\"telehash\");\nth.generate(function(err, endpoint){\n  if(err) return console.log(\"endpoint generation failed\",err);\n  // endpoint contains a `keys:{}`, `secrets:{}`, and `hashname:\"...\"` \n});\n```\n\n## Mesh Creation\n\nNeeds an endpoint id object from a previously run `generate()` to initialize from:\n\n```js\nvar th = require(\"telehash\");\nvar id = {\"keys\":{\"1a\":\"akndnx5kbansip6xphxymwckpqkjj26fcm\"},\"secrets\":{\"1a\":\"ksxslm5mmtymnbph7nvxergb7oy3r35u\"},\"hashname\":\"5uegloufcyvnf34jausszmsabbfbcrg6fyxpcqzhddqxeefuapvq\"};\n\nvar mesh = th.mesh({id:id});\n```\n\nA second argument can be passed and will be called after the mesh is fully initialized, and return any startup errors:\n\n```js\nth.mesh({id:id}, function(err, mesh){\n  if(err) return console.log(\"mesh failed to initialize\",err);\n  // use mesh.* now\n  console.log(mesh.uri());\n});\n```\n\nThe args passed in to the `mesh` may include:\n\n* **id** - An endpoint id object previously generated\n* **links** - An object in the [mesh json](https://github.com/telehash/telehash.org/blob/master/v3/json.md) format that will be auto-loaded\n\nIn node, the `id` and `links` can be strings pointing to local filenames that will be auto-loaded.  In the browser they can be string keys to localStorage.  Those locations will also be generated and kept in sync for any changes.\n\n## Establishing Links\n\nA link can be created with just a hashname (this requires a router to assist):\n\n````js\nvar link = mesh.link(hashname);\n// will be called when link status changes, err is undefined when link is up\nlink.status(function(err){\n  if(err) {\n    console.log('disconnected',err);\n    return;\n  }\n  console.log('connected');\n  // can do any other link.* methods\n});\n````\n\nA link can also be establish directly (no router required):\n\n````js\nvar link = mesh.link({keys:{},paths:{}});\n````\n\nThe `.link({args})` will also take an argument of `\"jwt\":\"...\"` to include a [JWT](http://jwt.io/) in the link request for identifying/authorizing the sender.\n\n### Accepting/Authorizing Links\n\nWhen an incoming link is requested the local app must decide if it accepts that link.  By default all unknown links/senders are ignored and never responded to in order to protect the privacy of the recipient.\n\nTo process incoming link requests:\n\n````js\nmesh.accept = function(from){};\n````\n\nThe accept function will always be called with a from object that includes the hashname of the sender and any additional details about the request including `keys`, `paths`, and all handshake types received as `hset`.\n\nTo authorize/accept the request, simply perform a `mesh.link(from)` and it will respond and create the link.\n\n## Routing\n\nBy default every endpoint will assist with routing between any of the active links in its mesh in order to maximize connectivity, but this requires the routing endpoint to be connected to both which may not always be the case.\n\nOne or more links can be dedicated routers for all other link requests, and/or any link can be used as a router for another:\n\n````js\nmesh.router(link); // any link can be used as a default router\nmesh.link({...,router:true}); // another way to set a link as a default router from the start\n\nlink.router(link); // just one link can be used as a router for another\nmesh.link({...,paths:[{type:'peer',hn:'linked'}]}); // including a peer path to an already-linked hashname will automatically use it as a router\n````\n\nWhenever a default router is added, it will also be advertised to other links as a peer path for this endpoint.\n\n## Discovery Mode\n\nDiscovery mode enables any network transport to send un-encrypted announcements to any other endpoints that are available locally only. This can be used to automatically establish a link to a local peer when there is no other mechanism to exchange keys, such as when they are offline.\n\nIt is important to note that this should be used sparingly, as anything on a local network will be made aware of the sending hashname.  While this is generally very low risk, it should not be left on by default except in special cases.\n\n````js\nmesh.discover(true); // to enable\nmesh.discover(false); // to disable (default)\n````\n\nWhile discover is enabled, `mesh.accept` will be called for all discovered local endpoints.\n\nOptional args and a callback (to know once discovery is enabled on all the transports) can be passed in:\n\n````js\nmesh.discover({args},done);\n````\n\nThe args can include:\n\n* `jwt` - a JWT to include in the announcement to help identify the sender\n* custom per-transport discovery options may be passed in\n\n## Extensions\n\nMost functionality is added by extending the core library to support additional channels and expose more methods. The built-in extensions live in the [ext](ext/) folder, but additional ones can be added by the app.\n\n* **path** - check and synchronize all network paths on a link:\n````js\nlink.ping(function(err, latency){\n  // error if it failed\n  // latency is number of milliseconds if it succeeded (may be 0)\n});\n````\n\n* **stream** - native duplex `Stream` creation, also supports streaming objects\n````js\nlink.stream(); // returns a new duplex stream to this link, optional args are sent to the link during creation\nfs.createReadStream(filein).pipe(link.stream()); // can be used as a pipe\n// to receive incoming streams\nmesh.stream(function(link, args, cbAccept){\n  // link is who it came from\n  // args is set if any were given by the sender\n  // call cbAccept(err); to cancel\n  // cbAccept() returns a duplex stream\n  cbAccept().pipe(fs.createWriteStream(fileout));\n});\n````\n\n* **chat** - send and receive one-to-one or group chat messages\n> draft implementation, works but is minimal\n````js\n// create or set args.id and args.leader to join a new chat\nmesh.chat(args, profile, function(err, chat){\n  chat.inbox; // incoming message stream\n  chat.outbox; // stream to send messages\n  chat.profiles; // hn->profile\n  chat.messages; // cache/index by message id\n  chat.log; // ordered known chat history [\"id2\", \"id1\", ...]\n  chat.join(link); // leader can use to accept/invite others\n});\n\n// set handler for when invited to a chat\nmesh.invited(function(link, profile){});\n````\n\n### Extension Backing API\n\nExtensions typically involve:\n\n* handling one or more channel types\n* adding one or more methods to a created mesh instance\n* adding one or more methods to every link instance within a mesh\n* providing a transport\n\nUsing an interface like:\n\n````\nvar ext = require('ext');\next.name; // unique string name for debugging\ntelehash.add(ext); // just does telehash.extensions[ext.name] = ext; \nmesh.extend(ext,cb); // or per mesh, auto-run for all .extensions\n// calls:\nif(ext.mesh) ext.mesh(mesh, cb(err));\nif(ext.link) ext.link(link, cb(err));\n````\n\n\n## Transports\n\nA mesh will use all available transports to establish and maintain a link.\n\n### Transport Backing API\n\nAll transports are implemented as an extension that exposes the functionality of:\n\n* turnin a path into a pipe, pipe has a path (if any)\n* incoming packets with a pipe\n* outgoing packets to a pipe\n* pipe event of keepalive, closed, and changed\n* return available source paths\n* enable discovery mode\n\nUsing an interface like:\n\n````\nvar tpx = require('telehash-x');\n// mesh.receive = function(packet,pipe){ };\ntpx.mesh(mesh,function(err, tp){\n  tp.pipe(path, function(pipe){\n    pipe.path; // current json object (if addressable)\n    pipe.on('keepalive', function(){}) // adds callback, return false to unregister, called on all events\n    pipe.send(packet)\n  });\n  var paths = tp.paths(); // return array of current addressible paths, if any\n  tp.discover({packet:packet}, cb); // enables/disables discovery mode, will create new pipes for incoming, cb when done\n});\n````\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/telehash/telehash-js/issues"
  },
  "_id": "telehash@0.3.27",
  "dist": {
    "shasum": "29a28f4a430a9bfbc5e06289793d610c5fe6e21d"
  },
  "_from": "telehash@",
  "_resolved": "https://registry.npmjs.org/telehash/-/telehash-0.3.27.tgz"
}
